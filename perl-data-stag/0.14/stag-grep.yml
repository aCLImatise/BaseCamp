!Command
positional:
- !Positional
  description: the name of the node/element we are filtering on
  position: 0
  name: NODE
  optional: false
- !Positional
  description: the file to be parser. If no parser option is supplied, this is assumed
    to a be a stag compatible syntax (xml, sxpr or itext); otherwise you should parse
    in a parser name or a parser module that throws stag events
  position: 1
  name: FILE
  optional: false
named: []
command:
- stag-grep.pl
parent:
subcommands: []
help_flag:
usage_flag:
version_flag:
help_text: "\e[1mNAME\e[0m\n    stag-grep - filters a stag file (xml, itext, sxpr)\
  \ for nodes of interest\n\n\e[1mSYNOPSIS\e[0m\n      stag-grep person -q name=fred\
  \ file1.xml\n\n      stag-grep person 'sub {shift->get_name =~ /^A*/}' file1.xml\n\
  \n      stag-grep -p My::Foo -w sxpr record 'sub{..}' file2\n\n\e[1mUSAGE\e[0m\n\
  \      stag-grep [-p|parser PARSER] [-w|writer WRITER] NODE -q tag=val FILE\n\n\
  \      stag-grep [-p|parser PARSER] [-w|writer WRITER] NODE SUB FILE\n\n      stag-grep\
  \ [-p|parser PARSER] [-w|writer WRITER]  NODE -f PERLFILE FILE\n\n\e[1mDESCRIPTION\e\
  [0m\n    parsers an input file using the specified parser (which may be a built\
  \ in\n    stag parser, such as xml) and filters the resulting stag tree according\
  \ to\n    a user-supplied subroutine, writing out only the nodes/elements that pass\n\
  \    the test.\n\n    the parser is event based, so it should be able to handle\
  \ large files\n    (although if the node you parse is large, it will take up more\
  \ memory)\n\n\e[1mARGUMENTS\e[0m\n    -p|parser FORMAT\n        FORMAT is one of\
  \ xml, sxpr or itext, or the name of a perl module\n\n        xml assumed as default\n\
  \n    -w|writer FORMAT\n        FORMAT is one of xml, sxpr or itext, or the name\
  \ of a perl module\n\n    -c|count\n        prints the number of nodes that pass\
  \ the test\n\n    -filterfile|f\n        a file containing a perl subroutine (in\
  \ place of the SUB argument)\n\n    -q|query TAG1=VAL1 -q|query TAG2=VAL2 ... -q|query\
  \ TAGN=VALN\n        filters based on the field TAG\n\n        other operators can\
  \ be used too - eg <, <=, etc\n\n        multiple q arguments can be passed in\n\
  \n        for more complex operations, pass in your own subroutine, see below\n\n\
  \    SUB a perl subroutine. this subroutine is evaluated evry time NODE is\n   \
  \     encountered - the stag object for NODE is passed into the subroutine.\n\n\
  \        if the subroutine passes, the node will be passed to the writer for\n \
  \       display\n\n    NODE\n        the name of the node/element we are filtering\
  \ on\n\n    FILE\n        the file to be parser. If no parser option is supplied,\
  \ this is\n        assumed to a be a stag compatible syntax (xml, sxpr or itext);\n\
  \        otherwise you should parse in a parser name or a parser module that\n \
  \       throws stag events\n\n\e[1mSEE ALSO\e[0m\n    Data::Stag\n\n"
generated_using:
- --help
