!Command
command:
- design.py
positional:
- !Positional
  optional: false
  position: 0
  name: dataset
  description: "One or more target datasets (e.g., one per species).\nEach dataset\
    \ can be specified in one of multiple ways.\n(a) If dataset is in the format 'download:TAXID',\
    \ then\nCATCH downloads from NCBI all whole genomes for the\nNCBI taxonomy with\
    \ id TAXID, and uses these sequences\nas input. (b) If dataset is a path to a\
    \ FASTA file,\nthen its sequences are read and used as input. (c)\nOtherwise,\
    \ it is assumed that this is a label for a\ndataset included in this package (e.g.,\
    \ 'zika'). If\nthe label starts with 'collection:' (e.g.,\n'collection:viruses_with_human_host'),\
    \ then this reads\nfrom an available collection of datasets. For\nsegmented viruses,\
    \ the format for NCBI downloads can\nalso be 'download:TAXID-SEGMENT'."
named:
- !Flag
  optional: true
  synonyms:
  - -o
  - --output-probes
  description: "The file to which all final probes should be written;\nthey are written\
    \ in FASTA format"
  args: !SimpleFlagArg
    name: OUTPUT_PROBES
- !Flag
  optional: true
  synonyms:
  - --write-taxid-acc
  description: "If 'download:' labels are used in datasets, write\ndownloaded accessions\
    \ to a file in this directory.\nAccessions are written to WRITE_TAXID_ACC/TAXID.txt"
  args: !SimpleFlagArg
    name: WRITE_TAXID_ACC
- !Flag
  optional: true
  synonyms:
  - -pl
  - --probe-length
  description: (Optional) Make probes be PROBE_LENGTH nt long
  args: !SimpleFlagArg
    name: PROBE_LENGTH
- !Flag
  optional: true
  synonyms:
  - -ps
  - --probe-stride
  description: "(Optional) Generate candidate probes from the input\nthat are separated\
    \ by PROBE_STRIDE nt"
  args: !SimpleFlagArg
    name: PROBE_STRIDE
- !Flag
  optional: true
  synonyms:
  - -m
  - --mismatches
  description: "(Optional) Allow for MISMATCHES mismatches when\ndetermining whether\
    \ a probe covers a sequence"
  args: !SimpleFlagArg
    name: MISMATCHES
- !Flag
  optional: true
  synonyms:
  - -l
  - --lcf-thres
  description: "(Optional) Say that a portion of a probe covers a\nportion of a sequence\
    \ if the two share a substring\nwith at most MISMATCHES mismatches that has length\
    \ >=\nLCF_THRES nt; if unspecified, this is set to\nPROBE_LENGTH"
  args: !SimpleFlagArg
    name: LCF_THRES
- !Flag
  optional: true
  synonyms:
  - --island-of-exact-match
  description: "(Optional) When determining whether a probe covers a\nsequence, require\
    \ that there be an exact match (i.e.,\nno mismatches) of length at least\nISLAND_OF_EXACT_MATCH\
    \ nt between a portion of the\nprobe and a portion of the sequence"
  args: !SimpleFlagArg
    name: ISLAND_OF_EXACT_MATCH
- !Flag
  optional: true
  synonyms:
  - --custom-hybridization-fn
  description: "CUSTOM_HYBRIDIZATION_FN\n(Optional) Args: <PATH> <FUNC>; PATH is a\
    \ path to a\nPython module (.py file) and FUNC is a string giving\nthe name of\
    \ a function in that module. FUNC provides a\ncustom model of hybridization between\
    \ a probe and\ntarget sequence to use in the probe set design. If\nthis is set,\
    \ the arguments --mismatches, --lcf-thres,\nand --island-of-exact-match are not\
    \ used because these\nare meant for the default model of hybridization. The\n\
    function FUNC in PATH is dynamically loaded to use\nwhen determining whether a\
    \ probe hybridizes to a\ntarget sequence (and, if so, what portion). FUNC must\n\
    accept the following arguments in order, though it may\nchoose to ignore some\
    \ values: (1) array giving\nsequence of a probe; (2) str giving subsequence of\n\
    target sequence to which the probe may hybridize, of\nthe same length as the given\
    \ probe sequence; (3) int\ngiving the position in the probe (equivalently, the\n\
    target subsequence) of the start of a k-mer around\nwhich the probe and target\
    \ subsequence are anchored\n(the probe and target subsequence are aligned using\n\
    this k-mer as an anchor); (4) int giving the end\nposition (exclusive) of the\
    \ anchor k-mer; (5) int\ngiving the full length of the probe (the probe\nprovided\
    \ in (1) may be cutoff on an end if it extends\nfurther than where the target\
    \ sequence ends); (6) int\ngiving the full length of the target sequence of which\n\
    the subsequence in (2) is part. FUNC must return None\nif it deems that the probe\
    \ does not hybridize to the\ntarget subsequence; otherwise, it must return a tuple\n\
    (start, end) where start is an int giving the start\nposition in the probe (equivalently,\
    \ in the target\nsubsequence) at which the probe will hybridize to the\ntarget\
    \ subsequence, and end is an int (exclusive)\ngiving the end position of the hybridization."
  args: !SimpleFlagArg
    name: CUSTOM_HYBRIDIZATION_FN
- !Flag
  optional: true
  synonyms:
  - -c
  - --coverage
  description: "If this is a float in [0,1], it gives the fraction of\neach target\
    \ genome that must be covered by the\nselected probes; if this is an int > 1,\
    \ it gives the\nnumber of bp of each target genome that must be\ncovered by the\
    \ selected probes"
  args: !SimpleFlagArg
    name: COVERAGE
- !Flag
  optional: true
  synonyms:
  - -e
  - --cover-extension
  description: "Extend the coverage of each side of a probe by\nCOVER_EXTENSION nt.\
    \ That is, a probe covers a region\nthat consists of the portion of a sequence\
    \ it\nhybridizes to, as well as this number of nt on each\nside of that portion.\
    \ This is useful in modeling\nhybrid selection, where a probe hybridizes toa\n\
    fragment that includes the region targeted by the\nprobe, along with surrounding\
    \ portions of the\nsequence. Increasing its value should reduce the\nnumber of\
    \ probes required to achieve the desired\ncoverage."
  args: !SimpleFlagArg
    name: COVER_EXTENSION
- !Flag
  optional: true
  synonyms:
  - -i
  - --identify
  description: "Design probes meant to make it possible to identify\nnucleic acid\
    \ from a particular input dataset against\nthe other datasets; when set, the coverage\
    \ should\ngenerally be small"
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --blacklist-genomes
  description: "One or more blacklisted genomes; penalize probes based\non how much\
    \ of each of these genomes they cover. If\nthe value is a path to a file, then\
    \ that file is\ntreated as a FASTA file and its sequences are read.\nOtherwise,\
    \ it is assumed that this is a label for a\ndataset included in this package (e.g.,\
    \ 'zika')."
  args: !RepeatFlagArg
    name: BLACKLIST_GENOMES
- !Flag
  optional: true
  synonyms:
  - -mt
  - --mismatches-tolerant
  description: "(Optional) A more tolerant value for 'mismatches';\nthis should be\
    \ greater than the value of MISMATCHES.\nAllows for capturing more possible hybridizations\n\
    (i.e., more sensitivity) when designing probes for\nidentification or when genomes\
    \ are blacklisted."
  args: !SimpleFlagArg
    name: MISMATCHES_TOLERANT
- !Flag
  optional: true
  synonyms:
  - -lt
  - --lcf-thres-tolerant
  description: "(Optional) A more tolerant value for 'lcf_thres'; this\nshould be\
    \ less than LCF_THRES. Allows for capturing\nmore possible hybridizations (i.e.,\
    \ more sensitivity)\nwhen designing probes for identification or when\ngenomes\
    \ are blacklisted."
  args: !SimpleFlagArg
    name: LCF_THRES_TOLERANT
- !Flag
  optional: true
  synonyms:
  - --island-of-exact-match-tolerant
  description: "(Optional) A more tolerant value for\n'island_of_exact_match'; this\
    \ should be less than\nISLAND_OF_ EXACT_MATCH. Allows for capturing more\npossible\
    \ hybridizations (i.e., more sensitivity) when\ndesigning probes for identification\
    \ or when genomes\nare blacklisted."
  args: !SimpleFlagArg
    name: ISLAND_OF_EXACT_MATCH_TOLERANT
- !Flag
  optional: true
  synonyms:
  - --custom-hybridization-fn-tolerant
  description: "CUSTOM_HYBRIDIZATION_FN_TOLERANT\n(Optional) A more tolerant model\
    \ than the one\nimplemented in custom_hybridization_fn. This should\ncapture more\
    \ possible hybridizations (i.e., be more\nsensitive) when designing probes for\
    \ identification or\nwhen genomes are blacklisted. See --custom-\nhybridization-fn\
    \ for details of how this function\nshould be implemented and provided."
  args: !SimpleFlagArg
    name: CUSTOM_HYBRIDIZATION_FN_TOLERANT
- !Flag
  optional: true
  synonyms:
  - --print-analysis
  description: Print analysis of the probe set's coverage
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --write-analysis-to-tsv
  description: "(Optional) The file to which to write a TSV-formatted\nmatrix of the\
    \ probe set's coverage analysis"
  args: !SimpleFlagArg
    name: WRITE_ANALYSIS_TO_TSV
- !Flag
  optional: true
  synonyms:
  - --write-sliding-window-coverage
  description: "(Optional) The file to which to write the average\ncoverage achieved\
    \ by the probe set within sliding\nwindows of each target genome"
  args: !SimpleFlagArg
    name: WRITE_SLIDING_WINDOW_COVERAGE
- !Flag
  optional: true
  synonyms:
  - --write-probe-map-counts-to-tsv
  description: "(Optional) The file to which to write a TSV-formatted\nlist of the\
    \ number of sequences each probe maps to.\nThis explicitly does not count reverse\
    \ complements."
  args: !SimpleFlagArg
    name: WRITE_PROBE_MAP_COUNTS_TO_TSV
- !Flag
  optional: true
  synonyms:
  - --filter-from-fasta
  description: "(Optional) A FASTA file from which to select candidate\nprobes. Before\
    \ running any other filters, keep only\nthe candidate probes that are equal to\
    \ sequences in\nthe file and remove all probes not equal to any of\nthese sequences.\
    \ This, by default, ignores sequences\nin the file whose header contains the string\
    \ 'reverse\ncomplement'; that is, if there is some probe with\nsequence S, it\
    \ may be filtered out (even if there is a\nsequence S in the file) if the header\
    \ of S in the file\ncontains 'reverse complement'. This is useful if we\nalready\
    \ have probes decided by the set cover filter,\nbut simply want to process them\
    \ further by, e.g.,\nadding adapters or running a coverage analysis. For\nexample,\
    \ if we have already run the time-consuming set\ncover filter and have a FASTA\
    \ containing those probes,\nwe can provide a path to that FASTA file for this\n\
    argument, and also provide the --skip-set-cover\nargument, in order to add adapters\
    \ to those probes\nwithout having to re-run the set cover filter."
  args: !SimpleFlagArg
    name: FILTER_FROM_FASTA
- !Flag
  optional: true
  synonyms:
  - --skip-set-cover
  description: "Skip the set cover filter; this is useful when we wish\nto see the\
    \ probes generated from only the duplicate\nand reverse complement filters, to\
    \ gauge the effects\nof the set cover filter"
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --add-adapters
  description: "Add adapters to the ends of probes; to specify adapter\nsequences,\
    \ use --adapter-a and --adapter-b"
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --adapter-a
  description: "ADAPTER_A\n(Optional) Args: <X> <Y>; Custom A adapter to use; two\n\
    ordered where X is the A adapter sequence to place on\nthe 5' end of a probe and\
    \ Y is the A adapter sequence\nto place on the 3' end of a probe"
  args: !SimpleFlagArg
    name: ADAPTER_A
- !Flag
  optional: true
  synonyms:
  - --adapter-b
  description: "ADAPTER_B\n(Optional) Args: <X> <Y>; Custom B adapter to use; two\n\
    ordered where X is the B adapter sequence to place on\nthe 5' end of a probe and\
    \ Y is the B adapter sequence\nto place on the 3' end of a probe"
  args: !SimpleFlagArg
    name: ADAPTER_B
- !Flag
  optional: true
  synonyms:
  - --filter-polya
  description: "FILTER_POLYA\n(Optional) Args: <X> <Y> (integers); do not output any\n\
    probe that contains a stretch of X or more 'A' bases,\ntolerating up to Y mismatches\
    \ (and likewise for 'T'\nbases)"
  args: !SimpleFlagArg
    name: FILTER_POLYA
- !Flag
  optional: true
  synonyms:
  - --add-reverse-complements
  description: Add to the output the reverse complement of each probe
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --expand-n
  description: "[EXPAND_N]\nExpand each probe so that 'N' bases are replaced by\n\
    real bases; for example, the probe 'ANA' would be\nreplaced with the probes 'AAA',\
    \ 'ATA', 'ACA', and\n'AGA'; this is done combinatorially across all 'N'\nbases\
    \ in a probe, and thus the number of new probes\ngrows exponentially with the\
    \ number of 'N' bases in a\nprobe. If followed by a command- line argument (INT),\n\
    this only expands at most INT randomly selected N\nbases, and the rest are replaced\
    \ with random\nunambiguous bases (default INT is 3)."
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --limit-target-genomes
  description: "(Optional) Use only the first LIMIT_TARGET_GENOMES\ntarget genomes\
    \ in the dataset"
  args: !SimpleFlagArg
    name: LIMIT_TARGET_GENOMES
- !Flag
  optional: true
  synonyms:
  - --limit-target-genomes-randomly-with-replacement
  description: "(Optional) Randomly select\nLIMIT_TARGET_GENOMES_RANDOMLY_WITH_REPLACMENT\
    \ target\ngenomes in the dataset with replacement"
  args: !SimpleFlagArg
    name: LIMIT_TARGET_GENOMES_RANDOMLY_WITH_REPLACEMENT
- !Flag
  optional: true
  synonyms:
  - --cluster-and-design-separately
  description: "(Optional) If set, cluster all input sequences using\ntheir MinHash\
    \ signatures, design probes separately on\neach cluster, and combine the resulting\
    \ probes. This\ncan significantly lower runtime and memory usage, but\nmay lead\
    \ to a suboptimal solution. The value\nCLUSTER_AND_DESIGN_SEPARATELY gives the\
    \ inter-cluster\ndistance threshold to merge clusters (1-ANI, where ANI\nis average\
    \ nucleotide identity); higher values result\nin fewer clusters, and thus longer\
    \ runtime. Values\nmust be in (0,0.5], and generally should be around 0.1\nor\
    \ 0.2. When used, this creates a separate genome for\neach input sequence -- it\
    \ collapses all sequences,\nacross both groups and genomes, into one list of\n\
    sequences in one group. Therefore, genomes will not be\ngrouped as specified in\
    \ the input and sequences will\nnot be grouped by genome, and differential\nidentification\
    \ is not supported"
  args: !SimpleFlagArg
    name: CLUSTER_AND_DESIGN_SEPARATELY
- !Flag
  optional: true
  synonyms:
  - --cluster-from-fragments
  description: "(Optional) If set, break all sequences into sequences\nof length CLUSTER_FROM_FRAGMENTS\
    \ nt, and cluster these\nfragments. This can be useful for improving runtime on\n\
    input with especially large genomes, in which probes\nfor different fragments\
    \ can be designed separately.\nValues should generally be around 10,000. For this\
    \ to\nbe used, --cluster-and-design-separately must also be\nset."
  args: !SimpleFlagArg
    name: CLUSTER_FROM_FRAGMENTS
- !Flag
  optional: true
  synonyms:
  - --filter-with-lsh-hamming
  description: "(Optional) If set, filter candidate probes for near-\nduplicates using\
    \ LSH with a family of hash functions\nthat works with Hamming distance.\nFILTER_WITH_LSH_HAMMING\
    \ gives the maximum Hamming\ndistance at which to call near-duplicates; it should\n\
    be commensurate with (but not greater than)\nMISMATCHES. Using this may significantly\
    \ improve\nruntime and reduce memory usage by reducing the number\nof candidate\
    \ probes to consider, but may lead to a\nslightly sub-optimal solution. It may\
    \ also,\nparticularly with relatively high values of\nFILTER_WITH_LSH_HAMMING,\
    \ cause coverage obtained for\neach genome to be slightly less than the desired\n\
    coverage (COVERAGE) when that desired coverage is the\ncomplete genome; it is\
    \ recommended to also use\n--print-analysis or --write-analysis-to-tsv with this\n\
    to see the coverage that is obtained."
  args: !SimpleFlagArg
    name: FILTER_WITH_LSH_HAMMING
- !Flag
  optional: true
  synonyms:
  - --filter-with-lsh-minhash
  description: "(Optional) If set, filter candidate probes for near-\nduplicates using\
    \ LSH with a MinHash family.\nFILTER_WITH_LSH_MINHASH gives the maximum Jaccard\n\
    distance (1 minus Jaccard similarity) at which to call\nnear-duplicates; the Jaccard\
    \ similarity is calculated\nby treating each probe as a set of overlapping\n10-mers.\
    \ Its value should be commensurate with\nparameter values determining whether\
    \ a probe\nhybridizes to a target sequence, but this can be\ndifficult to measure\
    \ compared to the input for\n--filter-with-lsh-hamming. However, this allows more\n\
    sensitivity in near-duplicate detection than --filter-\nwith-lsh-hamming (e.g.,\
    \ if near-duplicates should\ninvolve probes shifted relative to each other). The\n\
    same caveats mentioned in help for --filter-with-lsh-\nhamming also apply here.\
    \ Values of\nFILTER_WITH_LSH_MINHASH above ~0.7 may start to\nrequire significant\
    \ memory and runtime for near-\nduplicate detection."
  args: !SimpleFlagArg
    name: FILTER_WITH_LSH_MINHASH
- !Flag
  optional: true
  synonyms:
  - --cover-groupings-separately
  description: "Run a separate instance of set cover with the target\ngenomes from\
    \ each grouping and pool (union) the\nresulting probes. When set, the software\
    \ will run\nfaster than when not set, but it may yield more probes\nthan when\
    \ it is not set."
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --small-seq-skip
  description: "(Optional) Do not create candidate probes from\nsequences whose length\
    \ is <= SMALL_SEQ_SKIP. If set to\n(PROBE_LENGTH - 1), this avoids the error raised\
    \ when\nsequences are less than the probe length"
  args: !SimpleFlagArg
    name: SMALL_SEQ_SKIP
- !Flag
  optional: true
  synonyms:
  - --small-seq-min
  description: "(Optional) If set, allow sequences as input that are\nshorter than\
    \ PROBE_LENGTH (when not set, the program\nwill error on such input). SMALL_SEQ_MIN\
    \ is the\nminimum sequence length that should be accepted as\ninput. When a sequence\
    \ is less than PROBE_LENGTH, a\ncandidate probe is created that is equal to the\n\
    sequence; thus, the output probes may have different\nlengths. Note that, when\
    \ this is set, it might be a\ngood idea to also set LCF_THRES to be a value smaller\n\
    than PROBE_LENGTH -- e.g., the length of the shortest\ninput sequence; otherwise,\
    \ when a probe of length p_l\nis mapped to a sequence of length s_l, then lcf_thres\n\
    is treated as being min(LCF_THRES, p_l, s_l) so that a\nprobe is able to 'cover'\
    \ a sequence shorter than the\nprobe and so that a probe shorter than lcf_thres\
    \ is\nable to 'cover' a sequence"
  args: !SimpleFlagArg
    name: SMALL_SEQ_MIN
- !Flag
  optional: true
  synonyms:
  - --max-num-processes
  description: "(Optional) An int >= 1 that gives the maximum number\nof processes\
    \ to use in multiprocessing pools; uses\nmin(number of CPUs in the system, MAX_NUM_PROCESSES)\n\
    processes"
  args: !SimpleFlagArg
    name: MAX_NUM_PROCESSES
- !Flag
  optional: true
  synonyms:
  - --kmer-probe-map-k
  description: "(Optional) Use this value (KMER_PROBE_LENGTH_K) as the\nk-mer length\
    \ when constructing a map of k-mers to the\nprobes that contain these k-mers.\
    \ This map is used\nwhen mapping candidate probes to target sequences and\nthe\
    \ k-mers serve as seeds for calculating whether a\ncandidate probe 'covers' a\
    \ subsequence. The value\nshould be sufficiently less than PROBE_LENGTH so that\n\
    it can find mappings even when the candidate probe and\ntarget sequence are divergent.\
    \ In particular, CATCH\nwill try to find a value k >= KMER_PROBE_LENGTH_K (by\n\
    default, >=20) such that k divides PROBE_LENGTH and k\n< PROBE_LENGTH / MISMATCHES\
    \ (if MISMATCHES=0, then\nk=PROBE_LENGTH). It will then use this k as the k-mer\n\
    length in mappings; if no such k exists, it will use a\nrandomized approach with\
    \ KMER_PROBE_LENGTH_K as the\nk-mer length. If --custom-hybridization-fn is set,\
    \ it\nwill always use the randomized approach with\nKMER_PROBE_LENGTH_K (by default,\
    \ 20) as the k-mer\nlength."
  args: !SimpleFlagArg
    name: KMER_PROBE_MAP_K
- !Flag
  optional: true
  synonyms:
  - --use-native-dict-when-finding-tolerant-coverage
  description: "When finding probe coverage for blacklisting and\nidentification (i.e.,\
    \ when using tolerant parameters),\nuse a native Python dict as the kmer_probe_map\
    \ across\nprocesses, rather than the primitives in\nSharedKmerProbeMap that are\
    \ more suited to sharing\nacross processes. Depending on the input (particularly\n\
    if there are many candidate probes) this may result in\nsubstantial memory usage;\
    \ but it may provide an\nimprovement in runtime when there are relatively few\n\
    candidate probes and a very large blacklisted input"
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --ncbi-api-key
  description: "API key to use for NCBI e-utils. Using this increases\nthe limit on\
    \ requests/second and may prevent an IP\naddress from being block due to too many\
    \ requests"
  args: !SimpleFlagArg
    name: NCBI_API_KEY
- !Flag
  optional: true
  synonyms:
  - --debug
  description: Debug output
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --verbose
  description: Verbose output
  args: !EmptyFlagArg {}
parent:
subcommands: []
usage: []
help_flag: !Flag
  optional: true
  synonyms:
  - -h
  - --help
  description: show this help message and exit
  args: !EmptyFlagArg {}
usage_flag:
version_flag: !Flag
  optional: true
  synonyms:
  - -V
  - --version
  description: show program's version number and exit
  args: !EmptyFlagArg {}
help_text: "usage: design.py [-h] -o OUTPUT_PROBES [--write-taxid-acc WRITE_TAXID_ACC]\n\
  \                 [-pl PROBE_LENGTH] [-ps PROBE_STRIDE] [-m MISMATCHES]\n      \
  \           [-l LCF_THRES]\n                 [--island-of-exact-match ISLAND_OF_EXACT_MATCH]\n\
  \                 [--custom-hybridization-fn CUSTOM_HYBRIDIZATION_FN CUSTOM_HYBRIDIZATION_FN]\n\
  \                 [-c COVERAGE] [-e COVER_EXTENSION] [-i]\n                 [--blacklist-genomes\
  \ BLACKLIST_GENOMES [BLACKLIST_GENOMES ...]]\n                 [-mt MISMATCHES_TOLERANT]\
  \ [-lt LCF_THRES_TOLERANT]\n                 [--island-of-exact-match-tolerant ISLAND_OF_EXACT_MATCH_TOLERANT]\n\
  \                 [--custom-hybridization-fn-tolerant CUSTOM_HYBRIDIZATION_FN_TOLERANT\
  \ CUSTOM_HYBRIDIZATION_FN_TOLERANT]\n                 [--print-analysis]\n     \
  \            [--write-analysis-to-tsv WRITE_ANALYSIS_TO_TSV]\n                 [--write-sliding-window-coverage\
  \ WRITE_SLIDING_WINDOW_COVERAGE]\n                 [--write-probe-map-counts-to-tsv\
  \ WRITE_PROBE_MAP_COUNTS_TO_TSV]\n                 [--filter-from-fasta FILTER_FROM_FASTA]\
  \ [--skip-set-cover]\n                 [--add-adapters] [--adapter-a ADAPTER_A ADAPTER_A]\n\
  \                 [--adapter-b ADAPTER_B ADAPTER_B]\n                 [--filter-polya\
  \ FILTER_POLYA FILTER_POLYA]\n                 [--add-reverse-complements] [--expand-n\
  \ [EXPAND_N]]\n                 [--limit-target-genomes LIMIT_TARGET_GENOMES]\n\
  \                 [--limit-target-genomes-randomly-with-replacement LIMIT_TARGET_GENOMES_RANDOMLY_WITH_REPLACEMENT]\n\
  \                 [--cluster-and-design-separately CLUSTER_AND_DESIGN_SEPARATELY]\n\
  \                 [--cluster-from-fragments CLUSTER_FROM_FRAGMENTS]\n          \
  \       [--filter-with-lsh-hamming FILTER_WITH_LSH_HAMMING]\n                 [--filter-with-lsh-minhash\
  \ FILTER_WITH_LSH_MINHASH]\n                 [--cover-groupings-separately]\n  \
  \               [--small-seq-skip SMALL_SEQ_SKIP]\n                 [--small-seq-min\
  \ SMALL_SEQ_MIN]\n                 [--max-num-processes MAX_NUM_PROCESSES]\n   \
  \              [--kmer-probe-map-k KMER_PROBE_MAP_K]\n                 [--use-native-dict-when-finding-tolerant-coverage]\n\
  \                 [--ncbi-api-key NCBI_API_KEY] [--debug] [--verbose] [-V]\n   \
  \              dataset [dataset ...]\n\npositional arguments:\n  dataset       \
  \        One or more target datasets (e.g., one per species).\n                \
  \        Each dataset can be specified in one of multiple ways.\n              \
  \          (a) If dataset is in the format 'download:TAXID', then\n            \
  \            CATCH downloads from NCBI all whole genomes for the\n             \
  \           NCBI taxonomy with id TAXID, and uses these sequences\n            \
  \            as input. (b) If dataset is a path to a FASTA file,\n             \
  \           then its sequences are read and used as input. (c)\n               \
  \         Otherwise, it is assumed that this is a label for a\n                \
  \        dataset included in this package (e.g., 'zika'). If\n                 \
  \       the label starts with 'collection:' (e.g.,\n                        'collection:viruses_with_human_host'),\
  \ then this reads\n                        from an available collection of datasets.\
  \ For\n                        segmented viruses, the format for NCBI downloads\
  \ can\n                        also be 'download:TAXID-SEGMENT'.\n\noptional arguments:\n\
  \  -h, --help            show this help message and exit\n  -o OUTPUT_PROBES, --output-probes\
  \ OUTPUT_PROBES\n                        The file to which all final probes should\
  \ be written;\n                        they are written in FASTA format\n  --write-taxid-acc\
  \ WRITE_TAXID_ACC\n                        If 'download:' labels are used in datasets,\
  \ write\n                        downloaded accessions to a file in this directory.\n\
  \                        Accessions are written to WRITE_TAXID_ACC/TAXID.txt\n \
  \ -pl PROBE_LENGTH, --probe-length PROBE_LENGTH\n                        (Optional)\
  \ Make probes be PROBE_LENGTH nt long\n  -ps PROBE_STRIDE, --probe-stride PROBE_STRIDE\n\
  \                        (Optional) Generate candidate probes from the input\n \
  \                       that are separated by PROBE_STRIDE nt\n  -m MISMATCHES,\
  \ --mismatches MISMATCHES\n                        (Optional) Allow for MISMATCHES\
  \ mismatches when\n                        determining whether a probe covers a\
  \ sequence\n  -l LCF_THRES, --lcf-thres LCF_THRES\n                        (Optional)\
  \ Say that a portion of a probe covers a\n                        portion of a sequence\
  \ if the two share a substring\n                        with at most MISMATCHES\
  \ mismatches that has length >=\n                        LCF_THRES nt; if unspecified,\
  \ this is set to\n                        PROBE_LENGTH\n  --island-of-exact-match\
  \ ISLAND_OF_EXACT_MATCH\n                        (Optional) When determining whether\
  \ a probe covers a\n                        sequence, require that there be an exact\
  \ match (i.e.,\n                        no mismatches) of length at least\n    \
  \                    ISLAND_OF_EXACT_MATCH nt between a portion of the\n       \
  \                 probe and a portion of the sequence\n  --custom-hybridization-fn\
  \ CUSTOM_HYBRIDIZATION_FN CUSTOM_HYBRIDIZATION_FN\n                        (Optional)\
  \ Args: <PATH> <FUNC>; PATH is a path to a\n                        Python module\
  \ (.py file) and FUNC is a string giving\n                        the name of a\
  \ function in that module. FUNC provides a\n                        custom model\
  \ of hybridization between a probe and\n                        target sequence\
  \ to use in the probe set design. If\n                        this is set, the arguments\
  \ --mismatches, --lcf-thres,\n                        and --island-of-exact-match\
  \ are not used because these\n                        are meant for the default\
  \ model of hybridization. The\n                        function FUNC in PATH is\
  \ dynamically loaded to use\n                        when determining whether a\
  \ probe hybridizes to a\n                        target sequence (and, if so, what\
  \ portion). FUNC must\n                        accept the following arguments in\
  \ order, though it may\n                        choose to ignore some values: (1)\
  \ array giving\n                        sequence of a probe; (2) str giving subsequence\
  \ of\n                        target sequence to which the probe may hybridize,\
  \ of\n                        the same length as the given probe sequence; (3) int\n\
  \                        giving the position in the probe (equivalently, the\n \
  \                       target subsequence) of the start of a k-mer around\n   \
  \                     which the probe and target subsequence are anchored\n    \
  \                    (the probe and target subsequence are aligned using\n     \
  \                   this k-mer as an anchor); (4) int giving the end\n         \
  \               position (exclusive) of the anchor k-mer; (5) int\n            \
  \            giving the full length of the probe (the probe\n                  \
  \      provided in (1) may be cutoff on an end if it extends\n                 \
  \       further than where the target sequence ends); (6) int\n                \
  \        giving the full length of the target sequence of which\n              \
  \          the subsequence in (2) is part. FUNC must return None\n             \
  \           if it deems that the probe does not hybridize to the\n             \
  \           target subsequence; otherwise, it must return a tuple\n            \
  \            (start, end) where start is an int giving the start\n             \
  \           position in the probe (equivalently, in the target\n               \
  \         subsequence) at which the probe will hybridize to the\n              \
  \          target subsequence, and end is an int (exclusive)\n                 \
  \       giving the end position of the hybridization.\n  -c COVERAGE, --coverage\
  \ COVERAGE\n                        If this is a float in [0,1], it gives the fraction\
  \ of\n                        each target genome that must be covered by the\n \
  \                       selected probes; if this is an int > 1, it gives the\n \
  \                       number of bp of each target genome that must be\n      \
  \                  covered by the selected probes\n  -e COVER_EXTENSION, --cover-extension\
  \ COVER_EXTENSION\n                        Extend the coverage of each side of a\
  \ probe by\n                        COVER_EXTENSION nt. That is, a probe covers\
  \ a region\n                        that consists of the portion of a sequence it\n\
  \                        hybridizes to, as well as this number of nt on each\n \
  \                       side of that portion. This is useful in modeling\n     \
  \                   hybrid selection, where a probe hybridizes toa\n           \
  \             fragment that includes the region targeted by the\n              \
  \          probe, along with surrounding portions of the\n                     \
  \   sequence. Increasing its value should reduce the\n                        number\
  \ of probes required to achieve the desired\n                        coverage.\n\
  \  -i, --identify        Design probes meant to make it possible to identify\n \
  \                       nucleic acid from a particular input dataset against\n \
  \                       the other datasets; when set, the coverage should\n    \
  \                    generally be small\n  --blacklist-genomes BLACKLIST_GENOMES\
  \ [BLACKLIST_GENOMES ...]\n                        One or more blacklisted genomes;\
  \ penalize probes based\n                        on how much of each of these genomes\
  \ they cover. If\n                        the value is a path to a file, then that\
  \ file is\n                        treated as a FASTA file and its sequences are\
  \ read.\n                        Otherwise, it is assumed that this is a label for\
  \ a\n                        dataset included in this package (e.g., 'zika').\n\
  \  -mt MISMATCHES_TOLERANT, --mismatches-tolerant MISMATCHES_TOLERANT\n        \
  \                (Optional) A more tolerant value for 'mismatches';\n          \
  \              this should be greater than the value of MISMATCHES.\n          \
  \              Allows for capturing more possible hybridizations\n             \
  \           (i.e., more sensitivity) when designing probes for\n               \
  \         identification or when genomes are blacklisted.\n  -lt LCF_THRES_TOLERANT,\
  \ --lcf-thres-tolerant LCF_THRES_TOLERANT\n                        (Optional) A\
  \ more tolerant value for 'lcf_thres'; this\n                        should be less\
  \ than LCF_THRES. Allows for capturing\n                        more possible hybridizations\
  \ (i.e., more sensitivity)\n                        when designing probes for identification\
  \ or when\n                        genomes are blacklisted.\n  --island-of-exact-match-tolerant\
  \ ISLAND_OF_EXACT_MATCH_TOLERANT\n                        (Optional) A more tolerant\
  \ value for\n                        'island_of_exact_match'; this should be less\
  \ than\n                        ISLAND_OF_ EXACT_MATCH. Allows for capturing more\n\
  \                        possible hybridizations (i.e., more sensitivity) when\n\
  \                        designing probes for identification or when genomes\n \
  \                       are blacklisted.\n  --custom-hybridization-fn-tolerant CUSTOM_HYBRIDIZATION_FN_TOLERANT\
  \ CUSTOM_HYBRIDIZATION_FN_TOLERANT\n                        (Optional) A more tolerant\
  \ model than the one\n                        implemented in custom_hybridization_fn.\
  \ This should\n                        capture more possible hybridizations (i.e.,\
  \ be more\n                        sensitive) when designing probes for identification\
  \ or\n                        when genomes are blacklisted. See --custom-\n    \
  \                    hybridization-fn for details of how this function\n       \
  \                 should be implemented and provided.\n  --print-analysis      Print\
  \ analysis of the probe set's coverage\n  --write-analysis-to-tsv WRITE_ANALYSIS_TO_TSV\n\
  \                        (Optional) The file to which to write a TSV-formatted\n\
  \                        matrix of the probe set's coverage analysis\n  --write-sliding-window-coverage\
  \ WRITE_SLIDING_WINDOW_COVERAGE\n                        (Optional) The file to\
  \ which to write the average\n                        coverage achieved by the probe\
  \ set within sliding\n                        windows of each target genome\n  --write-probe-map-counts-to-tsv\
  \ WRITE_PROBE_MAP_COUNTS_TO_TSV\n                        (Optional) The file to\
  \ which to write a TSV-formatted\n                        list of the number of\
  \ sequences each probe maps to.\n                        This explicitly does not\
  \ count reverse complements.\n  --filter-from-fasta FILTER_FROM_FASTA\n        \
  \                (Optional) A FASTA file from which to select candidate\n      \
  \                  probes. Before running any other filters, keep only\n       \
  \                 the candidate probes that are equal to sequences in\n        \
  \                the file and remove all probes not equal to any of\n          \
  \              these sequences. This, by default, ignores sequences\n          \
  \              in the file whose header contains the string 'reverse\n         \
  \               complement'; that is, if there is some probe with\n            \
  \            sequence S, it may be filtered out (even if there is a\n          \
  \              sequence S in the file) if the header of S in the file\n        \
  \                contains 'reverse complement'. This is useful if we\n         \
  \               already have probes decided by the set cover filter,\n         \
  \               but simply want to process them further by, e.g.,\n            \
  \            adding adapters or running a coverage analysis. For\n             \
  \           example, if we have already run the time-consuming set\n           \
  \             cover filter and have a FASTA containing those probes,\n         \
  \               we can provide a path to that FASTA file for this\n            \
  \            argument, and also provide the --skip-set-cover\n                 \
  \       argument, in order to add adapters to those probes\n                   \
  \     without having to re-run the set cover filter.\n  --skip-set-cover      Skip\
  \ the set cover filter; this is useful when we wish\n                        to\
  \ see the probes generated from only the duplicate\n                        and\
  \ reverse complement filters, to gauge the effects\n                        of the\
  \ set cover filter\n  --add-adapters        Add adapters to the ends of probes;\
  \ to specify adapter\n                        sequences, use --adapter-a and --adapter-b\n\
  \  --adapter-a ADAPTER_A ADAPTER_A\n                        (Optional) Args: <X>\
  \ <Y>; Custom A adapter to use; two\n                        ordered where X is\
  \ the A adapter sequence to place on\n                        the 5' end of a probe\
  \ and Y is the A adapter sequence\n                        to place on the 3' end\
  \ of a probe\n  --adapter-b ADAPTER_B ADAPTER_B\n                        (Optional)\
  \ Args: <X> <Y>; Custom B adapter to use; two\n                        ordered where\
  \ X is the B adapter sequence to place on\n                        the 5' end of\
  \ a probe and Y is the B adapter sequence\n                        to place on the\
  \ 3' end of a probe\n  --filter-polya FILTER_POLYA FILTER_POLYA\n              \
  \          (Optional) Args: <X> <Y> (integers); do not output any\n            \
  \            probe that contains a stretch of X or more 'A' bases,\n           \
  \             tolerating up to Y mismatches (and likewise for 'T'\n            \
  \            bases)\n  --add-reverse-complements\n                        Add to\
  \ the output the reverse complement of each probe\n  --expand-n [EXPAND_N]\n   \
  \                     Expand each probe so that 'N' bases are replaced by\n    \
  \                    real bases; for example, the probe 'ANA' would be\n       \
  \                 replaced with the probes 'AAA', 'ATA', 'ACA', and\n          \
  \              'AGA'; this is done combinatorially across all 'N'\n            \
  \            bases in a probe, and thus the number of new probes\n             \
  \           grows exponentially with the number of 'N' bases in a\n            \
  \            probe. If followed by a command- line argument (INT),\n           \
  \             this only expands at most INT randomly selected N\n              \
  \          bases, and the rest are replaced with random\n                      \
  \  unambiguous bases (default INT is 3).\n  --limit-target-genomes LIMIT_TARGET_GENOMES\n\
  \                        (Optional) Use only the first LIMIT_TARGET_GENOMES\n  \
  \                      target genomes in the dataset\n  --limit-target-genomes-randomly-with-replacement\
  \ LIMIT_TARGET_GENOMES_RANDOMLY_WITH_REPLACEMENT\n                        (Optional)\
  \ Randomly select\n                        LIMIT_TARGET_GENOMES_RANDOMLY_WITH_REPLACMENT\
  \ target\n                        genomes in the dataset with replacement\n  --cluster-and-design-separately\
  \ CLUSTER_AND_DESIGN_SEPARATELY\n                        (Optional) If set, cluster\
  \ all input sequences using\n                        their MinHash signatures, design\
  \ probes separately on\n                        each cluster, and combine the resulting\
  \ probes. This\n                        can significantly lower runtime and memory\
  \ usage, but\n                        may lead to a suboptimal solution. The value\n\
  \                        CLUSTER_AND_DESIGN_SEPARATELY gives the inter-cluster\n\
  \                        distance threshold to merge clusters (1-ANI, where ANI\n\
  \                        is average nucleotide identity); higher values result\n\
  \                        in fewer clusters, and thus longer runtime. Values\n  \
  \                      must be in (0,0.5], and generally should be around 0.1\n\
  \                        or 0.2. When used, this creates a separate genome for\n\
  \                        each input sequence -- it collapses all sequences,\n  \
  \                      across both groups and genomes, into one list of\n      \
  \                  sequences in one group. Therefore, genomes will not be\n    \
  \                    grouped as specified in the input and sequences will\n    \
  \                    not be grouped by genome, and differential\n              \
  \          identification is not supported\n  --cluster-from-fragments CLUSTER_FROM_FRAGMENTS\n\
  \                        (Optional) If set, break all sequences into sequences\n\
  \                        of length CLUSTER_FROM_FRAGMENTS nt, and cluster these\n\
  \                        fragments. This can be useful for improving runtime on\n\
  \                        input with especially large genomes, in which probes\n\
  \                        for different fragments can be designed separately.\n \
  \                       Values should generally be around 10,000. For this to\n\
  \                        be used, --cluster-and-design-separately must also be\n\
  \                        set.\n  --filter-with-lsh-hamming FILTER_WITH_LSH_HAMMING\n\
  \                        (Optional) If set, filter candidate probes for near-\n\
  \                        duplicates using LSH with a family of hash functions\n\
  \                        that works with Hamming distance.\n                   \
  \     FILTER_WITH_LSH_HAMMING gives the maximum Hamming\n                      \
  \  distance at which to call near-duplicates; it should\n                      \
  \  be commensurate with (but not greater than)\n                        MISMATCHES.\
  \ Using this may significantly improve\n                        runtime and reduce\
  \ memory usage by reducing the number\n                        of candidate probes\
  \ to consider, but may lead to a\n                        slightly sub-optimal solution.\
  \ It may also,\n                        particularly with relatively high values\
  \ of\n                        FILTER_WITH_LSH_HAMMING, cause coverage obtained for\n\
  \                        each genome to be slightly less than the desired\n    \
  \                    coverage (COVERAGE) when that desired coverage is the\n   \
  \                     complete genome; it is recommended to also use\n         \
  \               --print-analysis or --write-analysis-to-tsv with this\n        \
  \                to see the coverage that is obtained.\n  --filter-with-lsh-minhash\
  \ FILTER_WITH_LSH_MINHASH\n                        (Optional) If set, filter candidate\
  \ probes for near-\n                        duplicates using LSH with a MinHash\
  \ family.\n                        FILTER_WITH_LSH_MINHASH gives the maximum Jaccard\n\
  \                        distance (1 minus Jaccard similarity) at which to call\n\
  \                        near-duplicates; the Jaccard similarity is calculated\n\
  \                        by treating each probe as a set of overlapping\n      \
  \                  10-mers. Its value should be commensurate with\n            \
  \            parameter values determining whether a probe\n                    \
  \    hybridizes to a target sequence, but this can be\n                        difficult\
  \ to measure compared to the input for\n                        --filter-with-lsh-hamming.\
  \ However, this allows more\n                        sensitivity in near-duplicate\
  \ detection than --filter-\n                        with-lsh-hamming (e.g., if near-duplicates\
  \ should\n                        involve probes shifted relative to each other).\
  \ The\n                        same caveats mentioned in help for --filter-with-lsh-\n\
  \                        hamming also apply here. Values of\n                  \
  \      FILTER_WITH_LSH_MINHASH above ~0.7 may start to\n                       \
  \ require significant memory and runtime for near-\n                        duplicate\
  \ detection.\n  --cover-groupings-separately\n                        Run a separate\
  \ instance of set cover with the target\n                        genomes from each\
  \ grouping and pool (union) the\n                        resulting probes. When\
  \ set, the software will run\n                        faster than when not set,\
  \ but it may yield more probes\n                        than when it is not set.\n\
  \  --small-seq-skip SMALL_SEQ_SKIP\n                        (Optional) Do not create\
  \ candidate probes from\n                        sequences whose length is <= SMALL_SEQ_SKIP.\
  \ If set to\n                        (PROBE_LENGTH - 1), this avoids the error raised\
  \ when\n                        sequences are less than the probe length\n  --small-seq-min\
  \ SMALL_SEQ_MIN\n                        (Optional) If set, allow sequences as input\
  \ that are\n                        shorter than PROBE_LENGTH (when not set, the\
  \ program\n                        will error on such input). SMALL_SEQ_MIN is the\n\
  \                        minimum sequence length that should be accepted as\n  \
  \                      input. When a sequence is less than PROBE_LENGTH, a\n   \
  \                     candidate probe is created that is equal to the\n        \
  \                sequence; thus, the output probes may have different\n        \
  \                lengths. Note that, when this is set, it might be a\n         \
  \               good idea to also set LCF_THRES to be a value smaller\n        \
  \                than PROBE_LENGTH -- e.g., the length of the shortest\n       \
  \                 input sequence; otherwise, when a probe of length p_l\n      \
  \                  is mapped to a sequence of length s_l, then lcf_thres\n     \
  \                   is treated as being min(LCF_THRES, p_l, s_l) so that a\n   \
  \                     probe is able to 'cover' a sequence shorter than the\n   \
  \                     probe and so that a probe shorter than lcf_thres is\n    \
  \                    able to 'cover' a sequence\n  --max-num-processes MAX_NUM_PROCESSES\n\
  \                        (Optional) An int >= 1 that gives the maximum number\n\
  \                        of processes to use in multiprocessing pools; uses\n  \
  \                      min(number of CPUs in the system, MAX_NUM_PROCESSES)\n  \
  \                      processes\n  --kmer-probe-map-k KMER_PROBE_MAP_K\n      \
  \                  (Optional) Use this value (KMER_PROBE_LENGTH_K) as the\n    \
  \                    k-mer length when constructing a map of k-mers to the\n   \
  \                     probes that contain these k-mers. This map is used\n     \
  \                   when mapping candidate probes to target sequences and\n    \
  \                    the k-mers serve as seeds for calculating whether a\n     \
  \                   candidate probe 'covers' a subsequence. The value\n        \
  \                should be sufficiently less than PROBE_LENGTH so that\n       \
  \                 it can find mappings even when the candidate probe and\n     \
  \                   target sequence are divergent. In particular, CATCH\n      \
  \                  will try to find a value k >= KMER_PROBE_LENGTH_K (by\n     \
  \                   default, >=20) such that k divides PROBE_LENGTH and k\n    \
  \                    < PROBE_LENGTH / MISMATCHES (if MISMATCHES=0, then\n      \
  \                  k=PROBE_LENGTH). It will then use this k as the k-mer\n     \
  \                   length in mappings; if no such k exists, it will use a\n   \
  \                     randomized approach with KMER_PROBE_LENGTH_K as the\n    \
  \                    k-mer length. If --custom-hybridization-fn is set, it\n   \
  \                     will always use the randomized approach with\n           \
  \             KMER_PROBE_LENGTH_K (by default, 20) as the k-mer\n              \
  \          length.\n  --use-native-dict-when-finding-tolerant-coverage\n       \
  \                 When finding probe coverage for blacklisting and\n           \
  \             identification (i.e., when using tolerant parameters),\n         \
  \               use a native Python dict as the kmer_probe_map across\n        \
  \                processes, rather than the primitives in\n                    \
  \    SharedKmerProbeMap that are more suited to sharing\n                      \
  \  across processes. Depending on the input (particularly\n                    \
  \    if there are many candidate probes) this may result in\n                  \
  \      substantial memory usage; but it may provide an\n                       \
  \ improvement in runtime when there are relatively few\n                       \
  \ candidate probes and a very large blacklisted input\n  --ncbi-api-key NCBI_API_KEY\n\
  \                        API key to use for NCBI e-utils. Using this increases\n\
  \                        the limit on requests/second and may prevent an IP\n  \
  \                      address from being block due to too many requests\n  --debug\
  \               Debug output\n  --verbose             Verbose output\n  -V, --version\
  \         show program's version number and exit\n"
generated_using:
- --help
docker_image: quay.io/biocontainers/catch:1.4.0--py_0
