from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import String, Float, Int, Boolean

Fastqsimulate_V0_1_0 = CommandToolBuilder(tool="fastqSimulate", base_command=["fastqSimulate"], inputs=[ToolInput(tag="in_use_sequences_reffasta", input_type=String(optional=True), prefix="-f", doc=InputDocumentation(doc="Use sequences in ref.fasta as the genome.")), ToolInput(tag="in_create_outputs_namefastq", input_type=Float(optional=True), prefix="-o", doc=InputDocumentation(doc="Create outputs name.1.fastq and name.2.fastq (and maybe others).")), ToolInput(tag="in_create_reads_length", input_type=Int(optional=True), prefix="-l", doc=InputDocumentation(doc="Create reads of length 'len' bases.")), ToolInput(tag="in_create_pairs_mp", input_type=String(optional=True), prefix="-n", doc=InputDocumentation(doc="Create 'n' reads (for -se) or 'n' pairs of reads (for -pe and -mp).")), ToolInput(tag="in_set_read_coverage", input_type=String(optional=True), prefix="-x", doc=InputDocumentation(doc="Set 'np' to create reads that sample the genome to 'read-cov' read coverage.")), ToolInput(tag="in_set_clone_coverage", input_type=String(optional=True), prefix="-X", doc=InputDocumentation(doc="Set 'np' to create reads that sample the genome to 'clone-cov' clone coverage.")), ToolInput(tag="in_em", input_type=Float(optional=True), prefix="-em", doc=InputDocumentation(doc="Reads will contain fraction mismatch  error 'e' (0.01 == 1% error).")), ToolInput(tag="in_ei", input_type=Float(optional=True), prefix="-ei", doc=InputDocumentation(doc="Reads will contain fraction insertion error 'e' (0.01 == 1% error).")), ToolInput(tag="in_ed", input_type=Float(optional=True), prefix="-ed", doc=InputDocumentation(doc="Reads will contain fraction deletion  error 'e' (0.01 == 1% error).")), ToolInput(tag="in_allow_gaps", input_type=Boolean(optional=True), prefix="-allowgaps", doc=InputDocumentation(doc="Allow pairs to span N regions in the reference.  By default, pairs\nare not allowed to span a gap.  Reads are never allowed to cover N's.")), ToolInput(tag="in_all_owns", input_type=Boolean(optional=True), prefix="-allowns", doc=InputDocumentation(doc="Allow reads to contain N regions.  Implies -allowgaps")), ToolInput(tag="in_no_junction", input_type=Boolean(optional=True), prefix="-nojunction", doc=InputDocumentation(doc="For -mp, do not create chimeric junction reads.  Create only fully PE or\nfully MP reads.")), ToolInput(tag="in_normal", input_type=String(optional=True), prefix="-normal", doc=InputDocumentation(doc="Output a normal-oriented (both forward or both reverse) pair with\nprobability p.  Only for -pe and -mp.")), ToolInput(tag="in_se", input_type=Boolean(optional=True), prefix="-se", doc=InputDocumentation(doc="Create single-end reads.")), ToolInput(tag="in_cc", input_type=Int(optional=True), prefix="-cc", doc=InputDocumentation(doc="junkStdDev false\nCreate chimeric single-end reads.  The chimer is formed from two uniformly\ndistributed positions in the reference.  Some amount of random junk is inserted\nat the junction.  With probability 'false' the read is not chimeric, but still\nthe junk bases inserted in the middle.")), ToolInput(tag="in_pe", input_type=Int(optional=True), prefix="-pe", doc=InputDocumentation(doc="shearStdDev\nCreate paired-end reads, from fragments of size 'shearSize +- shearStdDev'.")), ToolInput(tag="in_mp", input_type=Int(optional=True), prefix="-mp", doc=InputDocumentation(doc="insertStdDev shearSize shearStdDev enrichment\nCreate mate-pair reads.  The pairs will be 'insertSize +- insertStdDev'\napart.  The circularized insert is then sheared into fragments of size\n'shearSize +- shearStdDev'.  With probability 'enrichment' the fragment\ncontaining the junction is used to form the pair of reads.  The junction\nlocation is uniformly distributed through this fragment.\nReads are labeled as:\ntMP - a MP pair\nfMP - a PE pair\naMP - a MP pair with junction in the first read\nbMP - a MP pair with junction in the second read\ncMP - a MP pair with junction in both reads (the reads overlap)"))], outputs=[], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Fastqsimulate_V0_1_0().translate("wdl", allow_empty_container=True)

