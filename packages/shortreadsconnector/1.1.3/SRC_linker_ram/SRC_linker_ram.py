from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean

Src_Linker_Ram_V0_1_0 = CommandToolBuilder(tool="SRC_linker_ram", base_command=["SRC_linker_ram"], inputs=[ToolInput(tag="in_nb_cores", input_type=Boolean(optional=True), prefix="-nb-cores", doc=InputDocumentation(doc="(1 arg) :    number of cores  [default '0']")), ToolInput(tag="in_verbose", input_type=Boolean(optional=True), prefix="-verbose", doc=InputDocumentation(doc="(1 arg) :    verbosity level  [default '1']")), ToolInput(tag="in_version", input_type=Boolean(optional=True), prefix="-version", doc=InputDocumentation(doc="(0 arg) :    version")), ToolInput(tag="in_graph", input_type=Boolean(optional=True), prefix="-graph", doc=InputDocumentation(doc="(1 arg) :    graph input")), ToolInput(tag="in_bank", input_type=Boolean(optional=True), prefix="-bank", doc=InputDocumentation(doc="(1 arg) :    bank input")), ToolInput(tag="in_query", input_type=Boolean(optional=True), prefix="-query", doc=InputDocumentation(doc="(1 arg) :    query input")), ToolInput(tag="in_out", input_type=Boolean(optional=True), prefix="-out", doc=InputDocumentation(doc="(1 arg) :    output_file")), ToolInput(tag="in_km_er_threshold", input_type=Boolean(optional=True), prefix="-kmer_threshold", doc=InputDocumentation(doc="(1 arg) :    Minimal percentage of shared kmer span for considering 2 reads as similar.  The kmer span is the number of bases from the read query covered by a kmer shared with the target read. If a read of length 80 has a kmer-span of 60 with another read from the bank (of unkonwn size), then the percentage of shared kmer span is 75%. If a least a windows (of size 'windows_size' contains at least kmer_threshold percent of positionf covered by shared kmers, the read couple is conserved).  [default '75']")), ToolInput(tag="in_windows_size", input_type=Boolean(optional=True), prefix="-windows_size", doc=InputDocumentation(doc="(1 arg) :    size of the window. If the windows size is zero (default value), then the full read is considered  [default '0']")), ToolInput(tag="in_gamma", input_type=Boolean(optional=True), prefix="-gamma", doc=InputDocumentation(doc="(1 arg) :    gamma value  [default '2']")), ToolInput(tag="in_fingerprint_size", input_type=Boolean(optional=True), prefix="-fingerprint_size", doc=InputDocumentation(doc="(1 arg) :    fingerprint size  [default '8']")), ToolInput(tag="in_core", input_type=Boolean(optional=True), prefix="-core", doc=InputDocumentation(doc="(1 arg) :    Number of thread(s)  [default '1']")), ToolInput(tag="in_no_sharing_detail", input_type=Boolean(optional=True), prefix="-no_sharing_detail", doc=InputDocumentation(doc="(0 arg) :    Output ids of reads from query input that are shared with at least one read from reference bank input. With this option no information with whom a read is shared is provided, one only knows that a read is shared.")), ToolInput(tag="in_keep_low_complexity", input_type=Boolean(optional=True), prefix="-keep_low_complexity", doc=InputDocumentation(doc="(0 arg) :    Conserve low complexity sequences during indexing and querying")), ToolInput(tag="in_zero_density_windows_size", input_type=Boolean(optional=True), prefix="-zero_density_windows_size", doc=InputDocumentation(doc="(1 arg) :    If defined (>0): two reads are linked if they DO NOT contain a window of this size, with a percentage of zero higher than '-zero_density_threshold'. Note: this test is performed over the full read length, not limited to '-windows_size'  [default '0']")), ToolInput(tag="in_zero_density_threshold", input_type=Boolean(optional=True), prefix="-zero_density_threshold", doc=InputDocumentation(doc="(1 arg) :    See '-zero_density_windows_size'  [default '80']"))], outputs=[], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Src_Linker_Ram_V0_1_0().translate("wdl", allow_empty_container=True)

