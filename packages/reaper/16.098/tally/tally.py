from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import File, String, Boolean, Int

Tally_V0_1_0 = CommandToolBuilder(tool="tally", base_command=["tally"], inputs=[ToolInput(tag="in_input_stream_gzipped", input_type=File(optional=True), prefix="-i", doc=InputDocumentation(doc="input stream (gzipped file allowed) (default STDIN)")), ToolInput(tag="in_gzipped_stream_default", input_type=String(optional=True), prefix="-o", doc=InputDocumentation(doc="(gzipped!) output stream (default out.tally.gz)")), ToolInput(tag="in_fast_a_in", input_type=Boolean(optional=True), prefix="--fasta-in", doc=InputDocumentation(doc="expect FASTA format (same as -record-format '>%I%#%R%n')")), ToolInput(tag="in_fast_a_out", input_type=Boolean(optional=True), prefix="--fasta-out", doc=InputDocumentation(doc="write FASTA format (same as -format '>trn_%I%s%C%n%R%n')")), ToolInput(tag="in_with_quality", input_type=Boolean(optional=True), prefix="--with-quality", doc=InputDocumentation(doc="pass quality scores along, collate by taking per-base max")), ToolInput(tag="in_no_auto", input_type=Boolean(optional=True), prefix="--no-auto", doc=InputDocumentation(doc="do not peek in input file and set memory parameters automatically")), ToolInput(tag="in_peek", input_type=Boolean(optional=True), prefix="--peek", doc=InputDocumentation(doc="peek in input file and output estimated memory parameters")), ToolInput(tag="in_zip_factor", input_type=Int(optional=True), prefix="-zip-factor", doc=InputDocumentation(doc="assume compression factor <num> (use 1.0 for uncompressed files")), ToolInput(tag="in_l", input_type=Int(optional=True), prefix="-l", doc=InputDocumentation(doc="require read length >= <int>")), ToolInput(tag="in_u", input_type=Int(optional=True), prefix="-u", doc=InputDocumentation(doc="require read length <= <int>")), ToolInput(tag="in_tri", input_type=Int(optional=True), prefix="-tri", doc=InputDocumentation(doc="required tri-nucleotide score <= <int>")), ToolInput(tag="in_si", input_type=Int(optional=True), prefix="-si", doc=InputDocumentation(doc="strip <int> bases from start of read before uniquifying")), ToolInput(tag="in_dsi", input_type=Int(optional=True), prefix="-dsi", doc=InputDocumentation(doc="as -si but after uniquifying (degenerate sequence insert)")), ToolInput(tag="in_sum_stat", input_type=File(optional=True), prefix="-sumstat", doc=InputDocumentation(doc="<fname> output file with counts of discarded categories")), ToolInput(tag="in_second_paired_end", input_type=String(optional=True), prefix="-j", doc=InputDocumentation(doc="second paired end input stream\n-> (requires -record-format with %J or --fastqx-in or --fastax-in)")), ToolInput(tag="in_gzipped_second_stream", input_type=String(optional=True), prefix="-p", doc=InputDocumentation(doc="(gzipped!) second output stream for second paired end (cf -j)")), ToolInput(tag="in_fast_a_x_in", input_type=Boolean(optional=True), prefix="--fastax-in", doc=InputDocumentation(doc="expect reaper --fastax-out format (same as -record-format '>%I%brecno=%J%#%R%n')")), ToolInput(tag="in_fast_qx_in", input_type=Boolean(optional=True), prefix="--fastqx-in", doc=InputDocumentation(doc="expect reaper --fastqx-out format (same as -record-format '@%I%brecno=%J%#%R%n+%#%Q%n')\n-> these two options are for re-pairing individually processed paired-end files")), ToolInput(tag="in_hsd", input_type=Boolean(optional=True), prefix="-hsd", doc=InputDocumentation(doc="[1,-1,2,-2]  increase or decrease hash size relative to default")), ToolInput(tag="in_dsd", input_type=Boolean(optional=True), prefix="-dsd", doc=InputDocumentation(doc="[1,-1,2,-2]  increase or decrease data size relative to default")), ToolInput(tag="in_hs", input_type=Int(optional=True), prefix="-hs", doc=InputDocumentation(doc="k in 14..32 specifies hash size 2 ** k")), ToolInput(tag="in_ds", input_type=Int(optional=True), prefix="-ds", doc=InputDocumentation(doc="k in 14..31 specifies storage size 2 ** k")), ToolInput(tag="in_unsorted", input_type=Boolean(optional=True), prefix="--unsorted", doc=InputDocumentation(doc="do not sort output sequences")), ToolInput(tag="in_cx", input_type=Boolean(optional=True), prefix="--cx", doc=InputDocumentation(doc="do not compress sequence (unit testing)\nNOTE with --cx output will not be sorted in the same way\nbecause hash values change. To compare, sort outputs")), ToolInput(tag="in_no_put", input_type=Boolean(optional=True), prefix="--noput", doc=InputDocumentation(doc="do not output uniquified sequences")), ToolInput(tag="in_turn_paired_end", input_type=String(optional=True), prefix="-v", doc=InputDocumentation(doc="turn on verbosity settings\ncmp         with cmp paired end identifier mismatches will be reported")), ToolInput(tag="in_record_format", input_type=Boolean(optional=True), prefix="-record-format", doc=InputDocumentation(doc="specify input format\nThe same syntax as documented under reaper --record-format,\nAdditionally %J is accepted and assumes a numerical ID that\nwill be strictly increasing.\nIf -j is used this ID is required and will be used to match reads.\nThis can be used in conjunction with the reaper %J format directive.")), ToolInput(tag="in_format", input_type=Int(optional=True), prefix="-format", doc=InputDocumentation(doc="output format specification, syntax below\n%R  read\n%L  length\n%C  number of occurrences\n%T  trinucleotide score\n%I  read identifier - numerical identifier constructed on output\nCAVEAT read identifier could differ between runs depending on options\nCAVEAT read identifier is not tied to the read sequence\n%t  tab\n%s  tab\n%n  newline\n%%  percentage character")), ToolInput(tag="in_no_tally", input_type=Boolean(optional=True), prefix="--no-tally", doc=InputDocumentation(doc="reads are output as they are processed (use --with-quality to retain quality)\nThis can be useful for matching up paired-end files with missing reads.\nIt works only if record offset information was preserved and is read back in using %J\nThe supported output directives (besides %n %s %t and %%) are these:\n%R  read\n%Q  quality\n%I  identifier\n%J  output offset\nFilter options such as -tri and -si are NOT active")), ToolInput(tag="in_pair_by_offset", input_type=Boolean(optional=True), prefix="--pair-by-offset", doc=InputDocumentation(doc="assume the -i and -j input files match record-by-record\nWith this option the %J directive is not needed\n"))], outputs=[ToolOutput(tag="out_sum_stat", output_type=File(optional=True), selector=InputSelector(input_to_select="in_sum_stat", type_hint=File()), doc=OutputDocumentation(doc="<fname> output file with counts of discarded categories"))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Tally_V0_1_0().translate("wdl", allow_empty_container=True)

