from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean

_Getorf_V0_1_0 = CommandToolBuilder(tool="_getorf", base_command=["_getorf"], inputs=[ToolInput(tag="in_table", input_type=Boolean(optional=True), prefix="-table", doc=InputDocumentation(doc="menu       [0] Code to use (Values: 0 (Standard); 1\n(Standard (with alternative initiation\ncodons)); 2 (Vertebrate Mitochondrial); 3\n(Yeast Mitochondrial); 4 (Mold, Protozoan,\nCoelenterate Mitochondrial and\nMycoplasma/Spiroplasma); 5 (Invertebrate\nMitochondrial); 6 (Ciliate Macronuclear and\nDasycladacean); 9 (Echinoderm\nMitochondrial); 10 (Euplotid Nuclear); 11\n(Bacterial); 12 (Alternative Yeast Nuclear);\n13 (Ascidian Mitochondrial); 14 (Flatworm\nMitochondrial); 15 (Blepharisma\nMacronuclear); 16 (Chlorophycean\nMitochondrial); 21 (Trematode\nMitochondrial); 22 (Scenedesmus obliquus);\n23 (Thraustochytrium Mitochondrial))")), ToolInput(tag="in_minsize", input_type=Boolean(optional=True), prefix="-minsize", doc=InputDocumentation(doc="integer    [30] Minimum nucleotide size of ORF to\nreport (Any integer value)")), ToolInput(tag="in_maxsize", input_type=Boolean(optional=True), prefix="-maxsize", doc=InputDocumentation(doc="integer    [1000000] Maximum nucleotide size of ORF to\nreport (Any integer value)")), ToolInput(tag="in_find", input_type=Boolean(optional=True), prefix="-find", doc=InputDocumentation(doc="menu       [0] This is a small menu of possible output\noptions. The first four options are to\nselect either the protein translation or the\noriginal nucleic acid sequence of the open\nreading frame. There are two possible\ndefinitions of an open reading frame: it can\neither be a region that is free of STOP\ncodons or a region that begins with a START\ncodon and ends with a STOP codon. The last\nthree options are probably only of interest\nto people who wish to investigate the\nstatistical properties of the regions around\npotential START or STOP codons. The last\noption assumes that ORF lengths are\ncalculated between two STOP codons. (Values:\n0 (Translation of regions between STOP\ncodons); 1 (Translation of regions between\nSTART and STOP codons); 2 (Nucleic sequences\nbetween STOP codons); 3 (Nucleic sequences\nbetween START and STOP codons); 4\n(Nucleotides flanking START codons); 5\n(Nucleotides flanking initial STOP codons);\n6 (Nucleotides flanking ending STOP codons))")), ToolInput(tag="in_circular", input_type=Boolean(optional=True), prefix="-circular", doc=InputDocumentation(doc="boolean    [N] Is the sequence circular")), ToolInput(tag="in_flanking", input_type=Boolean(optional=True), prefix="-flanking", doc=InputDocumentation(doc="integer    [100] If you have chosen one of the options\nof the type of sequence to find that gives\nthe flanking sequence around a STOP or START\ncodon, this allows you to set the number of\nnucleotides either side of that codon to\noutput. If the region of flanking\nnucleotides crosses the start or end of the\nsequence, no output is given for this codon.\n(Any integer value)"))], outputs=[], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    _Getorf_V0_1_0().translate("wdl", allow_empty_container=True)

