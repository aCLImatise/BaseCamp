from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Int, File, String, Boolean, Float

Wtzmo_V0_1_0 = CommandToolBuilder(tool="wtzmo", base_command=["wtzmo"], inputs=[ToolInput(tag="in_number_of_threads", input_type=Int(optional=True), prefix="-t", doc=InputDocumentation(doc="Number of threads, [1]")), ToolInput(tag="in_total_parallel_jobs", input_type=Int(optional=True), prefix="-P", doc=InputDocumentation(doc="Total parallel jobs, [1]")), ToolInput(tag="in_index_current_p", input_type=Int(optional=True), prefix="-p", doc=InputDocumentation(doc="Index of current job (0-based), [0]\nSuppose to run wtzmo parallelly in 60 nodes. For node1, -P 60 -p 0; node2, -P 60 -p 1, ...")), ToolInput(tag="in_long_reads_file", input_type=File(optional=True), prefix="-i", doc=InputDocumentation(doc="Long reads sequences file, + *")), ToolInput(tag="in_long_reads_index", input_type=File(optional=True), prefix="-I", doc=InputDocumentation(doc="Long reads sequence file, DON'T build index on them, +\nIf specified, program will only align them against all sequences from <-i>\nUseful in -I mapping contigs(not too large) against -i pacbio reads")), ToolInput(tag="in_long_reads_region", input_type=String(optional=True), prefix="-b", doc=InputDocumentation(doc="Long reads retained region, often from wtobt/wtcyc, +\nFormat: read_name\toffset\tlength\toriginal_len")), ToolInput(tag="in_jack_knife_original", input_type=Int(optional=True), prefix="-J", doc=InputDocumentation(doc="Jack knife of original read length, [0]")), ToolInput(tag="in_load_pairs_read", input_type=File(optional=True), prefix="-L", doc=InputDocumentation(doc="Load pairs of read name from file, will avoid to calculate overlap them again, + [NULL]")), ToolInput(tag="in_output_file_alignments", input_type=File(optional=True), prefix="-o", doc=InputDocumentation(doc="Output file of alignments, *")), ToolInput(tag="in_record_pairs_sequences", input_type=Int(optional=True), prefix="-9", doc=InputDocumentation(doc="Record pairs of sequences have beed aligned regardless of successful, including pairs from '-L'\nFormat: read1\tread2")), ToolInput(tag="in_force_overwrite", input_type=Boolean(optional=True), prefix="-f", doc=InputDocumentation(doc="Force overwrite")), ToolInput(tag="in_option_homopolymer_compression", input_type=Int(optional=True), prefix="-H", doc=InputDocumentation(doc="Option of homopolymer compression, [3]\n1: trun on compression on kmer\n2: trun on compression on small-kmer(zmer)")), ToolInput(tag="in_filter_high_frequency_kmers", input_type=Int(optional=True), prefix="-K", doc=InputDocumentation(doc="Filter high frequency kmers, maybe repetitive, [0]\n0: set K to 5 * <average_kmer_depth>, but no less than 100")), ToolInput(tag="in_minimum_size_kmer", input_type=Int(optional=True), prefix="-d", doc=InputDocumentation(doc="Minimum size of total seeding region for kmer windows, [300]")), ToolInput(tag="in_subsampling_kmers_kmers", input_type=Int(optional=True), prefix="-S", doc=InputDocumentation(doc="Subsampling kmers, 1/<-S> kmers are indexed, [4]")), ToolInput(tag="in_build_kmer_index", input_type=Int(optional=True), prefix="-G", doc=InputDocumentation(doc="Build kmer index in multiple iterations to save memory, 1: once, [1]\nGiven 10M reads having 100G bases, about 100/(4)=25G used in seq storage, about 100*(6)G=600G\nused in kmer-index. If -G = 10, kmer-index is divided into 10 pieces, thus taking 60G. But we need additional\n10M / <tot_jobs: -P> * 8 * <num_of_cand: -A> memory to store candidates to be aligned.")), ToolInput(tag="in_filter_high_frequency_zmers", input_type=Int(optional=True), prefix="-Z", doc=InputDocumentation(doc="Filter high frequency z-mers, maybe repetitive, [64]")), ToolInput(tag="in_ultrafast_dot_matrix", input_type=Float(optional=True), prefix="-U", doc=InputDocumentation(doc="Ultra-fast dot matrix alignment, pattern search in zmer image\nUsage: wtzmo <other_options> -s 200 -m 0.1 -U 128 -U 64 -U 160 -U 1.0 -U 0.05\n(1)    (2)   (3)    (4)    (5)\nIntra-block (1): max_gap, (2): max_deviation, (3): min_size\nInter-block (4): deviation penalty, (5): gap size penalty\nuse -U -1 instead of type six default parameters\nWill trun off -y -R -r -l -q -B -C -M -X -O -W -T -w -W -e -n -y <int>    Zmer window, [800]")), ToolInput(tag="in_minimum_size_seeding", input_type=Int(optional=True), prefix="-R", doc=InputDocumentation(doc="Minimum size of seeding region within zmer window, [200]")), ToolInput(tag="in_minimum_size_zmer", input_type=Int(optional=True), prefix="-r", doc=InputDocumentation(doc="Minimum size of total seeding region for zmer windows, [300]")), ToolInput(tag="in_maximum_variant_uncompressed", input_type=Int(optional=True), prefix="-l", doc=InputDocumentation(doc="Maximum variant of uncompressed sizes between two matched hz-kmer, [2]")), ToolInput(tag="in_threshold_seedwindow_coverage", input_type=Int(optional=True), prefix="-q", doc=InputDocumentation(doc="THreshold of seed-window coverage along query, will be used to decrease weight of repetitive region, [100]")), ToolInput(tag="in_limit_number_best_candidates", input_type=Int(optional=True), prefix="-A", doc=InputDocumentation(doc="Limit number of best candidates per read, [500]")), ToolInput(tag="in_limit_number_best_overlaps", input_type=Int(optional=True), prefix="-B", doc=InputDocumentation(doc="Limit number of best overlaps per read, [100]\nSo call 'best' is estimated by seed-windows, and increase as rd_len / avg_rd_len")), ToolInput(tag="in_skip_calculation_contained", input_type=Boolean(optional=True), prefix="-C", doc=InputDocumentation(doc="Don't skip calculation of its overlaps even when the read was contained by others")), ToolInput(tag="in_reads_files_exclued", input_type=File(optional=True), prefix="-F", doc=InputDocumentation(doc="Reads from this file(s) are to be exclued, one line for one read name, + [NULL]")), ToolInput(tag="in_alignment_penalty_match", input_type=Int(optional=True), prefix="-M", doc=InputDocumentation(doc="Alignment penalty: match, [2]")), ToolInput(tag="in_alignment_penalty_mismatch", input_type=Int(optional=True), prefix="-X", doc=InputDocumentation(doc="Alignment penalty: mismatch, [-5]")), ToolInput(tag="in_alignment_penalty_insertion", input_type=Int(optional=True), prefix="-O", doc=InputDocumentation(doc="Alignment penalty: insertion or deletion, [-3]")), ToolInput(tag="in_alignment_penalty_gap", input_type=Int(optional=True), prefix="-E", doc=InputDocumentation(doc="Alignment penalty: gap extension, [-1]")), ToolInput(tag="in_alignment_penalty_read", input_type=Int(optional=True), prefix="-T", doc=InputDocumentation(doc="Alignment penalty: read end clipping, 0: distable HSP extension, otherwise set to -50 or other [-50]")), ToolInput(tag="in_minimum_bandwidth_iteratively", input_type=Int(optional=True), prefix="-w", doc=InputDocumentation(doc="Minimum bandwidth, iteratively doubled to maximum [50]")), ToolInput(tag="in_maximum_bandwidth", input_type=Int(optional=True), prefix="-W", doc=InputDocumentation(doc="Maximum bandwidth, [3200]")), ToolInput(tag="in_maximum_bandwidth_ending", input_type=Int(optional=True), prefix="-e", doc=InputDocumentation(doc="Maximum bandwidth at ending extension, [800]")), ToolInput(tag="in_minimum_alignment_score", input_type=Int(optional=True), prefix="-s", doc=InputDocumentation(doc="Minimum alignment score, [200]")), ToolInput(tag="in_minimum_alignment_identity", input_type=Float(optional=True), prefix="-m", doc=InputDocumentation(doc="Minimum alignment identity, [0.5]")), ToolInput(tag="in_refine_the_alignment", input_type=Boolean(optional=True), prefix="-n", doc=InputDocumentation(doc="Refine the alignment")), ToolInput(tag="in_verbose_be_careful", input_type=Boolean(optional=True), prefix="-v", doc=InputDocumentation(doc="Verbose, BE careful, HUGEEEEEEEE output on STDOUT"))], outputs=[ToolOutput(tag="out_output_file_alignments", output_type=File(optional=True), selector=InputSelector(input_to_select="in_output_file_alignments", type_hint=File()), doc=OutputDocumentation(doc="Output file of alignments, *"))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Wtzmo_V0_1_0().translate("wdl", allow_empty_container=True)

