!Command
command:
- fastv
positional: []
named:
- !Flag
  optional: true
  synonyms:
  - -i
  - --in1
  description: read1 input file name (string [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -I
  - --in2
  description: read2 input file name (string [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -o
  - --out1
  description: file name to store read1 with on-target sequences (string [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -O
  - --out2
  description: file name to store read2 with on-target sequences (string [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -c
  - --kmer_collection
  description: 'the unique k-mer collection file in fasta format, see an example:
    http://opengene.org/kmer_collection.fasta (string [=])'
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -k
  - --kmer
  description: the unique k-mer file of the detection target in fasta format. data/SARS-CoV-2.kmer.fa
    will be used if none of k-mer/Genomes/k-mer_Collection file is specified (string
    [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -g
  - --genomes
  description: the genomes file of the detection target in fasta format. data/SARS-CoV-2.genomes.fa
    will be used if none of k-mer/Genomes/k-mer_Collection file is specified (string
    [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -p
  - --positive_threshold
  description: the data is considered as POSITIVE, when its mean coverage of unique
    kmer >= positive_threshold (0.001 ~ 100). 0.1 by default. (float [=0.1])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -d
  - --depth_threshold
  description: For coverage calculation. A region is considered covered when its mean
    depth >= depth_threshold (0.001 ~ 1000). 1.0 by default. (float [=1])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -E
  - --ed_threshold
  description: If the edit distance of a sequence and a genome region is <=ed_threshold,
    then consider it a match (0 ~ 50). 8 by default. (int [=8])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --long_read_threshold
  description: A read will be considered as long read if its length >= long_read_threshold
    (100 ~ 10000). 200 by default. (int [=200])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --read_segment_len
  description: A long read will be splitted to read segments, with each <= read_segment_len
    (50 ~ 5000, should be < long_read_threshold). 100 by default. (int [=100])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --bin_size
  description: For coverage calculation. The genome is splitted to many bins, with
    each bin has a length of bin_size (1 ~ 100000), default 0 means adaptive. (int
    [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -j
  - --json
  description: the json format report file name (string [=fastv.json])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -R
  - --report_title
  description: should be quoted with ' or ", default is "fastv report" (string [=fastv
    report])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -w
  - --thread
  description: worker thread number, default is 4 (int [=4])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - '-6'
  - --phred64
  description: indicate the input is using phred64 scoring (it'll be converted to
    phred33, so the output will still be phred33)
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -z
  - --compression
  description: compression level for gzip output (1 ~ 9). 1 is fastest, 9 is smallest,
    default is 4. (int [=4])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --stdin
  description: input from STDIN. If the STDIN is interleaved paired-end FASTQ, please
    also add --interleaved_in.
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --stdout
  description: stream passing-filters reads to STDOUT. This option will result in
    interleaved FASTQ output for paired-end output. Disabled by default.
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --interleaved_in
  description: indicate that <in1> is an interleaved FASTQ which contains both read1
    and read2. Disabled by default.
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --reads_to_process
  description: specify how many reads/pairs to be processed. Default 0 means process
    all reads. (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --dont_overwrite
  description: don't overwrite existing files. Overwritting is allowed by default.
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -V
  - --verbose
  description: output verbose log information (i.e. when every 1M reads are processed).
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -A
  - --disable_adapter_trimming
  description: adapter trimming is enabled by default. If this option is specified,
    adapter trimming is disabled
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -a
  - --adapter_sequence
  description: the adapter for read1. For SE data, if not specified, the adapter will
    be auto-detected. For PE data, this is used if R1/R2 are found not overlapped.
    (string [=auto])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --adapter_sequence_r2
  description: the adapter for read2 (PE data only). This is used if R1/R2 are found
    not overlapped. If not specified, it will be the same as <adapter_sequence> (string
    [=auto])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --adapter_fasta
  description: specify a FASTA file to trim both read1 and read2 (if PE) by all the
    sequences in this FASTA file (string [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --detect_adapter_for_pe
  description: by default, the auto-detection for adapter is for SE data input only,
    turn on this option to enable it for PE data.
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -f
  - --trim_front1
  description: trimming how many bases in front for read1, default is 0 (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -t
  - --trim_tail1
  description: trimming how many bases in tail for read1, default is 0 (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -b
  - --max_len1
  description: if read1 is longer than max_len1, then trim read1 at its tail to make
    it as long as max_len1. Default 0 means no limitation (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -F
  - --trim_front2
  description: trimming how many bases in front for read2. If it's not specified,
    it will follow read1's settings (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -T
  - --trim_tail2
  description: trimming how many bases in tail for read2. If it's not specified, it
    will follow read1's settings (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -B
  - --max_len2
  description: if read2 is longer than max_len2, then trim read2 at its tail to make
    it as long as max_len2. Default 0 means no limitation. If it's not specified,
    it will follow read1's settings (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --poly_g_min_len
  description: the minimum length to detect polyG in the read tail. 10 by default.
    (int [=10])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -G
  - --disable_trim_poly_g
  description: disable polyG tail trimming, by default trimming is automatically enabled
    for Illumina NextSeq/NovaSeq data
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -x
  - --trim_poly_x
  description: enable polyX trimming in 3' ends.
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --poly_x_min_len
  description: the minimum length to detect polyX in the read tail. 10 by default.
    (int [=10])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - '-5'
  - --cut_front
  description: move a sliding window from front (5') to tail, drop the bases in the
    window if its mean quality < threshold, stop otherwise.
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - '-3'
  - --cut_tail
  description: move a sliding window from tail (3') to front, drop the bases in the
    window if its mean quality < threshold, stop otherwise.
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -r
  - --cut_right
  description: move a sliding window from front to tail, if meet one window with mean
    quality < threshold, drop the bases in the window and the right part, and then
    stop.
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -W
  - --cut_window_size
  description: 'the window size option shared by cut_front, cut_tail or cut_sliding.
    Range: 1~1000, default: 4 (int [=4])'
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -M
  - --cut_mean_quality
  description: 'the mean quality requirement option shared by cut_front, cut_tail
    or cut_sliding. Range: 1~36 default: 20 (Q20) (int [=20])'
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --cut_front_window_size
  description: the window size option of cut_front, default to cut_window_size if
    not specified (int [=4])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --cut_front_mean_quality
  description: the mean quality requirement option for cut_front, default to cut_mean_quality
    if not specified (int [=20])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --cut_tail_window_size
  description: the window size option of cut_tail, default to cut_window_size if not
    specified (int [=4])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --cut_tail_mean_quality
  description: the mean quality requirement option for cut_tail, default to cut_mean_quality
    if not specified (int [=20])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --cut_right_window_size
  description: the window size option of cut_right, default to cut_window_size if
    not specified (int [=4])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --cut_right_mean_quality
  description: the mean quality requirement option for cut_right, default to cut_mean_quality
    if not specified (int [=20])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -Q
  - --disable_quality_filtering
  description: quality filtering is enabled by default. If this option is specified,
    quality filtering is disabled
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -q
  - --qualified_quality_phred
  description: the quality value that a base is qualified. Default 15 means phred
    quality >=Q15 is qualified. (int [=15])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -u
  - --unqualified_percent_limit
  description: how many percents of bases are allowed to be unqualified (0~100). Default
    40 means 40% (int [=40])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -n
  - --n_base_limit
  description: if one read's number of N base is >n_base_limit, then this read/pair
    is discarded. Default is 5 (int [=5])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -e
  - --average_qual
  description: if one read's average quality score <avg_qual, then this read/pair
    is discarded. Default 0 means no requirement (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -L
  - --disable_length_filtering
  description: length filtering is enabled by default. If this option is specified,
    length filtering is disabled
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -l
  - --length_required
  description: reads shorter than length_required will be discarded, default is 15.
    (int [=15])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --length_limit
  description: reads longer than length_limit will be discarded, default 0 means no
    limitation. (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -y
  - --low_complexity_filter
  description: enable low complexity filter. The complexity is defined as the percentage
    of base that is different from its next base (base[i] != base[i+1]).
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -Y
  - --complexity_threshold
  description: the threshold for low complexity filter (0~100). Default is 30, which
    means 30% complexity is required. (int [=30])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --filter_by_index1
  description: specify a file contains a list of barcodes of index1 to be filtered
    out, one barcode per line (string [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --filter_by_index2
  description: specify a file contains a list of barcodes of index2 to be filtered
    out, one barcode per line (string [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --filter_by_index_threshold
  description: the allowed difference of index barcode for index filtering, default
    0 means completely identical. (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -C
  - --correction
  description: enable base correction in overlapped regions (only for PE data), default
    is disabled
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --overlap_len_require
  description: the minimum length to detect overlapped region of PE reads. This will
    affect overlap analysis based PE merge, adapter trimming and correction. 30 by
    default. (int [=30])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --overlap_diff_limit
  description: the maximum number of mismatched bases to detect overlapped region
    of PE reads. This will affect overlap analysis based PE merge, adapter trimming
    and correction. 5 by default. (int [=5])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --overlap_diff_percent_limit
  description: the maximum percentage of mismatched bases to detect overlapped region
    of PE reads. This will affect overlap analysis based PE merge, adapter trimming
    and correction. Default 20 means 20%. (int [=20])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - -U
  - --umi
  description: enable unique molecular identifier (UMI) preprocessing
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --umi_loc
  description: specify the location of UMI, can be (index1/index2/read1/read2/per_index/per_read,
    default is none (string [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --umi_len
  description: if the UMI is in read1/read2, its length should be provided (int [=0])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --umi_prefix
  description: if specified, an underline will be used to connect prefix and UMI (i.e.
    prefix=UMI, UMI=AATTCG, final=UMI_AATTCG). No prefix by default (string [=])
  args: !EmptyFlagArg {}
- !Flag
  optional: true
  synonyms:
  - --umi_skip
  description: if the UMI is in read1/read2, fastv can skip several bases following
    UMI, default is 0 (int [=0])
  args: !EmptyFlagArg {}
parent:
subcommands: []
usage: []
help_flag: !Flag
  optional: true
  synonyms:
  - -h
  - --html
  description: the html format report file name (string [=fastv.html])
  args: !EmptyFlagArg {}
usage_flag:
version_flag:
help_text: "usage: fastv [options] ... \noptions:\n  -i, --in1                   \
  \        read1 input file name (string [=])\n  -I, --in2                       \
  \    read2 input file name (string [=])\n  -o, --out1                          file\
  \ name to store read1 with on-target sequences (string [=])\n  -O, --out2      \
  \                    file name to store read2 with on-target sequences (string [=])\n\
  \  -c, --kmer_collection               the unique k-mer collection file in fasta\
  \ format, see an example: http://opengene.org/kmer_collection.fasta (string [=])\n\
  \  -k, --kmer                          the unique k-mer file of the detection target\
  \ in fasta format. data/SARS-CoV-2.kmer.fa will be used if none of k-mer/Genomes/k-mer_Collection\
  \ file is specified (string [=])\n  -g, --genomes                       the genomes\
  \ file of the detection target in fasta format. data/SARS-CoV-2.genomes.fa will\
  \ be used if none of k-mer/Genomes/k-mer_Collection file is specified (string [=])\n\
  \  -p, --positive_threshold            the data is considered as POSITIVE, when\
  \ its mean coverage of unique kmer >= positive_threshold (0.001 ~ 100). 0.1 by default.\
  \ (float [=0.1])\n  -d, --depth_threshold               For coverage calculation.\
  \ A region is considered covered when its mean depth >= depth_threshold (0.001 ~\
  \ 1000). 1.0 by default. (float [=1])\n  -E, --ed_threshold                  If\
  \ the edit distance of a sequence and a genome region is <=ed_threshold, then consider\
  \ it a match (0 ~ 50). 8 by default. (int [=8])\n      --long_read_threshold   \
  \        A read will be considered as long read if its length >= long_read_threshold\
  \ (100 ~ 10000). 200 by default. (int [=200])\n      --read_segment_len        \
  \      A long read will be splitted to read segments, with each <= read_segment_len\
  \ (50 ~ 5000, should be < long_read_threshold). 100 by default. (int [=100])\n \
  \     --bin_size                      For coverage calculation. The genome is splitted\
  \ to many bins, with each bin has a length of bin_size (1 ~ 100000), default 0 means\
  \ adaptive. (int [=0])\n  -j, --json                          the json format report\
  \ file name (string [=fastv.json])\n  -h, --html                          the html\
  \ format report file name (string [=fastv.html])\n  -R, --report_title         \
  \         should be quoted with ' or \", default is \"fastv report\" (string [=fastv\
  \ report])\n  -w, --thread                        worker thread number, default\
  \ is 4 (int [=4])\n  -6, --phred64                       indicate the input is using\
  \ phred64 scoring (it'll be converted to phred33, so the output will still be phred33)\n\
  \  -z, --compression                   compression level for gzip output (1 ~ 9).\
  \ 1 is fastest, 9 is smallest, default is 4. (int [=4])\n      --stdin         \
  \                input from STDIN. If the STDIN is interleaved paired-end FASTQ,\
  \ please also add --interleaved_in.\n      --stdout                        stream\
  \ passing-filters reads to STDOUT. This option will result in interleaved FASTQ\
  \ output for paired-end output. Disabled by default.\n      --interleaved_in   \
  \             indicate that <in1> is an interleaved FASTQ which contains both read1\
  \ and read2. Disabled by default.\n      --reads_to_process              specify\
  \ how many reads/pairs to be processed. Default 0 means process all reads. (int\
  \ [=0])\n      --dont_overwrite                don't overwrite existing files. Overwritting\
  \ is allowed by default.\n  -V, --verbose                       output verbose log\
  \ information (i.e. when every 1M reads are processed).\n  -A, --disable_adapter_trimming\
  \      adapter trimming is enabled by default. If this option is specified, adapter\
  \ trimming is disabled\n  -a, --adapter_sequence              the adapter for read1.\
  \ For SE data, if not specified, the adapter will be auto-detected. For PE data,\
  \ this is used if R1/R2 are found not overlapped. (string [=auto])\n      --adapter_sequence_r2\
  \           the adapter for read2 (PE data only). This is used if R1/R2 are found\
  \ not overlapped. If not specified, it will be the same as <adapter_sequence> (string\
  \ [=auto])\n      --adapter_fasta                 specify a FASTA file to trim both\
  \ read1 and read2 (if PE) by all the sequences in this FASTA file (string [=])\n\
  \      --detect_adapter_for_pe         by default, the auto-detection for adapter\
  \ is for SE data input only, turn on this option to enable it for PE data.\n  -f,\
  \ --trim_front1                   trimming how many bases in front for read1, default\
  \ is 0 (int [=0])\n  -t, --trim_tail1                    trimming how many bases\
  \ in tail for read1, default is 0 (int [=0])\n  -b, --max_len1                 \
  \     if read1 is longer than max_len1, then trim read1 at its tail to make it as\
  \ long as max_len1. Default 0 means no limitation (int [=0])\n  -F, --trim_front2\
  \                   trimming how many bases in front for read2. If it's not specified,\
  \ it will follow read1's settings (int [=0])\n  -T, --trim_tail2               \
  \     trimming how many bases in tail for read2. If it's not specified, it will\
  \ follow read1's settings (int [=0])\n  -B, --max_len2                      if read2\
  \ is longer than max_len2, then trim read2 at its tail to make it as long as max_len2.\
  \ Default 0 means no limitation. If it's not specified, it will follow read1's settings\
  \ (int [=0])\n      --poly_g_min_len                the minimum length to detect\
  \ polyG in the read tail. 10 by default. (int [=10])\n  -G, --disable_trim_poly_g\
  \           disable polyG tail trimming, by default trimming is automatically enabled\
  \ for Illumina NextSeq/NovaSeq data\n  -x, --trim_poly_x                   enable\
  \ polyX trimming in 3' ends.\n      --poly_x_min_len                the minimum\
  \ length to detect polyX in the read tail. 10 by default. (int [=10])\n  -5, --cut_front\
  \                     move a sliding window from front (5') to tail, drop the bases\
  \ in the window if its mean quality < threshold, stop otherwise.\n  -3, --cut_tail\
  \                      move a sliding window from tail (3') to front, drop the bases\
  \ in the window if its mean quality < threshold, stop otherwise.\n  -r, --cut_right\
  \                     move a sliding window from front to tail, if meet one window\
  \ with mean quality < threshold, drop the bases in the window and the right part,\
  \ and then stop.\n  -W, --cut_window_size               the window size option shared\
  \ by cut_front, cut_tail or cut_sliding. Range: 1~1000, default: 4 (int [=4])\n\
  \  -M, --cut_mean_quality              the mean quality requirement option shared\
  \ by cut_front, cut_tail or cut_sliding. Range: 1~36 default: 20 (Q20) (int [=20])\n\
  \      --cut_front_window_size         the window size option of cut_front, default\
  \ to cut_window_size if not specified (int [=4])\n      --cut_front_mean_quality\
  \        the mean quality requirement option for cut_front, default to cut_mean_quality\
  \ if not specified (int [=20])\n      --cut_tail_window_size          the window\
  \ size option of cut_tail, default to cut_window_size if not specified (int [=4])\n\
  \      --cut_tail_mean_quality         the mean quality requirement option for cut_tail,\
  \ default to cut_mean_quality if not specified (int [=20])\n      --cut_right_window_size\
  \         the window size option of cut_right, default to cut_window_size if not\
  \ specified (int [=4])\n      --cut_right_mean_quality        the mean quality requirement\
  \ option for cut_right, default to cut_mean_quality if not specified (int [=20])\n\
  \  -Q, --disable_quality_filtering     quality filtering is enabled by default.\
  \ If this option is specified, quality filtering is disabled\n  -q, --qualified_quality_phred\
  \       the quality value that a base is qualified. Default 15 means phred quality\
  \ >=Q15 is qualified. (int [=15])\n  -u, --unqualified_percent_limit     how many\
  \ percents of bases are allowed to be unqualified (0~100). Default 40 means 40%\
  \ (int [=40])\n  -n, --n_base_limit                  if one read's number of N base\
  \ is >n_base_limit, then this read/pair is discarded. Default is 5 (int [=5])\n\
  \  -e, --average_qual                  if one read's average quality score <avg_qual,\
  \ then this read/pair is discarded. Default 0 means no requirement (int [=0])\n\
  \  -L, --disable_length_filtering      length filtering is enabled by default. If\
  \ this option is specified, length filtering is disabled\n  -l, --length_required\
  \               reads shorter than length_required will be discarded, default is\
  \ 15. (int [=15])\n      --length_limit                  reads longer than length_limit\
  \ will be discarded, default 0 means no limitation. (int [=0])\n  -y, --low_complexity_filter\
  \         enable low complexity filter. The complexity is defined as the percentage\
  \ of base that is different from its next base (base[i] != base[i+1]).\n  -Y, --complexity_threshold\
  \          the threshold for low complexity filter (0~100). Default is 30, which\
  \ means 30% complexity is required. (int [=30])\n      --filter_by_index1      \
  \        specify a file contains a list of barcodes of index1 to be filtered out,\
  \ one barcode per line (string [=])\n      --filter_by_index2              specify\
  \ a file contains a list of barcodes of index2 to be filtered out, one barcode per\
  \ line (string [=])\n      --filter_by_index_threshold     the allowed difference\
  \ of index barcode for index filtering, default 0 means completely identical. (int\
  \ [=0])\n  -C, --correction                    enable base correction in overlapped\
  \ regions (only for PE data), default is disabled\n      --overlap_len_require \
  \          the minimum length to detect overlapped region of PE reads. This will\
  \ affect overlap analysis based PE merge, adapter trimming and correction. 30 by\
  \ default. (int [=30])\n      --overlap_diff_limit            the maximum number\
  \ of mismatched bases to detect overlapped region of PE reads. This will affect\
  \ overlap analysis based PE merge, adapter trimming and correction. 5 by default.\
  \ (int [=5])\n      --overlap_diff_percent_limit    the maximum percentage of mismatched\
  \ bases to detect overlapped region of PE reads. This will affect overlap analysis\
  \ based PE merge, adapter trimming and correction. Default 20 means 20%. (int [=20])\n\
  \  -U, --umi                           enable unique molecular identifier (UMI)\
  \ preprocessing\n      --umi_loc                       specify the location of UMI,\
  \ can be (index1/index2/read1/read2/per_index/per_read, default is none (string\
  \ [=])\n      --umi_len                       if the UMI is in read1/read2, its\
  \ length should be provided (int [=0])\n      --umi_prefix                    if\
  \ specified, an underline will be used to connect prefix and UMI (i.e. prefix=UMI,\
  \ UMI=AATTCG, final=UMI_AATTCG). No prefix by default (string [=])\n      --umi_skip\
  \                      if the UMI is in read1/read2, fastv can skip several bases\
  \ following UMI, default is 0 (int [=0])\n  -?, --help                         \
  \ print this message\n"
generated_using:
- --help
docker_image: quay.io/biocontainers/fastv:0.8.1--he513fc3_0
