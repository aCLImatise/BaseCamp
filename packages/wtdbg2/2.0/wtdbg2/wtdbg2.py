from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import File, String, Int, Boolean, Float

Wtdbg2_V0_1_0 = CommandToolBuilder(tool="wtdbg2", base_command=["wtdbg2"], inputs=[ToolInput(tag="in_long_reads_file", input_type=File(optional=True), prefix="-i", doc=InputDocumentation(doc="Long reads sequences file (REQUIRED; can be multiple), []")), ToolInput(tag="in_errorfree_sequences_file", input_type=File(optional=True), prefix="-I", doc=InputDocumentation(doc="Error-free sequences file (can be multiple), []")), ToolInput(tag="in_prefix_output_required", input_type=String(optional=True), prefix="-o", doc=InputDocumentation(doc="Prefix of output files (REQUIRED), []")), ToolInput(tag="in_number_threads_cores", input_type=Int(optional=True), prefix="-t", doc=InputDocumentation(doc="Number of threads, 0 for all cores, [4]")), ToolInput(tag="in_force_overwrite_files", input_type=Boolean(optional=True), prefix="-f", doc=InputDocumentation(doc="Force to overwrite output files")), ToolInput(tag="in_choose_longest_subread", input_type=Int(optional=True), prefix="-L", doc=InputDocumentation(doc="Choose the longest subread and drop reads shorter than <int> (5000 recommended for PacBio) [0]")), ToolInput(tag="in_kmer_psize_seed", input_type=Int(optional=True), prefix="-p", doc=InputDocumentation(doc="Kmer psize, 0 <= p <= 25, [21]\nk + p <= 25, seed is <k-mer>+<p-homopolymer-compressed>")), ToolInput(tag="in_filter_high_frequency", input_type=Float(optional=True), prefix="-K", doc=InputDocumentation(doc="Filter high frequency kmers, maybe repetitive, [1000]\nif K >= 1, take the integer value as cutoff, MUST <= 65535\nelse, mask the top fraction part high frequency kmers")), ToolInput(tag="in_min_kmer_frequency", input_type=Int(optional=True), prefix="-E", doc=InputDocumentation(doc="Min kmer frequency, [2]")), ToolInput(tag="in_filter_low_frequency", input_type=Boolean(optional=True), prefix="-F", doc=InputDocumentation(doc="Filter low frequency kmers by a 4G-bytes array (max_occ=3 2-bits). Here, -E must greater than 1")), ToolInput(tag="in_max_one_gap", input_type=Int(optional=True), prefix="-X", doc=InputDocumentation(doc="Max number of bin(256bp) in one gap, [4]")), ToolInput(tag="in_max_one_deviation", input_type=Int(optional=True), prefix="-Y", doc=InputDocumentation(doc="Max number of bin(256bp) in one deviation, [4]")), ToolInput(tag="in_penalty_bin_gap", input_type=Int(optional=True), prefix="-x", doc=InputDocumentation(doc="penalty for BIN gap, [-7]")), ToolInput(tag="in_penalty_bin_deviation", input_type=Int(optional=True), prefix="-y", doc=InputDocumentation(doc="penalty for BIN deviation, [-21]")), ToolInput(tag="in_min_length_alignment", input_type=Float(optional=True), prefix="-l", doc=InputDocumentation(doc="Min length of alignment, [2048]")), ToolInput(tag="in_min_matched", input_type=Float(optional=True), prefix="-m", doc=InputDocumentation(doc="Min matched, [200]")), ToolInput(tag="in_keep_contained_reads", input_type=Boolean(optional=True), prefix="-A", doc=InputDocumentation(doc="Keep contained reads during alignment")), ToolInput(tag="in_max_length_variation", input_type=Float(optional=True), prefix="-s", doc=InputDocumentation(doc="Max length variation of two aligned fragments, [0.2]")), ToolInput(tag="in_min_read_depth", input_type=Int(optional=True), prefix="-e", doc=InputDocumentation(doc="Min read depth of a valid edge, [3]")), ToolInput(tag="in_quiet", input_type=Boolean(optional=True), prefix="-q", doc=InputDocumentation(doc="Quiet")), ToolInput(tag="in_verbose_be_multiple", input_type=Boolean(optional=True), prefix="-v", doc=InputDocumentation(doc="Verbose (can be multiple)")), ToolInput(tag="in_cpu", input_type=Int(optional=True), prefix="--cpu", doc=InputDocumentation(doc="See -t 0, default: all cores")), ToolInput(tag="in_input", input_type=String(optional=True), prefix="--input", doc=InputDocumentation(doc="+\nSee -i")), ToolInput(tag="in_err_free_seq", input_type=String(optional=True), prefix="--err-free-seq", doc=InputDocumentation(doc="+\nSee -I. Error-free sequences will be firstly token for nodes, if --err-free-nodes is specified, only select nodes from those sequences")), ToolInput(tag="in_force", input_type=Boolean(optional=True), prefix="--force", doc=InputDocumentation(doc="See -f")), ToolInput(tag="in_prefix", input_type=String(optional=True), prefix="--prefix", doc=InputDocumentation(doc="See -o")), ToolInput(tag="in_km_er_f_size", input_type=Int(optional=True), prefix="--kmer-fsize", doc=InputDocumentation(doc="See -k 0")), ToolInput(tag="in_km_er_p_size", input_type=Int(optional=True), prefix="--kmer-psize", doc=InputDocumentation(doc="See -p 21")), ToolInput(tag="in_km_er_depth_max", input_type=Float(optional=True), prefix="--kmer-depth-max", doc=InputDocumentation(doc="See -K 1000")), ToolInput(tag="in_km_er_depth_min", input_type=Int(optional=True), prefix="--kmer-depth-min", doc=InputDocumentation(doc="See -E")), ToolInput(tag="in_km_er_depth_min_filter", input_type=Boolean(optional=True), prefix="--kmer-depth-min-filter", doc=InputDocumentation(doc="See -F\n`wtdbg` uses a 4 Gbytes array to counting the occurence (0-3) of kmers in the way of counting-bloom-filter. It will reduce memory space largely\nOrphaned kmers won't appear in building kbm-index")), ToolInput(tag="in_km_er_sub_am_pling", input_type=Int(optional=True), prefix="--kmer-subampling", doc=InputDocumentation(doc="See -S 1")), ToolInput(tag="in_aln_km_er_sampling", input_type=Int(optional=True), prefix="--aln-kmer-sampling", doc=InputDocumentation(doc="Select no more than n seeds in a query bin, default: 256")), ToolInput(tag="in_dp_max_gap", input_type=Int(optional=True), prefix="--dp-max-gap", doc=InputDocumentation(doc="See -X 4")), ToolInput(tag="in_dp_max_var", input_type=Int(optional=True), prefix="--dp-max-var", doc=InputDocumentation(doc="See -Y 4")), ToolInput(tag="in_dp_penalty_gap", input_type=Int(optional=True), prefix="--dp-penalty-gap", doc=InputDocumentation(doc="See -x -7")), ToolInput(tag="in_dp_penalty_var", input_type=Int(optional=True), prefix="--dp-penalty-var", doc=InputDocumentation(doc="See -y -21")), ToolInput(tag="in_aln_min_length", input_type=Int(optional=True), prefix="--aln-min-length", doc=InputDocumentation(doc="See -l 2048")), ToolInput(tag="in_aln_min_match", input_type=Int(optional=True), prefix="--aln-min-match", doc=InputDocumentation(doc="See -m 200. Here the num of matches counting basepair of the matched kmer's regions")), ToolInput(tag="in_aln_max_var", input_type=Float(optional=True), prefix="--aln-max-var", doc=InputDocumentation(doc="See -s 0.2")), ToolInput(tag="in_aln_dovetail", input_type=Int(optional=True), prefix="--aln-dovetail", doc=InputDocumentation(doc="Retain dovetail overlaps only, the max overhang size is <--aln-dovetail>, -1 to disable filtering, default: 256")), ToolInput(tag="in_aln_strand", input_type=Int(optional=True), prefix="--aln-strand", doc=InputDocumentation(doc="1: forward, 2: reverse, 3: both. Please don't change the deault vaule 3, unless you exactly know what you are doing")), ToolInput(tag="in_aln_max_hit", input_type=Int(optional=True), prefix="--aln-maxhit", doc=InputDocumentation(doc="Max n hits for each read in build graph, default: 1000")), ToolInput(tag="in_aln_best_n", input_type=Int(optional=True), prefix="--aln-bestn", doc=InputDocumentation(doc="Use best n hits for each read in build graph, 0: keep all, default: 500\n<prefix>.alignments always store all alignments")), ToolInput(tag="in_aln_no_skip", input_type=Boolean(optional=True), prefix="--aln-noskip", doc=InputDocumentation(doc="Even a read was contained in previous alignment, still align it against other reads")), ToolInput(tag="in_verbose", input_type=Boolean(optional=True), prefix="--verbose", doc=InputDocumentation(doc="+\nSee -v. -vvvv will display the most detailed information")), ToolInput(tag="in_quiet", input_type=Boolean(optional=True), prefix="--quiet", doc=InputDocumentation(doc="See -q")), ToolInput(tag="in_tidy_reads", input_type=Int(optional=True), prefix="--tidy-reads", doc=InputDocumentation(doc="Default: 0. Pick longest subreads if possible. Filter reads less than <--tidy-reads>. Rename reads into 'S%010d' format. The first read is named as S0000000001\nSet to 0 bp to disable tidy. Suggested vaule is 5000 for pacbio reads")), ToolInput(tag="in_err_free_nodes", input_type=Boolean(optional=True), prefix="--err-free-nodes", doc=InputDocumentation(doc="Select nodes from error-free-sequences only. E.g. you have contigs assembled from NGS-WGS reads, and long noisy reads.\nYou can type '--err-free-seq your_ctg.fa --input your_long_reads.fa --err-free-nodes' to perform assembly somehow act as long-reads scaffolding")), ToolInput(tag="in_limit_input", input_type=Int(optional=True), prefix="--limit-input", doc=InputDocumentation(doc="Limit the input sequences to at most <int> M bp. Usually for test")), ToolInput(tag="in_node_len", input_type=Int(optional=True), prefix="--node-len", doc=InputDocumentation(doc="The default value is 1024, which is times of KBM_BIN_SIZE(always equals 256 bp). It specifies the length of intervals (or call nodes after selecting).\nkbm indexs sequences into BINs of 256 bp in size, so that many parameter should be times of 256 bp. There are: --node-len, --node-ovl, --aln-min-length, --aln-dovetail .   Other parameters are counted in BINs, --dp-max-gap, --dp-max-var .")), ToolInput(tag="in_node_matched_bins", input_type=Int(optional=True), prefix="--node-matched-bins", doc=InputDocumentation(doc="Min matched bins in a node, default:1")), ToolInput(tag="in_node_ovl", input_type=Int(optional=True), prefix="--node-ovl", doc=InputDocumentation(doc="Default: 256. Max overlap size between two adjacent intervals in any read. It is used in selecting best nodes representing reads in graph")), ToolInput(tag="in_edge_min", input_type=Int(optional=True), prefix="--edge-min", doc=InputDocumentation(doc="Default: 3. The minimal depth of a valid edge is set to 3. In another word, Valid edges must be supported by at least 3 reads\nWhen the sequence depth is low, have a try with --edge-min 2. Or very high, try --edge-min 4")), ToolInput(tag="in_drop_low_cov_edges", input_type=Boolean(optional=True), prefix="--drop-low-cov-edges", doc=InputDocumentation(doc="Don't attempt to rescue low coverage edges")), ToolInput(tag="in_node_min", input_type=Int(optional=True), prefix="--node-min", doc=InputDocumentation(doc="Min depth of a intreval to be selected as valid node. Defaultly, this value is automaticly the same with --edge-min.")), ToolInput(tag="in_node_max", input_type=Int(optional=True), prefix="--node-max", doc=InputDocumentation(doc="Nodes with too high depth will be regarded as repetitive, and be masked. Default: 200, more than 200 reads contain this node")), ToolInput(tag="in_ttr_cut_off_ratio", input_type=Float(optional=True), prefix="--ttr-cutoff-ratio", doc=InputDocumentation(doc=", 0.5\nTiny Tandom Repeat. A node located inside ttr will bring noisy in graph, should be masked. The pattern of such nodes is:\ndepth >= <--ttr-cutoff-depth>, and none of their edges have depth greater than depth * <--ttr-cutoff-ratio 0.5>\nset --ttr-cutoff-depth 0 to disable ttr masking")), ToolInput(tag="in_dump_kbm", input_type=File(optional=True), prefix="--dump-kbm", doc=InputDocumentation(doc="Dump kbm index into file for loaded by `kbm` or `wtdbg`")), ToolInput(tag="in_load_kbm", input_type=File(optional=True), prefix="--load-kbm", doc=InputDocumentation(doc="Instead of reading sequences and building kbm index, which is time-consumed, loading kbm-index from already dumped file.\nPlease note that, once kbm-index is mmaped by kbm -R <kbm-index> start, will just get the shared memory in minute time.\nSee `kbm` -R <your_seqs.kbmidx> [start | stop]")), ToolInput(tag="in_load_alignments", input_type=File(optional=True), prefix="--load-alignments", doc=InputDocumentation(doc="+\n`wtdbg` output reads' alignments into <--prefix>.alignments, program can load them to fastly build assembly graph. Or you can offer\nother source of alignments to `wtdbg`. When --load-alignment, will only reading long sequences but skip building kbm index\nYou can type --load-alignments <file> more than once to load alignments from many files")), ToolInput(tag="in_load_clips", input_type=String(optional=True), prefix="--load-clips", doc=InputDocumentation(doc="Combined with --load-nodes. Load reads clips. You can find it in `wtdbg`'s <--prefix>.clps")), ToolInput(tag="in_load_nodes", input_type=Float(optional=True), prefix="--load-nodes", doc=InputDocumentation(doc="Load dumped nodes from previous execution for fast construct the assembly graph, should be combined with --load-clips. You can find it in `wtdbg`'s <--prefix>.1.nodes")), ToolInput(tag="in_bubble_step", input_type=Int(optional=True), prefix="--bubble-step", doc=InputDocumentation(doc="Max step to search a bubble, meaning the max step from the starting node to the ending node. Default: 40")), ToolInput(tag="in_tip_step", input_type=Int(optional=True), prefix="--tip-step", doc=InputDocumentation(doc="Max step to search a tip, 10")), ToolInput(tag="in_ctg_min_length", input_type=Int(optional=True), prefix="--ctg-min-length", doc=InputDocumentation(doc="Min length of contigs to be output, 5000")), ToolInput(tag="in_ctg_min_nodes", input_type=Int(optional=True), prefix="--ctg-min-nodes", doc=InputDocumentation(doc="Min num of nodes in a contig to be ouput, 3")), ToolInput(tag="in_minimal_output", input_type=Boolean(optional=True), prefix="--minimal-output", doc=InputDocumentation(doc="Will generate as less output files (<--prefix>.*) as it can")), ToolInput(tag="in_bin_complexity_cut_off", input_type=Int(optional=True), prefix="--bin-complexity-cutoff", doc=InputDocumentation(doc="Used in filtering BINs. If a BIN has less indexed valid kmers than <--bin-complexity-cutoff 2>, masks it.")), ToolInput(tag="in_no_local_graph_analysis", input_type=Boolean(optional=True), prefix="--no-local-graph-analysis", doc=InputDocumentation(doc="Before building edges, for each node, local-graph-analysis reads all related reads and according nodes, and builds a local graph to judge whether to mask it\nThe analysis aims to find repetitive nodes")), ToolInput(tag="in_no_read_length_sort", input_type=Boolean(optional=True), prefix="--no-read-length-sort", doc=InputDocumentation(doc="Defaultly, `wtdbg` sorts input sequences by length DSC. The order of reads affects the generating of nodes in selecting important intervals")), ToolInput(tag="in_keep_isolated_nodes", input_type=Boolean(optional=True), prefix="--keep-isolated-nodes", doc=InputDocumentation(doc="In graph clean, `wtdbg` normally masks isolated (orphaned) nodes")), ToolInput(tag="in_no_read_clip", input_type=Boolean(optional=True), prefix="--no-read-clip", doc=InputDocumentation(doc="Defaultly, `wtdbg` clips a input sequence by analyzing its overlaps to remove high error endings, rolling-circle repeats (see PacBio CCS), and chimera.\nWhen building edges, clipped region won't contribute. However, `wtdbg` will use them in the final linking of unitigs")), ToolInput(tag="in_no_chain_ning_clip", input_type=Boolean(optional=True), prefix="--no-chainning-clip", doc=InputDocumentation(doc="Defaultly, performs alignments chainning in read clipping\n** If '--aln-bestn 0 --no-read-clip', alignments will be parsed directly, and less RAM spent on recording alignments\n"))], outputs=[ToolOutput(tag="out_load_alignments", output_type=File(optional=True), selector=InputSelector(input_to_select="in_load_alignments", type_hint=File()), doc=OutputDocumentation(doc="+\n`wtdbg` output reads' alignments into <--prefix>.alignments, program can load them to fastly build assembly graph. Or you can offer\nother source of alignments to `wtdbg`. When --load-alignment, will only reading long sequences but skip building kbm index\nYou can type --load-alignments <file> more than once to load alignments from many files"))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Wtdbg2_V0_1_0().translate("wdl", allow_empty_container=True)

