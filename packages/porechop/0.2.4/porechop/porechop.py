from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Directory, File, String, Int, Float, Boolean

Porechop_V0_1_0 = CommandToolBuilder(tool="porechop", base_command=["porechop"], inputs=[ToolInput(tag="in_input", input_type=Directory(optional=True), prefix="--input", doc=InputDocumentation(doc="FASTA/FASTQ of input reads or a directory which will\nbe recursively searched for FASTQ files (required)")), ToolInput(tag="in_output", input_type=File(optional=True), prefix="--output", doc=InputDocumentation(doc="Filename for FASTA or FASTQ of trimmed reads (if not\nset, trimmed reads will be printed to stdout)")), ToolInput(tag="in_format", input_type=String(optional=True), prefix="--format", doc=InputDocumentation(doc="Output format for the reads - if auto, the format\nwill be chosen based on the output filename or the\ninput read format (default: auto)")), ToolInput(tag="in_verbosity", input_type=File(optional=True), prefix="--verbosity", doc=InputDocumentation(doc="Level of progress information: 0 = none, 1 = some, 2\n= lots, 3 = full - output will go to stdout if reads\nare saved to a file and stderr if reads are printed\nto stdout (default: 1)")), ToolInput(tag="in_threads", input_type=Int(optional=True), prefix="--threads", doc=InputDocumentation(doc="Number of threads to use for adapter alignment\n(default: 8)")), ToolInput(tag="in_barcode_dir", input_type=Directory(optional=True), prefix="--barcode_dir", doc=InputDocumentation(doc="Reads will be binned based on their barcode and\nsaved to separate files in this directory\n(incompatible with --output)")), ToolInput(tag="in_barcode_threshold", input_type=Float(optional=True), prefix="--barcode_threshold", doc=InputDocumentation(doc="A read must have at least this percent identity to a\nbarcode to be binned (default: 75.0)")), ToolInput(tag="in_barcode_diff", input_type=Float(optional=True), prefix="--barcode_diff", doc=InputDocumentation(doc="If the difference between a read's best barcode\nidentity and its second-best barcode identity is\nless than this value, it will not be put in a\nbarcode bin (to exclude cases which are too close to\ncall) (default: 5.0)")), ToolInput(tag="in_require_two_barcodes", input_type=Boolean(optional=True), prefix="--require_two_barcodes", doc=InputDocumentation(doc="Reads will only be put in barcode bins if they have\na strong match for the barcode on both their start\nand end (default: a read can be binned with a match\nat its start or end)")), ToolInput(tag="in_untrimmed", input_type=Boolean(optional=True), prefix="--untrimmed", doc=InputDocumentation(doc="Bin reads but do not trim them (default: trim the\nreads)")), ToolInput(tag="in_discard_unassigned", input_type=Boolean(optional=True), prefix="--discard_unassigned", doc=InputDocumentation(doc="Discard unassigned reads (instead of creating a\n'none' bin) (default: False)")), ToolInput(tag="in_adapter_threshold", input_type=Float(optional=True), prefix="--adapter_threshold", doc=InputDocumentation(doc="An adapter set has to have at least this percent\nidentity to be labelled as present and trimmed off\n(0 to 100) (default: 90.0)")), ToolInput(tag="in_check_reads", input_type=Int(optional=True), prefix="--check_reads", doc=InputDocumentation(doc="This many reads will be aligned to all possible\nadapters to determine which adapter sets are present\n(default: 10000)")), ToolInput(tag="in_scoring_scheme", input_type=String(optional=True), prefix="--scoring_scheme", doc=InputDocumentation(doc="Comma-delimited string of alignment scores: match,\nmismatch, gap open, gap extend (default: 3,-6,-5,-2)")), ToolInput(tag="in_end_size", input_type=Int(optional=True), prefix="--end_size", doc=InputDocumentation(doc="The number of base pairs at each end of the read\nwhich will be searched for adapter sequences\n(default: 150)")), ToolInput(tag="in_min_trim_size", input_type=Int(optional=True), prefix="--min_trim_size", doc=InputDocumentation(doc="Adapter alignments smaller than this will be ignored\n(default: 4)")), ToolInput(tag="in_extra_end_trim", input_type=Int(optional=True), prefix="--extra_end_trim", doc=InputDocumentation(doc="This many additional bases will be removed next to\nadapters found at the ends of reads (default: 2)")), ToolInput(tag="in_end_threshold", input_type=Float(optional=True), prefix="--end_threshold", doc=InputDocumentation(doc="Adapters at the ends of reads must have at least\nthis percent identity to be removed (0 to 100)\n(default: 75.0)")), ToolInput(tag="in_no_split", input_type=Boolean(optional=True), prefix="--no_split", doc=InputDocumentation(doc="Skip splitting reads based on middle adapters\n(default: split reads when an adapter is found in\nthe middle)")), ToolInput(tag="in_discard_middle", input_type=Boolean(optional=True), prefix="--discard_middle", doc=InputDocumentation(doc="Reads with middle adapters will be discarded\n(default: reads with middle adapters are split)\n(required for reads to be used with Nanopolish, this\noption is on by default when outputting reads into\nbarcode bins)")), ToolInput(tag="in_middle_threshold", input_type=Float(optional=True), prefix="--middle_threshold", doc=InputDocumentation(doc="Adapters in the middle of reads must have at least\nthis percent identity to be found (0 to 100)\n(default: 90.0)")), ToolInput(tag="in_extra_middle_trim_good_side", input_type=Int(optional=True), prefix="--extra_middle_trim_good_side", doc=InputDocumentation(doc="This many additional bases will be removed next to\nmiddle adapters on their 'good' side (default: 10)")), ToolInput(tag="in_extra_middle_trim_bad_side", input_type=Int(optional=True), prefix="--extra_middle_trim_bad_side", doc=InputDocumentation(doc="This many additional bases will be removed next to\nmiddle adapters on their 'bad' side (default: 100)")), ToolInput(tag="in_min_split_read_size", input_type=Int(optional=True), prefix="--min_split_read_size", doc=InputDocumentation(doc="Post-split read pieces smaller than this many base\npairs will not be outputted (default: 1000)"))], outputs=[ToolOutput(tag="out_verbosity", output_type=File(optional=True), selector=InputSelector(input_to_select="in_verbosity", type_hint=File()), doc=OutputDocumentation(doc="Level of progress information: 0 = none, 1 = some, 2\n= lots, 3 = full - output will go to stdout if reads\nare saved to a file and stderr if reads are printed\nto stdout (default: 1)")), ToolOutput(tag="out_barcode_dir", output_type=Directory(optional=True), selector=InputSelector(input_to_select="in_barcode_dir", type_hint=File()), doc=OutputDocumentation(doc="Reads will be binned based on their barcode and\nsaved to separate files in this directory\n(incompatible with --output)"))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Porechop_V0_1_0().translate("wdl", allow_empty_container=True)

