from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import String, File, Boolean, Int, Float

Macmd_V0_1_0 = CommandToolBuilder(tool="maCMD", base_command=["maCMD"], inputs=[ToolInput(tag="in_presetting", input_type=String(optional=True), prefix="--Presetting", doc=InputDocumentation(doc="[default]              Optimize aligner parameters for a selected\nsequencing technique. Available presettings are:\n'Default', 'Illumina', 'Illumina_Paired',\n'Nanopore', 'PacBio'.")), ToolInput(tag="in_index", input_type=File(optional=True), prefix="--Index", doc=InputDocumentation(doc="[]                     Filename of FMD-index. (A FMD-index can be\ngenerated via the --Create_Index option.) This\noption must be set.")), ToolInput(tag="in_in", input_type=File(optional=True), prefix="--In", doc=InputDocumentation(doc="[]                        Filenames of Fasta/Fastq files containing reads.\ngz-compressed files are automatically decompressed.\nMultiple files can be specified by a comma\nseparated list. One file name must be provided at\nleast.")), ToolInput(tag="in_mate_in", input_type=File(optional=True), prefix="--Mate_In", doc=InputDocumentation(doc="[]                   Filenames of the mates in the case of paired reads.\nIf this option is set, the aligner switches to\npaired mode automatically. The number of reads\ngiven as mates must match the accumulated number of\nreads provided via the 'in'-option.")), ToolInput(tag="in_create_index", input_type=Boolean(optional=True), prefix="--Create_Index", doc=InputDocumentation(doc="<fasta_file_name,output_folder,index_name> []\nGenerate a FMD-index for a Fasta file.\n'fasta_file_name' has to be the file-path of the\nFasta file holding the genome used for index\ncreation. 'output_folder' is the folder-path of the\nlocation used for index storage. 'index_name' is\nthe name used for identifying the new FMD-Index. In\nthe context of alignments, the genome-name is used\nfor FMD-index selection.")), ToolInput(tag="in_sam_file_name", input_type=File(optional=True), prefix="--SAM_File_name", doc=InputDocumentation(doc="[ma_out.sam]\nName of the SAM file that is used for the output of\nalignments. Use /dev/stdout for printing to stdout.")), ToolInput(tag="in_number_of_threads", input_type=Int(optional=True), prefix="--Number_of_Threads", doc=InputDocumentation(doc="[8]              Number of threads used in the context of")), ToolInput(tag="in_use_paired_reads", input_type=Boolean(optional=True), prefix="--Use_Paired_Reads", doc=InputDocumentation(doc="[false]              For paired reads set this flag to true.")), ToolInput(tag="in_mean_distance_of_paired_reads", input_type=Int(optional=True), prefix="--Mean_Distance_of_Paired_Reads", doc=InputDocumentation(doc="[400]\nTwo reads can be paired, if they are within mean +-\n(standard deviation)*3 distance from one another on\nthe expected strands (depends on Use Mate Pair\non/off) Used in the context of the computation of\nthe mapping quality and for picking optimal\nalignment pairs.")), ToolInput(tag="in_standard_deviation_of_paired_reads", input_type=Int(optional=True), prefix="--Standard_Deviation_of_Paired_Reads", doc=InputDocumentation(doc="[150]\n<val> represents the standard deviation for the\ndistance between paired reads. Used in the context\nof the computation of the mapping quality and for\npicking optimal alignment pairs.")), ToolInput(tag="in_score_factor_for_paired_reads", input_type=Float(optional=True), prefix="--Score_Factor_for_Paired_Reads", doc=InputDocumentation(doc="[1.25]\nThis factor is multiplied to the score of\nsuccessfully paired reads. Used in the context of\nthe computation of the mapping quality and for\npicking optimal alignment pairs. <val> < 1 results\nin penalty; <val> > 1 results in bonus.")), ToolInput(tag="in_check_for_consistency", input_type=Boolean(optional=True), prefix="--Check_for_Consistency", doc=InputDocumentation(doc="[false]         Check if both paired read files comprise the same\nnumber of reads. (Intended for debugging.)")), ToolInput(tag="in_seeding_technique", input_type=String(optional=True), prefix="--Seeding_Technique", doc=InputDocumentation(doc="[maxSpan]       Technique used for the initial seeding. Available\ntechniques are: maxSpan and SMEMs.")), ToolInput(tag="in_minimal_seed_length", input_type=Int(optional=True), prefix="--Minimal_Seed_Length", doc=InputDocumentation(doc="[16]           All seeds with size smaller than 'minimal seed\nlength' are discarded.")), ToolInput(tag="in_minimal_ambiguity", input_type=Int(optional=True), prefix="--Minimal_Ambiguity", doc=InputDocumentation(doc="[0]                  During the extension of seeds using the FMD-index:\nWith increasing extension width, the number of\noccurrences of corresponding seeds on the reference\nmonotonically decreases. Keep extending, while the\nnumber of occurrences is higher than 'Minimal\nAmbiguity'.")), ToolInput(tag="in_maximal_ambiguity", input_type=Int(optional=True), prefix="--Maximal_Ambiguity", doc=InputDocumentation(doc="[100]                Discard seeds that occur more than 'Maximal\nambiguity' time on the reference. Set this option\nto zero in order to disable it.")), ToolInput(tag="in_skip_ambiguous_seeds", input_type=Boolean(optional=True), prefix="--Skip_Ambiguous_Seeds", doc=InputDocumentation(doc="[false]          Enabled: Discard all seeds that are more ambiguous\nthan <Maximal Ambiguity>. Disabled: sample <Maximal\nAmbiguity> random seeds from too ambiguous seeds.")), ToolInput(tag="in_seeding_drop_off_a_minimal_seed_size", input_type=Int(optional=True), prefix="--Seeding_Drop-off_A_-_Minimal_Seed_Size", doc=InputDocumentation(doc="[15]\nHeuristic runtime optimization: For a given read R,\nlet N be the number of seeds of size >= <val>.\nDiscard R, if N < <length(R)> * <Seeding drop-off\nB>.")), ToolInput(tag="in_seeding_drop_off_b_factor", input_type=Float(optional=True), prefix="--Seeding_Drop-off_B_-_Factor", doc=InputDocumentation(doc="[0.005]\nHeuristic runtime optimization: Factor for seed\ndrop-off calculation. For more information see the\nparameter Seeding drop-off A.")), ToolInput(tag="in_maximal_number_of_socs", input_type=Int(optional=True), prefix="--Maximal_Number_of_SoCs", doc=InputDocumentation(doc="[30]        Consider the <val> best scored SoCs merely. 0 =\nConsider all SoCs.")), ToolInput(tag="in_minimal_number_of_socs", input_type=Int(optional=True), prefix="--Minimal_Number_of_SoCs", doc=InputDocumentation(doc="[1]         Always consider the first <val> SoCs no matter the\nHeuristic optimizations. Increasing this parameter\nmight improve the quality of supplementary\nalignments.")), ToolInput(tag="in_fixed_soc_width", input_type=Int(optional=True), prefix="--Fixed_SoC_Width", doc=InputDocumentation(doc="[0]                    Set the SoC width to a fixed value. 0 = use the\nformula given in the paper. (for debugging\npurposes.)")), ToolInput(tag="in_maximal_number_of_reported_alignments", input_type=Int(optional=True), prefix="--Maximal_Number_of_Reported_Alignments", doc=InputDocumentation(doc="[0]\nDo not output more than <val> alignments. Set to\nzero for unlimited output.")), ToolInput(tag="in_minimal_alignment_score", input_type=Int(optional=True), prefix="--Minimal_Alignment_Score", doc=InputDocumentation(doc="[75]           Suppress the output of alignments with a score\nbelow <val>.")), ToolInput(tag="in_omit_secondary_alignments", input_type=Boolean(optional=True), prefix="--Omit_Secondary_Alignments", doc=InputDocumentation(doc="[false]     Suppress the output of secondary alignments.")), ToolInput(tag="in_omit_supplementary_alignments", input_type=Boolean(optional=True), prefix="--Omit_Supplementary_Alignments", doc=InputDocumentation(doc="[false]\nSuppress the output of supplementary alignments.")), ToolInput(tag="in_maximal_supplementary_overlap", input_type=Float(optional=True), prefix="--Maximal_Supplementary_Overlap", doc=InputDocumentation(doc="[0.1]\nA non-primary alignment A is considered\nsupplementary, if less than <val> percent of A\noverlap with the primary alignment on the query.\nOtherwise A is considered secondary.")), ToolInput(tag="in_number_supplementary_alignments", input_type=Int(optional=True), prefix="--Number_Supplementary_Alignments", doc=InputDocumentation(doc="[1]\nMaximal Number of supplementary alignments per\nprimary alignment.")), ToolInput(tag="in_emulate_ng_mlr", input_type=Boolean(optional=True), prefix="--Emulate_NGMLR", doc=InputDocumentation(doc="'s_tag_output <bool> [false]\nOutput SAM tags as NGMLR would. Enable this flag if\nyou want to use MA in combination with Sniffles.\nEnabling this flag will drastically increase the\nsize of the SAM output file.")), ToolInput(tag="in_use_m_in_cigar", input_type=Boolean(optional=True), prefix="--Use_M_in_CIGAR", doc=InputDocumentation(doc="[true]                 Disabled: Distinguish matches and mismatches in\nCIGARs using '=' and 'X' operations. Enabled: Use\nthe 'M' operation in CIGARs.")), ToolInput(tag="in_output_long_cigars_in_cg_tag", input_type=Boolean(optional=True), prefix="--Output_long_cigars_in_CG_tag", doc=InputDocumentation(doc="[true]\nSome programs crash, if cigars become too long. If\nthis flag is enabled, the CG:B:I tag is used for\nthe output of long cigars (cigars with more than\n65536 operations).")), ToolInput(tag="in_soft_clip", input_type=Boolean(optional=True), prefix="--Soft_clip", doc=InputDocumentation(doc="[false]                     Output the full query for each alignment, instead\nof omitting the sequence before and after the\nalignment.")), ToolInput(tag="in_soc_score_drop_off", input_type=Float(optional=True), prefix="--SoC_Score_Drop-off", doc=InputDocumentation(doc="[0.1]            Let x be the maximal encountered SoC score. Stop\nharmonizing SoCs if there is a SoC with a score\nsmaller than <val>*x.")), ToolInput(tag="in_minimal_harmonization_score", input_type=Int(optional=True), prefix="--Minimal_Harmonization_Score", doc=InputDocumentation(doc="[18]       Discard all harmonized SoCs with scores smaller\nthan <val>. Only keep detected inversions with a\nscore >= <val> * <Match Score>.")), ToolInput(tag="in_relative_minimal_harmonization_score", input_type=Int(optional=True), prefix="--Relative_Minimal_Harmonization_Score", doc=InputDocumentation(doc="[0.002]\nDiscard all harmonized SoCs with scores smaller\nthan length(read)*<val>.")), ToolInput(tag="in_harmonization_drop_off_a_score_difference", input_type=Float(optional=True), prefix="--Harmonization_Drop-off_A_-_Score_Difference", doc=InputDocumentation(doc="[0.0001]\nLet x be the maximal encountered harmonization\nscore. Stop harmonizing further SoCs, if\n<Harmonization Drop-off B> many SoCs with scores\nbelow x - <readlength> * <val> occur consecutively.")), ToolInput(tag="in_harmonization_drop_off_b_look_ahead", input_type=Int(optional=True), prefix="--Harmonization_Drop-off_B_-_Lookahead", doc=InputDocumentation(doc="[3]\nSee Harmonization Drop-off A.")), ToolInput(tag="in_harmonization_score_drop_off_minimal_query_length", input_type=Int(optional=True), prefix="--Harmonization_Score_Drop-off_-_Minimal_Query_Length", doc=InputDocumentation(doc="[800]\nFor reads of length >= <val>: Ignore all SoCs with\nharmonization scores smaller than the current\nmaximal score. 0 = disabled.")), ToolInput(tag="in_artifact_filter_a_maximal_delta_distance", input_type=Float(optional=True), prefix="--Artifact_Filter_A_-_Maximal_Delta_Distance", doc=InputDocumentation(doc="[0.1]\nFilter a seed, if the difference between the delta\ndistance to its predecessor and successor is less\nthen <val> percent (set to 1 to disable filter) and\nthe delta distance to its pre- and successor is\nmore than <Artifact Filter B> nt.")), ToolInput(tag="in_artifact_filter_b_minimal_delta_distance", input_type=Int(optional=True), prefix="--Artifact_Filter_B_-_Minimal_Delta_Distance", doc=InputDocumentation(doc="[16]\nSee Artifact Filter A")), ToolInput(tag="in_pick_local_seed_set_a_enabled", input_type=Boolean(optional=True), prefix="--Pick_Local_Seed_Set_A_-_Enabled", doc=InputDocumentation(doc="[false]\nEnable this flag for local seed set computation.\n(See Pick_Local_Seed_Set_B)")), ToolInput(tag="in_pick_local_seed_set_b_optimistic_gap_estimation", input_type=Boolean(optional=True), prefix="--Pick_Local_Seed_Set_B_-_Optimistic_Gap_Estimation", doc=InputDocumentation(doc="[true]\nAfter the harmonization MA checks weather it is\npossible to compute a positively scored alignment\nfrom the seed set. Gaps between seeds can be\nestimated in two ways: Optimistic [true]: Assume\nthat the gap can be filled using merely matches and\na single insertion/deletion. Pessimistic [false]:\nAssume that the gap can be filled using matches and\nmismatches that add up to a score of 0 and a single\ninsertion/deletion.")), ToolInput(tag="in_pick_local_seed_set_c_maximal_gap_penalty", input_type=Int(optional=True), prefix="--Pick_Local_Seed_Set_C_-_Maximal_Gap_Penalty", doc=InputDocumentation(doc="[100]\nMaximal gap cost penalty during local seed set\ncomputation.")), ToolInput(tag="in_maximal_gap_size", input_type=Int(optional=True), prefix="--Maximal_Gap_Size", doc=InputDocumentation(doc="[20]                  If the gap between seeds is larger than <val> on\nquery or reference, a dual extension process is\nused for filling the gap. Dual extension is more\nexpensive, if the extension does not Z-drop, but\nmore efficient otherwise.")), ToolInput(tag="in_minimum_genome_size_for_heuristics", input_type=Int(optional=True), prefix="--Minimum_Genome_Size_for_Heuristics", doc=InputDocumentation(doc="[10000000]\nSome heuristics can only be applied on genomes of\nsufficient size. The parameter disables the SoC\nscore Drop-off, if the genome is shorter than\n<val>.")), ToolInput(tag="in_disable_all_heuristics", input_type=Boolean(optional=True), prefix="--Disable_All_Heuristics", doc=InputDocumentation(doc="[false]        Disables all runtime heuristics. (For debugging\npurposes)")), ToolInput(tag="in_match_score", input_type=Int(optional=True), prefix="--Match_Score", doc=InputDocumentation(doc="[2]                        Match score. (Used in the context of Dynamic\nProgramming and for SoC width computation.)")), ToolInput(tag="in_mismatch_penalty", input_type=Int(optional=True), prefix="--Mismatch_Penalty", doc=InputDocumentation(doc="[4]                   Penalty for mismatch.")), ToolInput(tag="in_gap_penalty", input_type=Int(optional=True), prefix="--Gap_penalty", doc=InputDocumentation(doc="[4]                        First penalty for gap opening. (Two piece affine\ngap costs)")), ToolInput(tag="in_extend_penalty", input_type=Int(optional=True), prefix="--Extend_Penalty", doc=InputDocumentation(doc="[2]                     First penalty for gap extension. (Two piece affine\ngap costs)")), ToolInput(tag="in_second_gap_penalty", input_type=Int(optional=True), prefix="--Second_Gap_Penalty", doc=InputDocumentation(doc="[24]                Second penalty for gap opening. (Two piece affine\ngap costs)")), ToolInput(tag="in_second_extend_penalty", input_type=Int(optional=True), prefix="--Second_Extend_Penalty", doc=InputDocumentation(doc="[1]              Second penalty for gap extension. (Two piece affine\ngap costs)")), ToolInput(tag="in_padding", input_type=Int(optional=True), prefix="--Padding", doc=InputDocumentation(doc="[1000]                         If an alignment does not reach its read's\nendpoints, the missing parts can be computed via\ndynamic programming. If the length of the missing\nparts is smaller than 'Padding', dynamic\nprogramming is used to extend the alignment towards\nthe endpoints of the read. Otherwise, the unaligned\nparts of the read are ignored and the alignment\nstays unextended.")), ToolInput(tag="in_bandwidth_for_extensions", input_type=Int(optional=True), prefix="--Bandwidth_for_Extensions", doc=InputDocumentation(doc="[512]         Bandwidth used in the context of the extension of\nan alignment towards the endpoints of its read.\n(See 'Padding')")), ToolInput(tag="in_minimal_bandwidth_in_gaps", input_type=Int(optional=True), prefix="--Minimal_Bandwidth_in_Gaps", doc=InputDocumentation(doc="[20]         Gaps between seeds are generally filled using\ndynamic programming. This option determines the\nminimal bandwidth used in the context of fillin\ngaps.")), ToolInput(tag="in_z_drop", input_type=Int(optional=True), prefix="--Z_Drop", doc=InputDocumentation(doc="[200]                           If the running score during dynamic programming\ndrops faster than <val> stop the extension process.")), ToolInput(tag="in_detect_small_inversions", input_type=Boolean(optional=True), prefix="--Detect_Small_Inversions", doc=InputDocumentation(doc="[false]       Use dynamic programming to search for small\ninversions that do not contain any seeds. (Flag\ndisabled = off)")), ToolInput(tag="in_z_drop_inversions", input_type=Int(optional=True), prefix="--Z_Drop_Inversions", doc=InputDocumentation(doc="[100]                Check for an inversion, if the running score during\ndynamic programming drops faster than <val>.")), ToolInput(tag="in_minimizer_size", input_type=Int(optional=True), prefix="--Minimizer_Size", doc=InputDocumentation(doc="[15]                Compute Minimizers with a size of <val>nt. A\nMinimizer index is built for the specific k and w\nchosen during index generation; To change the\nminimizer size or window size, a separate index has\nto be built. 'Seeding Technique' has to be set to\nminimizers in order to use this.")), ToolInput(tag="in_minimizer_window_size", input_type=Int(optional=True), prefix="--Minimizer_Window_Size", doc=InputDocumentation(doc="[10]         Compute Minimizers using a window of <val>nt. Two\nconsecutive minimizers can be at most w-k nt apart.\nSee 'Minimizer Size' for further information.")), ToolInput(tag="in_alignments_dot", input_type=String(), position=0, doc=InputDocumentation(doc="-h, --Help <bool> [true]                       Print the complete help text. "))], outputs=[ToolOutput(tag="out_sam_file_name", output_type=File(optional=True), selector=InputSelector(input_to_select="in_sam_file_name", type_hint=File()), doc=OutputDocumentation(doc="[ma_out.sam]\nName of the SAM file that is used for the output of\nalignments. Use /dev/stdout for printing to stdout."))], container="quay.io/biocontainers/ma:1.1.4--py37h8270d21_1", version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Macmd_V0_1_0().translate("wdl")

