!Command
positional:
- !Positional
  description: One or more target datasets (e.g., one per species). Each dataset can
    be specified in one of multiple ways. (a) If dataset is in the format 'download:TAXID',
    then CATCH downloads from NCBI all whole genomes for the NCBI taxonomy with id
    TAXID, and uses these sequences as input. (b) If dataset is a path to a FASTA
    file, then its sequences are read and used as input. (c) Otherwise, it is assumed
    that this is a label for a dataset included in this package (e.g., 'zika'). If
    the label starts with 'colleciton:' (e.g., 'collection:viruses_with_human_host'),
    then this reads from an available collection of datasets.
  position: 0
  name: dataset
  optional: false
named:
- !Flag
  description: Add to the output the reverse complement of each probe
  synonyms:
  - --add-reverse-complements
  args: !EmptyFlagArg {}
  optional: true
- !Flag
  description: "[EXPAND_N] Expand each probe so that 'N' bases are replaced by real\
    \ bases; for example, the probe 'ANA' would be replaced with the probes 'AAA',\
    \ 'ATA', 'ACA', and 'AGA'; this is done combinatorially across all 'N' bases in\
    \ a probe, and thus the number of new probes grows exponentially with the number\
    \ of 'N' bases in a probe. If followed by a command- line argument (INT), this\
    \ only expands at most INT randomly selected N bases, and the rest are replaced\
    \ with random unambiguous bases (default INT is 3)."
  synonyms:
  - --expand-n
  args: !EmptyFlagArg {}
  optional: true
- !Flag
  description: (Optional) Use only the first LIMIT_TARGET_GENOMES target genomes in
    the dataset
  synonyms:
  - --limit-target-genomes
  args: !SimpleFlagArg
    name: LIMIT_TARGET_GENOMES
  optional: true
- !Flag
  description: (Optional) Randomly select LIMIT_TARGET_GENOMES_RANDOMLY_WITH_REPLACMENT
    target genomes in the dataset with replacement
  synonyms:
  - --limit-target-genomes-randomly-with-replacement
  args: !SimpleFlagArg
    name: LIMIT_TARGET_GENOMES_RANDOMLY_WITH_REPLACEMENT
  optional: true
- !Flag
  description: (Optional) If set, cluster all input sequences using their MinHash
    signatures, design probes separately on each cluster, and combine the resulting
    probes. This can significantly lower runtime and memory usage, but may lead to
    a suboptimal solution. The value CLUSTER_AND_DESIGN_SEPARATELY gives the inter-cluster
    distance threshold to merge clusters (1-ANI, where ANI is average nucleotide identity);
    higher values result in fewer clusters, and thus longer runtime. Values must be
    in (0,0.5], and generally should be around 0.1 or 0.2. When used, this creates
    a separate genome for each input sequence -- it collapses all sequences, across
    both groups and genomes, into one list of sequences in one group. Therefore, genomes
    will not be grouped as specified in the input and sequences will not be grouped
    by genome, and differential identification is not supported
  synonyms:
  - --cluster-and-design-separately
  args: !SimpleFlagArg
    name: CLUSTER_AND_DESIGN_SEPARATELY
  optional: true
- !Flag
  description: (Optional) If set, break all sequences into sequences of length CLUSTER_FROM_FRAGMENTS
    nt, and cluster these fragments. This can be useful for improving runtime on input
    with especially large genomes, in which probes for different fragments can be
    designed separately. Values should generally be around 10,000. For this to be
    used, --cluster-and-design-separately must also be set.
  synonyms:
  - --cluster-from-fragments
  args: !SimpleFlagArg
    name: CLUSTER_FROM_FRAGMENTS
  optional: true
- !Flag
  description: (Optional) If set, filter candidate probes for near- duplicates using
    LSH with a family of hash functions that works with Hamming distance. FILTER_WITH_LSH_HAMMING
    gives the maximum Hamming distance at which to call near-duplicates; it should
    be commensurate with (but not greater than) MISMATCHES. Using this may significantly
    improve runtime and reduce memory usage by reducing the number of candidate probes
    to consider, but may lead to a slightly sub-optimal solution. It may also, particularly
    with relatively high values of FILTER_WITH_LSH_HAMMING, cause coverage obtained
    for each genome to be slightly less than the desired coverage (COVERAGE) when
    that desired coverage is the complete genome; it is recommended to also use --print-analysis
    or --write-analysis-to-tsv with this to see the coverage that is obtained.
  synonyms:
  - --filter-with-lsh-hamming
  args: !SimpleFlagArg
    name: FILTER_WITH_LSH_HAMMING
  optional: true
- !Flag
  description: (Optional) If set, filter candidate probes for near- duplicates using
    LSH with a MinHash family. FILTER_WITH_LSH_MINHASH gives the maximum Jaccard distance
    (1 minus Jaccard similarity) at which to call near-duplicates; the Jaccard similarity
    is calculated by treating each probe as a set of overlapping 10-mers. Its value
    should be commensurate with parameter values determining whether a probe hybridizes
    to a target sequence, but this can be difficult to measure compared to the input
    for --filter-with-lsh-hamming. However, this allows more sensitivity in near-duplicate
    detection than --filter- with-lsh-hamming (e.g., if near-duplicates should involve
    probes shifted relative to each other). The same caveats mentioned in help for
    --filter-with-lsh- hamming also apply here. Values of FILTER_WITH_LSH_MINHASH
    above ~0.7 may start to require significant memory and runtime for near- duplicate
    detection.
  synonyms:
  - --filter-with-lsh-minhash
  args: !SimpleFlagArg
    name: FILTER_WITH_LSH_MINHASH
  optional: true
- !Flag
  description: Run a separate instance of set cover with the target genomes from each
    grouping and pool (union) the resulting probes. When set, the software will run
    faster than when not set, but it may yield more probes than when it is not set.
  synonyms:
  - --cover-groupings-separately
  args: !EmptyFlagArg {}
  optional: true
- !Flag
  description: (Optional) Do not create candidate probes from sequences whose length
    is <= SMALL_SEQ_SKIP. If set to (PROBE_LENGTH - 1), this avoids the error raised
    when sequences are less than the probe length
  synonyms:
  - --small-seq-skip
  args: !SimpleFlagArg
    name: SMALL_SEQ_SKIP
  optional: true
- !Flag
  description: (Optional) If set, allow sequences as input that are shorter than PROBE_LENGTH
    (when not set, the program will error on such input). SMALL_SEQ_MIN is the minimum
    sequence length that should be accepted as input. When a sequence is less than
    PROBE_LENGTH, a candidate probe is created that is equal to the sequence; thus,
    the output probes may have different lengths. Note that, when this is set, it
    might be a good idea to also set LCF_THRES to be a value smaller than PROBE_LENGTH
    -- e.g., the length of the shortest input sequence; otherwise, when a probe of
    length p_l is mapped to a sequence of length s_l, then lcf_thres is treated as
    being min(LCF_THRES, p_l, s_l) so that a probe is able to 'cover' a sequence shorter
    than the probe and so that a probe shorter than lcf_thres is able to 'cover' a
    sequence
  synonyms:
  - --small-seq-min
  args: !SimpleFlagArg
    name: SMALL_SEQ_MIN
  optional: true
- !Flag
  description: (Optional) An int >= 1 that gives the maximum number of processes to
    use in multiprocessing pools; uses min(number of CPUs in the system, MAX_NUM_PROCESSES)
    processes
  synonyms:
  - --max-num-processes
  args: !SimpleFlagArg
    name: MAX_NUM_PROCESSES
  optional: true
- !Flag
  description: (Optional) Use this value (KMER_PROBE_LENGTH_K) as the k-mer length
    when constructing a map of k-mers to the probes that contain these k-mers. This
    map is used when mapping candidate probes to target sequences and the k-mers serve
    as seeds for calculating whether a candidate probe 'covers' a subsequence. The
    value should be sufficiently less than PROBE_LENGTH so that it can find mappings
    even when the candidate probe and target sequence are divergent. In particular,
    CATCH will try to find a value k >= KMER_PROBE_LENGTH_K (by default, >=20) such
    that k divides PROBE_LENGTH and k < PROBE_LENGTH / MISMATCHES (if MISMATCHES=0,
    then k=PROBE_LENGTH). It will then use this k as the k-mer length in mappings;
    if no such k exists, it will use a randomized approach with KMER_PROBE_LENGTH_K
    as the k-mer length. If --custom-hybridization-fn is set, it will always use the
    randomized approach with KMER_PROBE_LENGTH_K (by default, 20) as the k-mer length.
  synonyms:
  - --kmer-probe-map-k
  args: !SimpleFlagArg
    name: KMER_PROBE_MAP_K
  optional: true
- !Flag
  description: When finding probe coverage for blacklisting and identification (i.e.,
    when using tolerant parameters), use a native Python dict as the kmer_probe_map
    across processes, rather than the primitives in SharedKmerProbeMap that are more
    suited to sharing across processes. Depending on the input (particularly if there
    are many candidate probes) this may result in substantial memory usage; but it
    may provide an improvement in runtime when there are relatively few candidate
    probes and a very large blacklisted input
  synonyms:
  - --use-native-dict-when-finding-tolerant-coverage
  args: !EmptyFlagArg {}
  optional: true
- !Flag
  description: Debug output
  synonyms:
  - --debug
  args: !EmptyFlagArg {}
  optional: true
- !Flag
  description: Verbose output
  synonyms:
  - --verbose
  args: !EmptyFlagArg {}
  optional: true
- !Flag
  description: ''
  synonyms:
  - -o
  args: !SimpleFlagArg
    name: OUTPUT_PROBES
  optional: true
- !Flag
  description: ''
  synonyms:
  - -pl
  args: !SimpleFlagArg
    name: PROBE_LENGTH
  optional: true
- !Flag
  description: ''
  synonyms:
  - -ps
  args: !SimpleFlagArg
    name: PROBE_STRIDE
  optional: true
command:
- design.py
parent:
subcommands: []
help_flag: !Flag
  description: ''
  synonyms:
  - -h
  args: !EmptyFlagArg {}
  optional: true
usage_flag:
version_flag: !Flag
  description: show program's version number and exit
  synonyms:
  - -V
  - --version
  args: !EmptyFlagArg {}
  optional: true
help_text: "usage: design.py [-h] -o OUTPUT_PROBES [-pl PROBE_LENGTH] [-ps PROBE_STRIDE]\n\
  \                 [-m MISMATCHES] [-l LCF_THRES]\n                 [--island-of-exact-match\
  \ ISLAND_OF_EXACT_MATCH]\n                 [--custom-hybridization-fn CUSTOM_HYBRIDIZATION_FN\
  \ CUSTOM_HYBRIDIZATION_FN]\n                 [-c COVERAGE] [-e COVER_EXTENSION]\
  \ [-i]\n                 [--blacklist-genomes BLACKLIST_GENOMES [BLACKLIST_GENOMES\
  \ ...]]\n                 [-mt MISMATCHES_TOLERANT] [-lt LCF_THRES_TOLERANT]\n \
  \                [--island-of-exact-match-tolerant ISLAND_OF_EXACT_MATCH_TOLERANT]\n\
  \                 [--custom-hybridization-fn-tolerant CUSTOM_HYBRIDIZATION_FN_TOLERANT\
  \ CUSTOM_HYBRIDIZATION_FN_TOLERANT]\n                 [--print-analysis]\n     \
  \            [--write-analysis-to-tsv WRITE_ANALYSIS_TO_TSV]\n                 [--write-sliding-window-coverage\
  \ WRITE_SLIDING_WINDOW_COVERAGE]\n                 [--filter-from-fasta FILTER_FROM_FASTA]\
  \ [--skip-set-cover]\n                 [--add-adapters] [--adapter-a ADAPTER_A ADAPTER_A]\n\
  \                 [--adapter-b ADAPTER_B ADAPTER_B]\n                 [--filter-polya\
  \ FILTER_POLYA FILTER_POLYA]\n                 [--add-reverse-complements] [--expand-n\
  \ [EXPAND_N]]\n                 [--limit-target-genomes LIMIT_TARGET_GENOMES]\n\
  \                 [--limit-target-genomes-randomly-with-replacement LIMIT_TARGET_GENOMES_RANDOMLY_WITH_REPLACEMENT]\n\
  \                 [--cluster-and-design-separately CLUSTER_AND_DESIGN_SEPARATELY]\n\
  \                 [--cluster-from-fragments CLUSTER_FROM_FRAGMENTS]\n          \
  \       [--filter-with-lsh-hamming FILTER_WITH_LSH_HAMMING]\n                 [--filter-with-lsh-minhash\
  \ FILTER_WITH_LSH_MINHASH]\n                 [--cover-groupings-separately]\n  \
  \               [--small-seq-skip SMALL_SEQ_SKIP]\n                 [--small-seq-min\
  \ SMALL_SEQ_MIN]\n                 [--max-num-processes MAX_NUM_PROCESSES]\n   \
  \              [--kmer-probe-map-k KMER_PROBE_MAP_K]\n                 [--use-native-dict-when-finding-tolerant-coverage]\
  \ [--debug]\n                 [--verbose] [-V]\n                 dataset [dataset\
  \ ...]\n\npositional arguments:\n  dataset               One or more target datasets\
  \ (e.g., one per species).\n                        Each dataset can be specified\
  \ in one of multiple ways.\n                        (a) If dataset is in the format\
  \ 'download:TAXID', then\n                        CATCH downloads from NCBI all\
  \ whole genomes for the\n                        NCBI taxonomy with id TAXID, and\
  \ uses these sequences\n                        as input. (b) If dataset is a path\
  \ to a FASTA file,\n                        then its sequences are read and used\
  \ as input. (c)\n                        Otherwise, it is assumed that this is a\
  \ label for a\n                        dataset included in this package (e.g., 'zika').\
  \ If\n                        the label starts with 'colleciton:' (e.g.,\n     \
  \                   'collection:viruses_with_human_host'), then this reads\n   \
  \                     from an available collection of datasets.\n\noptional arguments:\n\
  \  -h, --help            show this help message and exit\n  -o OUTPUT_PROBES, --output-probes\
  \ OUTPUT_PROBES\n                        The file to which all final probes should\
  \ be written;\n                        they are written in FASTA format\n  -pl PROBE_LENGTH,\
  \ --probe-length PROBE_LENGTH\n                        (Optional) Make probes be\
  \ PROBE_LENGTH nt long\n  -ps PROBE_STRIDE, --probe-stride PROBE_STRIDE\n      \
  \                  (Optional) Generate candidate probes from the input\n       \
  \                 that are separated by PROBE_STRIDE nt\n  -m MISMATCHES, --mismatches\
  \ MISMATCHES\n                        (Optional) Allow for MISMATCHES mismatches\
  \ when\n                        determining whether a probe covers a sequence\n\
  \  -l LCF_THRES, --lcf-thres LCF_THRES\n                        (Optional) Say that\
  \ a portion of a probe covers a\n                        portion of a sequence if\
  \ the two share a substring\n                        with at most MISMATCHES mismatches\
  \ that has length >=\n                        LCF_THRES nt; if unspecified, this\
  \ is set to\n                        PROBE_LENGTH\n  --island-of-exact-match ISLAND_OF_EXACT_MATCH\n\
  \                        (Optional) When determining whether a probe covers a\n\
  \                        sequence, require that there be an exact match (i.e.,\n\
  \                        no mismatches) of length at least\n                   \
  \     ISLAND_OF_EXACT_MATCH nt between a portion of the\n                      \
  \  probe and a portion of the sequence\n  --custom-hybridization-fn CUSTOM_HYBRIDIZATION_FN\
  \ CUSTOM_HYBRIDIZATION_FN\n                        (Optional) Args: <PATH> <FUNC>;\
  \ PATH is a path to a\n                        Python module (.py file) and FUNC\
  \ is a string giving\n                        the name of a function in that module.\
  \ FUNC provides a\n                        custom model of hybridization between\
  \ a probe and\n                        target sequence to use in the probe set design.\
  \ If\n                        this is set, the arguments --mismatches, --lcf-thres,\n\
  \                        and --island-of-exact-match are not used because these\n\
  \                        are meant for the default model of hybridization. The\n\
  \                        function FUNC in PATH is dynamically loaded to use\n  \
  \                      when determining whether a probe hybridizes to a\n      \
  \                  target sequence (and, if so, what portion). FUNC must\n     \
  \                   accept the following arguments in order, though it may\n   \
  \                     choose to ignore some values: (1) array giving\n         \
  \               sequence of a probe; (2) str giving subsequence of\n           \
  \             target sequence to which the probe may hybridize, of\n           \
  \             the same length as the given probe sequence; (3) int\n           \
  \             giving the position in the probe (equivalently, the\n            \
  \            target subsequence) of the start of a k-mer around\n              \
  \          which the probe and target subsequence are anchored\n               \
  \         (the probe and target subsequence are aligned using\n                \
  \        this k-mer as an anchor); (4) int giving the end\n                    \
  \    position (exclusive) of the anchor k-mer; (5) int\n                       \
  \ giving the full length of the probe (the probe\n                        provided\
  \ in (1) may be cutoff on an end if it extends\n                        further\
  \ than where the target sequence ends); (6) int\n                        giving\
  \ the full length of the target sequence of which\n                        the subsequence\
  \ in (2) is part. FUNC must return None\n                        if it deems that\
  \ the probe does not hybridize to the\n                        target subsequence;\
  \ otherwise, it must return a tuple\n                        (start, end) where\
  \ start is an int giving the start\n                        position in the probe\
  \ (equivalently, in the target\n                        subsequence) at which the\
  \ probe will hybridize to the\n                        target subsequence, and end\
  \ is an int (exclusive)\n                        giving the end position of the\
  \ hybridization.\n  -c COVERAGE, --coverage COVERAGE\n                        If\
  \ this is a float in [0,1], it gives the fraction of\n                        each\
  \ target genome that must be covered by the\n                        selected probes;\
  \ if this is an int > 1, it gives the\n                        number of bp of each\
  \ target genome that must be\n                        covered by the selected probes\n\
  \  -e COVER_EXTENSION, --cover-extension COVER_EXTENSION\n                     \
  \   Extend the coverage of each side of a probe by\n                        COVER_EXTENSION\
  \ nt. That is, a probe covers a region\n                        that consists of\
  \ the portion of a sequence it\n                        hybridizes to, as well as\
  \ this number of nt on each\n                        side of that portion. This\
  \ is useful in modeling\n                        hybrid selection, where a probe\
  \ hybridizes toa\n                        fragment that includes the region targeted\
  \ by the\n                        probe, along with surrounding portions of the\n\
  \                        sequence. Increasing its value should reduce the\n    \
  \                    number of probes required to achieve the desired\n        \
  \                coverage.\n  -i, --identify        Design probes meant to make\
  \ it possible to identify\n                        nucleic acid from a particular\
  \ input dataset against\n                        the other datasets; when set, the\
  \ coverage should\n                        generally be small\n  --blacklist-genomes\
  \ BLACKLIST_GENOMES [BLACKLIST_GENOMES ...]\n                        One or more\
  \ blacklisted genomes; penalize probes based\n                        on how much\
  \ of each of these genomes they cover. If\n                        the value is\
  \ a path to a file, then that file is\n                        treated as a FASTA\
  \ file and its sequences are read.\n                        Otherwise, it is assumed\
  \ that this is a label for a\n                        dataset included in this package\
  \ (e.g., 'zika').\n  -mt MISMATCHES_TOLERANT, --mismatches-tolerant MISMATCHES_TOLERANT\n\
  \                        (Optional) A more tolerant value for 'mismatches';\n  \
  \                      this should be greater than the value of MISMATCHES.\n  \
  \                      Allows for capturing more possible hybridizations\n     \
  \                   (i.e., more sensitivity) when designing probes for\n       \
  \                 identification or when genomes are blacklisted.\n  -lt LCF_THRES_TOLERANT,\
  \ --lcf-thres-tolerant LCF_THRES_TOLERANT\n                        (Optional) A\
  \ more tolerant value for 'lcf_thres'; this\n                        should be less\
  \ than LCF_THRES. Allows for capturing\n                        more possible hybridizations\
  \ (i.e., more sensitivity)\n                        when designing probes for identification\
  \ or when\n                        genomes are blacklisted.\n  --island-of-exact-match-tolerant\
  \ ISLAND_OF_EXACT_MATCH_TOLERANT\n                        (Optional) A more tolerant\
  \ value for\n                        'island_of_exact_match'; this should be less\
  \ than\n                        ISLAND_OF_ EXACT_MATCH. Allows for capturing more\n\
  \                        possible hybridizations (i.e., more sensitivity) when\n\
  \                        designing probes for identification or when genomes\n \
  \                       are blacklisted.\n  --custom-hybridization-fn-tolerant CUSTOM_HYBRIDIZATION_FN_TOLERANT\
  \ CUSTOM_HYBRIDIZATION_FN_TOLERANT\n                        (Optional) A more tolerant\
  \ model than the one\n                        implemented in custom_hybridization_fn.\
  \ This should\n                        capture more possible hybridizations (i.e.,\
  \ be more\n                        sensitive) when designing probes for identification\
  \ or\n                        when genomes are blacklisted. See --custom-\n    \
  \                    hybridization-fn for details of how this function\n       \
  \                 should be implemented and provided.\n  --print-analysis      Print\
  \ analysis of the probe set's coverage\n  --write-analysis-to-tsv WRITE_ANALYSIS_TO_TSV\n\
  \                        (Optional) The file to which to write a TSV-formatted\n\
  \                        matrix of the probe set's coverage analysis\n  --write-sliding-window-coverage\
  \ WRITE_SLIDING_WINDOW_COVERAGE\n                        (Optional) The file to\
  \ which to write the average\n                        coverage achieved by the probe\
  \ set within sliding\n                        windows of each target genome\n  --filter-from-fasta\
  \ FILTER_FROM_FASTA\n                        (Optional) A FASTA file from which\
  \ to select candidate\n                        probes. Before running any other\
  \ filters, keep only\n                        the candidate probes that are equal\
  \ to sequences in\n                        the file and remove all probes not equal\
  \ to any of\n                        these sequences. This, by default, ignores\
  \ sequences\n                        in the file whose header contains the string\
  \ 'reverse\n                        complement'; that is, if there is some probe\
  \ with\n                        sequence S, it may be filtered out (even if there\
  \ is a\n                        sequence S in the file) if the header of S in the\
  \ file\n                        contains 'reverse complement'. This is useful if\
  \ we\n                        already have probes decided by the set cover filter,\n\
  \                        but simply want to process them further by, e.g.,\n   \
  \                     adding adapters or running a coverage analysis. For\n    \
  \                    example, if we have already run the time-consuming set\n  \
  \                      cover filter and have a FASTA containing those probes,\n\
  \                        we can provide a path to that FASTA file for this\n   \
  \                     argument, and also provide the --skip-set-cover\n        \
  \                argument, in order to add adapters to those probes\n          \
  \              without having to re-run the set cover filter.\n  --skip-set-cover\
  \      Skip the set cover filter; this is useful when we wish\n                \
  \        to see the probes generated from only the duplicate\n                 \
  \       and reverse complement filters, to gauge the effects\n                 \
  \       of the set cover filter\n  --add-adapters        Add adapters to the ends\
  \ of probes; to specify adapter\n                        sequences, use --adapter-a\
  \ and --adapter-b\n  --adapter-a ADAPTER_A ADAPTER_A\n                        (Optional)\
  \ Args: <X> <Y>; Custom A adapter to use; two\n                        ordered where\
  \ X is the A adapter sequence to place on\n                        the 5' end of\
  \ a probe and Y is the A adapter sequence\n                        to place on the\
  \ 3' end of a probe\n  --adapter-b ADAPTER_B ADAPTER_B\n                       \
  \ (Optional) Args: <X> <Y>; Custom B adapter to use; two\n                     \
  \   ordered where X is the B adapter sequence to place on\n                    \
  \    the 5' end of a probe and Y is the B adapter sequence\n                   \
  \     to place on the 3' end of a probe\n  --filter-polya FILTER_POLYA FILTER_POLYA\n\
  \                        (Optional) Args: <X> <Y> (integers); do not output any\n\
  \                        probe that contains a stretch of X or more 'A' bases,\n\
  \                        tolerating up to Y mismatches (and likewise for 'T'\n \
  \                       bases)\n  --add-reverse-complements\n                  \
  \      Add to the output the reverse complement of each probe\n  --expand-n [EXPAND_N]\n\
  \                        Expand each probe so that 'N' bases are replaced by\n \
  \                       real bases; for example, the probe 'ANA' would be\n    \
  \                    replaced with the probes 'AAA', 'ATA', 'ACA', and\n       \
  \                 'AGA'; this is done combinatorially across all 'N'\n         \
  \               bases in a probe, and thus the number of new probes\n          \
  \              grows exponentially with the number of 'N' bases in a\n         \
  \               probe. If followed by a command- line argument (INT),\n        \
  \                this only expands at most INT randomly selected N\n           \
  \             bases, and the rest are replaced with random\n                   \
  \     unambiguous bases (default INT is 3).\n  --limit-target-genomes LIMIT_TARGET_GENOMES\n\
  \                        (Optional) Use only the first LIMIT_TARGET_GENOMES\n  \
  \                      target genomes in the dataset\n  --limit-target-genomes-randomly-with-replacement\
  \ LIMIT_TARGET_GENOMES_RANDOMLY_WITH_REPLACEMENT\n                        (Optional)\
  \ Randomly select\n                        LIMIT_TARGET_GENOMES_RANDOMLY_WITH_REPLACMENT\
  \ target\n                        genomes in the dataset with replacement\n  --cluster-and-design-separately\
  \ CLUSTER_AND_DESIGN_SEPARATELY\n                        (Optional) If set, cluster\
  \ all input sequences using\n                        their MinHash signatures, design\
  \ probes separately on\n                        each cluster, and combine the resulting\
  \ probes. This\n                        can significantly lower runtime and memory\
  \ usage, but\n                        may lead to a suboptimal solution. The value\n\
  \                        CLUSTER_AND_DESIGN_SEPARATELY gives the inter-cluster\n\
  \                        distance threshold to merge clusters (1-ANI, where ANI\n\
  \                        is average nucleotide identity); higher values result\n\
  \                        in fewer clusters, and thus longer runtime. Values\n  \
  \                      must be in (0,0.5], and generally should be around 0.1\n\
  \                        or 0.2. When used, this creates a separate genome for\n\
  \                        each input sequence -- it collapses all sequences,\n  \
  \                      across both groups and genomes, into one list of\n      \
  \                  sequences in one group. Therefore, genomes will not be\n    \
  \                    grouped as specified in the input and sequences will\n    \
  \                    not be grouped by genome, and differential\n              \
  \          identification is not supported\n  --cluster-from-fragments CLUSTER_FROM_FRAGMENTS\n\
  \                        (Optional) If set, break all sequences into sequences\n\
  \                        of length CLUSTER_FROM_FRAGMENTS nt, and cluster these\n\
  \                        fragments. This can be useful for improving runtime on\n\
  \                        input with especially large genomes, in which probes\n\
  \                        for different fragments can be designed separately.\n \
  \                       Values should generally be around 10,000. For this to\n\
  \                        be used, --cluster-and-design-separately must also be\n\
  \                        set.\n  --filter-with-lsh-hamming FILTER_WITH_LSH_HAMMING\n\
  \                        (Optional) If set, filter candidate probes for near-\n\
  \                        duplicates using LSH with a family of hash functions\n\
  \                        that works with Hamming distance.\n                   \
  \     FILTER_WITH_LSH_HAMMING gives the maximum Hamming\n                      \
  \  distance at which to call near-duplicates; it should\n                      \
  \  be commensurate with (but not greater than)\n                        MISMATCHES.\
  \ Using this may significantly improve\n                        runtime and reduce\
  \ memory usage by reducing the number\n                        of candidate probes\
  \ to consider, but may lead to a\n                        slightly sub-optimal solution.\
  \ It may also,\n                        particularly with relatively high values\
  \ of\n                        FILTER_WITH_LSH_HAMMING, cause coverage obtained for\n\
  \                        each genome to be slightly less than the desired\n    \
  \                    coverage (COVERAGE) when that desired coverage is the\n   \
  \                     complete genome; it is recommended to also use\n         \
  \               --print-analysis or --write-analysis-to-tsv with this\n        \
  \                to see the coverage that is obtained.\n  --filter-with-lsh-minhash\
  \ FILTER_WITH_LSH_MINHASH\n                        (Optional) If set, filter candidate\
  \ probes for near-\n                        duplicates using LSH with a MinHash\
  \ family.\n                        FILTER_WITH_LSH_MINHASH gives the maximum Jaccard\n\
  \                        distance (1 minus Jaccard similarity) at which to call\n\
  \                        near-duplicates; the Jaccard similarity is calculated\n\
  \                        by treating each probe as a set of overlapping\n      \
  \                  10-mers. Its value should be commensurate with\n            \
  \            parameter values determining whether a probe\n                    \
  \    hybridizes to a target sequence, but this can be\n                        difficult\
  \ to measure compared to the input for\n                        --filter-with-lsh-hamming.\
  \ However, this allows more\n                        sensitivity in near-duplicate\
  \ detection than --filter-\n                        with-lsh-hamming (e.g., if near-duplicates\
  \ should\n                        involve probes shifted relative to each other).\
  \ The\n                        same caveats mentioned in help for --filter-with-lsh-\n\
  \                        hamming also apply here. Values of\n                  \
  \      FILTER_WITH_LSH_MINHASH above ~0.7 may start to\n                       \
  \ require significant memory and runtime for near-\n                        duplicate\
  \ detection.\n  --cover-groupings-separately\n                        Run a separate\
  \ instance of set cover with the target\n                        genomes from each\
  \ grouping and pool (union) the\n                        resulting probes. When\
  \ set, the software will run\n                        faster than when not set,\
  \ but it may yield more probes\n                        than when it is not set.\n\
  \  --small-seq-skip SMALL_SEQ_SKIP\n                        (Optional) Do not create\
  \ candidate probes from\n                        sequences whose length is <= SMALL_SEQ_SKIP.\
  \ If set to\n                        (PROBE_LENGTH - 1), this avoids the error raised\
  \ when\n                        sequences are less than the probe length\n  --small-seq-min\
  \ SMALL_SEQ_MIN\n                        (Optional) If set, allow sequences as input\
  \ that are\n                        shorter than PROBE_LENGTH (when not set, the\
  \ program\n                        will error on such input). SMALL_SEQ_MIN is the\n\
  \                        minimum sequence length that should be accepted as\n  \
  \                      input. When a sequence is less than PROBE_LENGTH, a\n   \
  \                     candidate probe is created that is equal to the\n        \
  \                sequence; thus, the output probes may have different\n        \
  \                lengths. Note that, when this is set, it might be a\n         \
  \               good idea to also set LCF_THRES to be a value smaller\n        \
  \                than PROBE_LENGTH -- e.g., the length of the shortest\n       \
  \                 input sequence; otherwise, when a probe of length p_l\n      \
  \                  is mapped to a sequence of length s_l, then lcf_thres\n     \
  \                   is treated as being min(LCF_THRES, p_l, s_l) so that a\n   \
  \                     probe is able to 'cover' a sequence shorter than the\n   \
  \                     probe and so that a probe shorter than lcf_thres is\n    \
  \                    able to 'cover' a sequence\n  --max-num-processes MAX_NUM_PROCESSES\n\
  \                        (Optional) An int >= 1 that gives the maximum number\n\
  \                        of processes to use in multiprocessing pools; uses\n  \
  \                      min(number of CPUs in the system, MAX_NUM_PROCESSES)\n  \
  \                      processes\n  --kmer-probe-map-k KMER_PROBE_MAP_K\n      \
  \                  (Optional) Use this value (KMER_PROBE_LENGTH_K) as the\n    \
  \                    k-mer length when constructing a map of k-mers to the\n   \
  \                     probes that contain these k-mers. This map is used\n     \
  \                   when mapping candidate probes to target sequences and\n    \
  \                    the k-mers serve as seeds for calculating whether a\n     \
  \                   candidate probe 'covers' a subsequence. The value\n        \
  \                should be sufficiently less than PROBE_LENGTH so that\n       \
  \                 it can find mappings even when the candidate probe and\n     \
  \                   target sequence are divergent. In particular, CATCH\n      \
  \                  will try to find a value k >= KMER_PROBE_LENGTH_K (by\n     \
  \                   default, >=20) such that k divides PROBE_LENGTH and k\n    \
  \                    < PROBE_LENGTH / MISMATCHES (if MISMATCHES=0, then\n      \
  \                  k=PROBE_LENGTH). It will then use this k as the k-mer\n     \
  \                   length in mappings; if no such k exists, it will use a\n   \
  \                     randomized approach with KMER_PROBE_LENGTH_K as the\n    \
  \                    k-mer length. If --custom-hybridization-fn is set, it\n   \
  \                     will always use the randomized approach with\n           \
  \             KMER_PROBE_LENGTH_K (by default, 20) as the k-mer\n              \
  \          length.\n  --use-native-dict-when-finding-tolerant-coverage\n       \
  \                 When finding probe coverage for blacklisting and\n           \
  \             identification (i.e., when using tolerant parameters),\n         \
  \               use a native Python dict as the kmer_probe_map across\n        \
  \                processes, rather than the primitives in\n                    \
  \    SharedKmerProbeMap that are more suited to sharing\n                      \
  \  across processes. Depending on the input (particularly\n                    \
  \    if there are many candidate probes) this may result in\n                  \
  \      substantial memory usage; but it may provide an\n                       \
  \ improvement in runtime when there are relatively few\n                       \
  \ candidate probes and a very large blacklisted input\n  --debug               Debug\
  \ output\n  --verbose             Verbose output\n  -V, --version         show program's\
  \ version number and exit\n"
generated_using:
- --help
