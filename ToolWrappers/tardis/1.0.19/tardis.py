from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean, Int, File, Directory, String

Tardis_V0_1_0 = CommandToolBuilder(tool="tardis", base_command=["tardis"], inputs=[ToolInput(tag="in_in_workflow", input_type=Boolean(optional=True), prefix="--in-workflow", doc=InputDocumentation(doc="Run the command as part of a workflow. After launching\nall of the jobs, tardis waits for all outputs, which\nare then collated and merged into a single output\nfile, as specified by the output file path in the\noriginal command; all of the temporary input files\n(for example chunks of uncompressed fastq) are deleted\nprovided all prior steps completed without error (if\nthere was an error they are left there to assist with\ndebugging). Without this option, the program exits\nimmediately after launching all of the jobs, and\noutput is left un-collated in the scratch folder\ncreated by this script, and no cleanup is done.")), ToolInput(tag="in_chunksize", input_type=Int(optional=True), prefix="--chunksize", doc=InputDocumentation(doc="When conditioning the input file(s), split into files\neach containing N logical records. (A logical record\nfor a sequence file is a complete sequence. For a text\nfile it is a line of text). (If the -s option is used\nto sample the inputs, the chunksize relates to the\nfull un-sampled file . so the same chunk-size can be\nused whether random sampling or not. For example a\nchunksize of 1,000,000 is specified in combination\nwith a sampling rate of .0001, then each chunk would\ncontain 100 sequences . i.e. you should not adjust the\nchunk-size, for the sampling rate. Note that to avoid\na race-condition that could be caused by a very small\nchunk-size resulting in launching a very large number\nof jobs, tardis will throw an exception if the chunk-\nsize used would result in launching more than\nMAX_DIMENSION jobs (currently 5000) )")), ToolInput(tag="in_from_record", input_type=Int(optional=True), prefix="--from-record", doc=InputDocumentation(doc="When conditioning the input file(s), only use records\nfrom the input file after or including N (where that\nis logical record number . e.g. in a fastq file, start\nfrom record number N means start from sequence N). By\ncombining this option with -to, you can process slices\nof a file. Note that this option has no affect when\nprocessing a list-file.")), ToolInput(tag="in_to_record", input_type=Int(optional=True), prefix="--to-record", doc=InputDocumentation(doc="When conditioning the input file(s), only use records\nup to and including the record N (where that is\nlogical record number . e.g. in a fastq file, process\nup to record number N means process up to and\nincluding sequence N). By combining this option with\n-from, you can process slices of a file. Note that\nthis option has no affect when processing a list-file.")), ToolInput(tag="in_rather_process_files", input_type=File(optional=True), prefix="-s", doc=InputDocumentation(doc="Rather than process the entire input file(s), a random\nsample of the records is processed. RATE is the\nprobability that a given record will be sampled. For\nexample -s .001 will result in roughly 1 in every 1000\nlogical records being sampled. When the -s option is\nspecified, tardis does not clean up the conditioned\ninput and output . e.g. all of the uncompressed fastq\nsample fragments would be retained. These are retained\nto assist with the Q/C work that is normally\nassociated with a sampled run. Paired fastq input\nfiles are sampled in lock-step, provided the paired\nfastq conditioning directive is used for both files.")), ToolInput(tag="in_rootdir", input_type=Directory(optional=True), prefix="--rootdir", doc=InputDocumentation(doc="create the tardis working folder under DIR. If no\nworking root is specified, a default location is used.")), ToolInput(tag="in_dry_run", input_type=Boolean(optional=True), prefix="--dry-run", doc=InputDocumentation(doc="validate the run by doing a dry run. This means that\nthe chunks, job scripts and job files etc. are all\ngenerated but the jobs are not launched. The user can\nstart then kill (CTRL-C) the run, inspect the script\nand job files that were generated to check that their\ncommand has been conditioned as envisaged.")), ToolInput(tag="in_keep_conditioned_data", input_type=Boolean(optional=True), prefix="--keep-conditioned-data", doc=InputDocumentation(doc="keep the conditioned input and output - i.e. the input\nand output fragments. Normally in workflow mode these\nare deleted after the output is successfully\n'unconditioned' - i.e. joined back together")), ToolInput(tag="in_job_file", input_type=File(optional=True), prefix="--job-file", doc=InputDocumentation(doc="optionally supply a job template - tardis will read\nthe contents of FILE and use this as the job template.")), ToolInput(tag="in_templatedir", input_type=Directory(optional=True), prefix="--templatedir", doc=InputDocumentation(doc="template directory")), ToolInput(tag="in_job_template_name", input_type=Directory(optional=True), prefix="--job-template-name", doc=InputDocumentation(doc="job template name, resolved in template directory")), ToolInput(tag="in_hpc_type", input_type=Int(optional=True), prefix="--hpctype", doc=InputDocumentation(doc="indicate the hpc environment. Currently the only\nsupported values are: condor which results in tardis\nattempting to set up and launch condor jobs; local\nwhich results in each job being launched by tardis\nitself on the local machine, using the native python\nsub-process API. The maximum number of processes it\nwill run at a time is controlled by a global variable\nin the script MAX_PROCESSES, which is initially 10;\nslurm which results in tardis attempting to set up and\nlaunch slurm jobs.")), ToolInput(tag="in_baton_file", input_type=File(optional=True), prefix="--batonfile", doc=InputDocumentation(doc="if you supply a 'baton file' FILE, tardis will write\nthe process exit code to this file after all\nprocessing has completed. This can be useful to\npreserve synchronous execution of a workflow, even if\ntardis is started in the background - the workflow can\ntest the existence of the batonfile - if it exists\nthen the corresponding tardis processing step has\ncompleted (i.e. another way of each step in a workflow\n'passing the baton' to the next step)")), ToolInput(tag="in_runtime_config_source_file", input_type=File(optional=True), prefix="--runtimeconfigsourcefile", doc=InputDocumentation(doc="shell script fragment included in jobs")), ToolInput(tag="in_quiet", input_type=Boolean(optional=True), prefix="--quiet", doc=InputDocumentation(doc="run quietly")), ToolInput(tag="in_user_config", input_type=File(optional=True), prefix="--userconfig", doc=InputDocumentation(doc="user configuration file")), ToolInput(tag="in_no_sysconfig", input_type=Boolean(optional=True), prefix="--no-sysconfig", doc=InputDocumentation(doc="ignore the system configuration file")), ToolInput(tag="in_command", input_type=String(), position=0, doc=InputDocumentation(doc="command to run")), ToolInput(tag="in_arg", input_type=String(), position=1, doc=InputDocumentation(doc="command arguments"))], outputs=[], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Tardis_V0_1_0().translate("wdl", allow_empty_container=True)

