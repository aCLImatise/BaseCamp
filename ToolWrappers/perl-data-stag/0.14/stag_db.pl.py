from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import String, File, Boolean

Stag_Db_Pl_V0_1_0 = CommandToolBuilder(tool="stag_db.pl", base_command=["stag-db.pl"], inputs=[ToolInput(tag="in_name_stag_node", input_type=String(optional=True), prefix="-r", doc=InputDocumentation(doc="This is the name of the stag node (XML element) that will be stored in\nthe index; for example, with the XML below you may want to use the node\nname person and the unique key id\n<person_set>\n<person>\n<id>...</id>\n</person>\n<person>\n<id>...</id>\n</person>\n...\n</person_set>\nThis flag should only be used when you want to store data")), ToolInput(tag="in_node_used_nested", input_type=File(optional=True), prefix="-k", doc=InputDocumentation(doc="This node will be used as the unique/primary key for the data\nThis node should be nested directly below the node that is being stored\nin the index - if it is more that one below, specify a path\nThis flag should only be used when you want to store data")), ToolInput(tag="in_synonym_for_k", input_type=String(optional=True), prefix="-u", doc=InputDocumentation(doc="Synonym for -k")), ToolInput(tag="in_be_name_sxpr", input_type=File(optional=True), prefix="-p", doc=InputDocumentation(doc="This can be the name of a stag supported format (xml, sxpr, itext) - XML\nis assumed by default\nIt can also be a module name - this module is used to parse the input\nfile into a stag stream; see Data::Stag::BaseGenerator for details on\nwriting your own parsers/event generators\nThis flag should only be used when you want to store data")), ToolInput(tag="in_fetches_relationnode_unique", input_type=String(optional=True), prefix="-q", doc=InputDocumentation(doc="Fetches the relation/node with unique key value equal to query-id\nMultiple arguments can be passed by specifying -q multple times\nThis flag should only be used when you want to query data")), ToolInput(tag="in_top", input_type=String(optional=True), prefix="-top", doc=InputDocumentation(doc="If this is specified in conjunction with -q or -qf then all the query\nresult nodes will be nested inside a node with this name (ie this\nprovides a root for the resulting document tree)")), ToolInput(tag="in_qf", input_type=File(optional=True), prefix="-qf", doc=InputDocumentation(doc="This is a file of newline-seperated IDs; this is useful for querying the\nindex in batch")), ToolInput(tag="in_keys", input_type=Boolean(optional=True), prefix="-keys", doc=InputDocumentation(doc="This will write a list of all primary keys in the index")), ToolInput(tag="in_format_transforms_events", input_type=String(optional=True), prefix="-w", doc=InputDocumentation(doc="This format will be used to write the data; can be any stag format (xml,\nsxpr, itext) - default XML.\nCan also be a module that catches the incoming stag event stream and\ndoes something with it (for example, this could be a module you write\nyourself that transforms the stag events into HTML)")), ToolInput(tag="in_arguments", input_type=String(), position=0, doc=InputDocumentation(doc="-i INDEXFILE\nThis file will be used as the persistent index for storage/retrieval")), ToolInput(tag="in_stag", input_type=String(), position=0, doc=InputDocumentation(doc="For more complex stag to database mapping, see DBIx::DBStag and the")), ToolInput(tag="in_scripts", input_type=String(), position=1, doc=InputDocumentation(doc="stag-storenode"))], outputs=[], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Stag_Db_Pl_V0_1_0().translate("wdl", allow_empty_container=True)

