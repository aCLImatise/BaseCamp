from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import String, File, Boolean, Int, Float

Macmd_V0_1_0 = CommandToolBuilder(tool="maCMD", base_command=["maCMD"], inputs=[ToolInput(tag="in_presetting", input_type=String(optional=True), prefix="--Presetting", doc=InputDocumentation(doc="[Default]              Optimize aligner parameters for a selected\nsequencing technique. Available presettings are:\n'Default', 'Illumina', 'Illumina_Paired',\n'Nanopore', 'PacBio'.")), ToolInput(tag="in_index", input_type=File(optional=True), prefix="--Index", doc=InputDocumentation(doc="[]                     Filename of FMD-index. (A FMD-index can be\ngenerated via the --Create_Index option.) This\noption must be set.")), ToolInput(tag="in_in", input_type=File(optional=True), prefix="--In", doc=InputDocumentation(doc="[]                        Filenames of Fasta/Fastq files containing reads.\ngz-compressed files are automatically decompressed.\nMultiple files can be specified by a comma\nseparated list. At least one file name must be\nprovided.")), ToolInput(tag="in_mate_in", input_type=File(optional=True), prefix="--Mate_In", doc=InputDocumentation(doc="[]                   Filenames of the mates in the case of paired reads.\nIf this option is set, the aligner switches to\npaired mode automatically. The number of reads\ngiven as mates must match the accumulated number of\nreads provided via the 'in'-option.")), ToolInput(tag="in_create_index", input_type=Boolean(optional=True), prefix="--Create_Index", doc=InputDocumentation(doc="<fasta_file_name,output_folder,index_name> []\nGenerate a FMD-index for a Fasta file.\n'fasta_file_name' has to be the file-path of the\nFasta file holding the genome used for index\ncreation. 'output_folder' is the folder-path of the\nlocation used for index storage. 'index_name' is\nthe name used for identifying the new FMD-Index. In\nthe context of alignments, the genome-name is used\nfor FMD-index selection.")), ToolInput(tag="in_sam_file_name", input_type=File(optional=True), prefix="--SAM_File_name", doc=InputDocumentation(doc="[ma_out.sam]\nName of the SAM file alignments shall be written\nto.")), ToolInput(tag="in_number_of_threads", input_type=Int(optional=True), prefix="--Number_of_Threads", doc=InputDocumentation(doc="[8]              Number of threads used in the context of\nalignments. This options is only available, if 'use\nall processor cores' is off.")), ToolInput(tag="in_help", input_type=Boolean(optional=True), prefix="--Help", doc=InputDocumentation(doc="[true]                       Print the complete help text.")), ToolInput(tag="in_use_paired_reads", input_type=Boolean(optional=True), prefix="--Use_Paired_Reads", doc=InputDocumentation(doc="[false]              If your reads occur as paired reads, activate this")), ToolInput(tag="in_standard_deviation_of_paired_reads", input_type=Int(optional=True), prefix="--Standard_Deviation_of_Paired_Reads", doc=InputDocumentation(doc="[150]\n<val> represents the standard deviation for the\ndistance between paired reads. Used in the context\nof the computation of the mapping quality and for\npicking optimal alignment pairs.")), ToolInput(tag="in_score_factor_for_paired_reads", input_type=Float(optional=True), prefix="--Score_Factor_for_Paired_Reads", doc=InputDocumentation(doc="[1.25]\nThis factor is multiplied to the score of\nsuccessfully paired reads. Used in the context of\nthe computation of the mapping quality and for\npicking optimal alignment pairs. [val] < 1 results\nin penalty; [val] > 1 results in bonus.")), ToolInput(tag="in_check_for_consistency", input_type=Boolean(optional=True), prefix="--Check_for_Consistency", doc=InputDocumentation(doc="[false]         Check if both paired read files comprise the same\nnumber of reads. (Intended for debugging.)")), ToolInput(tag="in_seeding_technique", input_type=String(optional=True), prefix="--Seeding_Technique", doc=InputDocumentation(doc="[maxSpan]       Technique used for the initial seeding. Available\ntechniques are: maxSpan and SMEMs.")), ToolInput(tag="in_minimal_seed_length", input_type=Int(optional=True), prefix="--Minimal_Seed_Length", doc=InputDocumentation(doc="[16]           All seeds with size smaller than 'minimal seed\nlength' are discarded.")), ToolInput(tag="in_minimal_ambiguity", input_type=Int(optional=True), prefix="--Minimal_Ambiguity", doc=InputDocumentation(doc="[0]                  During the extension of seeds using the FMD-index:\nWith increasing extension width, the number of\noccurrences of corresponding seeds on the reference\nmontonically decreases. Keep extending, while the\nnumber of occurrences is higher than 'Minimal\nAmbiguity'. (For details see the MA-Handbook.)")), ToolInput(tag="in_maximal_ambiguity", input_type=Int(optional=True), prefix="--Maximal_Ambiguity", doc=InputDocumentation(doc="[100]                Discard seeds that occur more than 'Maximal\nambiguity' time on the reference. Set to zero to\ndisable.")), ToolInput(tag="in_skip_ambiguous_seeds", input_type=Boolean(optional=True), prefix="--Skip_Ambiguous_Seeds", doc=InputDocumentation(doc="[false]          Enabled: Discard all seeds that are more ambiguous\nthan [Maximal Ambiguity]. Disabled: sample [Maximal\nAmbiguity] random seeds from too ambiguous seeds.")), ToolInput(tag="in_seeding_drop_off_a_minimal_seed_size", input_type=Int(optional=True), prefix="--Seeding_Drop-off_A_-_Minimal_Seed_Size", doc=InputDocumentation(doc="[15]\nHeuristic runtime optimization: For a given read R,\nlet N be the number of seeds of size >= [val].\nDiscard R, if N < [length(R)] * [Seeding drop-off\nB].")), ToolInput(tag="in_seeding_drop_off_b_factor", input_type=Float(optional=True), prefix="--Seeding_Drop-off_B_-_Factor", doc=InputDocumentation(doc="[0.005]\nHeuristic runtime optimization: Factor for seed\ndrop-off calculation. For more information see\nparameter [Seeding drop-off A].")), ToolInput(tag="in_maximal_number_of_soc", input_type=Boolean(optional=True), prefix="--Maximal_Number_of_SoC", doc=InputDocumentation(doc="'s <int> [30]       Only consider the <val> best scored SoC's. 0 = no")), ToolInput(tag="in_fixed_soc_width", input_type=Int(optional=True), prefix="--Fixed_SoC_Width", doc=InputDocumentation(doc="[0]                    Set the SoC width to a fixed value. 0 = use the\nformula given in the paper. This parameter is\nintended for debugging purposes.")), ToolInput(tag="in_maximal_number_of_reported_alignments", input_type=Int(optional=True), prefix="--Maximal_Number_of_Reported_Alignments", doc=InputDocumentation(doc="[0]\nDo not output more than <val> alignments. Set to\nzero for unlimited output.")), ToolInput(tag="in_minimal_alignment_score", input_type=Int(optional=True), prefix="--Minimal_Alignment_Score", doc=InputDocumentation(doc="[75]           Suppress the output of alignments with a score\nbelow val.")), ToolInput(tag="in_omit_secondary_alignments", input_type=Boolean(optional=True), prefix="--Omit_Secondary_Alignments", doc=InputDocumentation(doc="[false]     Suppress the output of secondary alignments.")), ToolInput(tag="in_omit_supplementary_alignments", input_type=Boolean(optional=True), prefix="--Omit_Supplementary_Alignments", doc=InputDocumentation(doc="[false]\nSuppress the output of supplementary alignments.")), ToolInput(tag="in_maximal_supplementary_overlap", input_type=Float(optional=True), prefix="--Maximal_Supplementary_Overlap", doc=InputDocumentation(doc="[0.1]\nAn non-primary alignment A is considered\nsupplementary, if less than val percent of A\noverlap with the primary alignment on the query.\nOtherwise A is considered secondary.")), ToolInput(tag="in_number_supplementary_alignments", input_type=Int(optional=True), prefix="--Number_Supplementary_Alignments", doc=InputDocumentation(doc="[1]\nMaximal Number of supplementary alignments per\nprimary alignment.")), ToolInput(tag="in_emulate_ng_mlr", input_type=Boolean(optional=True), prefix="--Emulate_NGMLR", doc=InputDocumentation(doc="'s_tag_output <bool> [false]\nOutput SAM tags as NGMLR would. Activate this if\nyou want to use MA in combination with Sniffles.\nEnableing this will drastically increase the size\nof the output file.")), ToolInput(tag="in_output_long_cigars_in_cg_tag", input_type=Boolean(optional=True), prefix="--Output_long_cigars_in_CG_tag", doc=InputDocumentation(doc="[true]\nSome software crashes if a cigar is too long.\nEnabeling this flag makes MA output that the entire\nread was soft clipped in the regular cigar field if\nthe cigar would exceed 65536 operations. The actual\ncigar is then given in the CG:B:I tag as a comma\nseperated binary list.")), ToolInput(tag="in_soc_score_drop_off", input_type=Float(optional=True), prefix="--SoC_Score_Drop-off", doc=InputDocumentation(doc="[0.1]            Let x be the maximal encountered SoC score. Stop\nharmonizing SoC's if there is a SoC with a score\nlower than <val>*x.")), ToolInput(tag="in_minimal_harmonization_score", input_type=Int(optional=True), prefix="--Minimal_Harmonization_Score", doc=InputDocumentation(doc="[18]       Discard all harmonized SoC's with scores lower than\n<val>. Only keep detected inversions with a score\n>= <val> * [Match Score].")), ToolInput(tag="in_relative_minimal_harmonization_score", input_type=Int(optional=True), prefix="--Relative_Minimal_Harmonization_Score", doc=InputDocumentation(doc="[0.002]\nDiscard all harmonized SoC's with scores lower than\nlength(read)*<val>.")), ToolInput(tag="in_harmonization_drop_off_a_score_difference", input_type=Float(optional=True), prefix="--Harmonization_Drop-off_A_-_Score_Difference", doc=InputDocumentation(doc="[0.0001]\nLet x be the maximal encountered harmonization\nscore. Stop harmonizing further SoC's if there are\n<Harmonization Drop-off B> SoC's with lower scores\nthan x-<readlength>*<val> in a row.")), ToolInput(tag="in_harmonization_drop_off_b_look_ahead", input_type=Int(optional=True), prefix="--Harmonization_Drop-off_B_-_Lookahead", doc=InputDocumentation(doc="[3]\nSee Harmonization Drop-off A.")), ToolInput(tag="in_harmonization_score_drop_off_minimal_query_length", input_type=Int(optional=True), prefix="--Harmonization_Score_Drop-off_-_Minimal_Query_Length", doc=InputDocumentation(doc="[800]\nFor reads of length >= [val]: Ignore all SoC's with\nharmonization scores lower than the current maximal\nscore. 0 = disabled.")), ToolInput(tag="in_artifact_filter_a_maximal_delta_distance", input_type=Float(optional=True), prefix="--Artifact_Filter_A_-_Maximal_Delta_Distance", doc=InputDocumentation(doc="[0.1]\nFilter seeds if the difference between the delta\ndistance to it's predecessor and successor is less\nthen [val] percent (set to 1 to disable filter) and\nthe delta distance to it's pre- and successor is\nmore than [Artifact Filter B] nt.")), ToolInput(tag="in_artifact_filter_b_minimal_delta_distance", input_type=Int(optional=True), prefix="--Artifact_Filter_B_-_Minimal_Delta_Distance", doc=InputDocumentation(doc="[16]\nSee Artifact Filter A")), ToolInput(tag="in_pick_local_seed_set_a_enabled", input_type=Boolean(optional=True), prefix="--Pick_Local_Seed_Set_A_-_Enabled", doc=InputDocumentation(doc="[false]\n<val> = true enables local seed set computation.")), ToolInput(tag="in_pick_local_seed_set_b_optimistic_gap_estimation", input_type=Boolean(optional=True), prefix="--Pick_Local_Seed_Set_B_-_Optimistic_Gap_Estimation", doc=InputDocumentation(doc="[true]\nAfter the harmonization MA checks weather it is\npossible to compute a positively scored alignment\nfrom the seed set. Gaps between seeds can be\nestimated in two ways: Optimistic [true]: Assume\nthat the gap can be filled using merely matches and\na single insertion/deletion. Pessimistic [false]:\nAssume that the gap can be filled using matches and\nmismatches that add up to a score of 0 and a single\ninsertion/deletion.")), ToolInput(tag="in_pick_local_seed_set_c_maximal_gap_penalty", input_type=Int(optional=True), prefix="--Pick_Local_Seed_Set_C_-_Maximal_Gap_Penalty", doc=InputDocumentation(doc="[100]\nMaximal Gap cost penalty during local seed set\ncomputation.")), ToolInput(tag="in_maximal_gap_size", input_type=Int(optional=True), prefix="--Maximal_Gap_Size", doc=InputDocumentation(doc="[20]                  If the gap between seeds is larger than <val> on\nquery or reference, the dual extension process is\nused to fill the gap. Dual extension is more\nexpensive if the extension does not Z-drop, but\nmore efficient otherwise.")), ToolInput(tag="in_minimum_genome_size_for_heuristics", input_type=Int(optional=True), prefix="--Minimum_Genome_Size_for_Heuristics", doc=InputDocumentation(doc="[10000000]\nSome heuristics can only be applied on long enough\ngenomes. Disables: SoC score Drop-off if the genome\nis shorter than <val>.")), ToolInput(tag="in_disable_all_heuristics", input_type=Boolean(optional=True), prefix="--Disable_All_Heuristics", doc=InputDocumentation(doc="[false]        Disables all runtime heuristics. (Intended for\ndebugging.)")), ToolInput(tag="in_match_score", input_type=Int(optional=True), prefix="--Match_Score", doc=InputDocumentation(doc="[2]                        Match score. (Used in the context of Dynamic\nProgramming and for SoC width computation.)")), ToolInput(tag="in_mismatch_penalty", input_type=Int(optional=True), prefix="--Mismatch_Penalty", doc=InputDocumentation(doc="[4]                   Penalty for mismatch.")), ToolInput(tag="in_gap_penalty", input_type=Int(optional=True), prefix="--Gap_penalty", doc=InputDocumentation(doc="[4]                        First penalty for gap opening. (Two piece affine\ngap costs)")), ToolInput(tag="in_extend_penalty", input_type=Int(optional=True), prefix="--Extend_Penalty", doc=InputDocumentation(doc="[2]                     First penalty for gap extension. (Two piece affine\ngap costs)")), ToolInput(tag="in_second_gap_penalty", input_type=Int(optional=True), prefix="--Second_Gap_Penalty", doc=InputDocumentation(doc="[24]                Second penalty for gap opening. (Two piece affine\ngap costs)")), ToolInput(tag="in_second_extend_penalty", input_type=Int(optional=True), prefix="--Second_Extend_Penalty", doc=InputDocumentation(doc="[1]              Second penalty for gap extension. (Two piece affine\ngap costs)")), ToolInput(tag="in_padding", input_type=Int(optional=True), prefix="--Padding", doc=InputDocumentation(doc="[1000]                         If an alignment does not reach its read's\nendpoints, the missing parts can be computed via\ndynamic programming. If the length of the missing\nparts is smaller than 'Padding', dynamic\nprogramming is used to extend the alignment towards\nthe endpoints of the read. Otherwise, the unaligned\nparts of the read are ignored and the alignment\nstays unextended.")), ToolInput(tag="in_bandwidth_for_extensions", input_type=Int(optional=True), prefix="--Bandwidth_for_Extensions", doc=InputDocumentation(doc="[512]         Bandwidth used in the context of extending an\nalignment towards the endpoints of its read. (See\n'Padding')")), ToolInput(tag="in_minimal_bandwidth_in_gaps", input_type=Int(optional=True), prefix="--Minimal_Bandwidth_in_Gaps", doc=InputDocumentation(doc="[20]         Gaps between seeds are generally filled using\ndynamic programming. This option determines the\nminimal bandwidth used in the context of bridging\ngaps. More details can be found in the MA-Handbook.")), ToolInput(tag="in_z_drop", input_type=Int(optional=True), prefix="--Z_Drop", doc=InputDocumentation(doc="[200]                           If the running score during dynamic programming\ndrops faster than <val> stop the extension process.")), ToolInput(tag="in_detect_small_inversions", input_type=Boolean(optional=True), prefix="--Detect_Small_Inversions", doc=InputDocumentation(doc="[false]       Use DP to search for small inversions that do not\ncontain any seeds.")), ToolInput(tag="in_z_drop_inversions", input_type=Int(optional=True), prefix="--Z_Drop_Inversions", doc=InputDocumentation(doc="[100]                Check for an inversion if the running score during\ndynamic programming drops faster than <val>.")), ToolInput(tag="in_limit_dot", input_type=String(), position=0, doc=InputDocumentation(doc="-M, --Minimal_Number_of_SoC's <int> [1]        Always consider the first <val> SoC's no matter the "))], outputs=[], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Macmd_V0_1_0().translate("wdl", allow_empty_container=True)

