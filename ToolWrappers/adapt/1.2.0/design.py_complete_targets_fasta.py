from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Int, String, Array, File, Boolean

Design_Py_Complete_Targets_Fasta_V0_1_0 = CommandToolBuilder(tool="design.py_complete_targets_fasta", base_command=["design.py", "complete-targets", "fasta"], inputs=[ToolInput(tag="in_guide_length", input_type=Int(optional=True), prefix="--guide-length", doc=InputDocumentation(doc="Length of guide to construct")), ToolInput(tag="in_obj", input_type=String(optional=True), prefix="--obj", doc=InputDocumentation(doc="Objective function to solve. 'maximize-activity'\nmaximizes the expected activity of the guide set of\nthe target genomes subject to soft and hard\nconstraints on the size of the guide set. 'minimize-\nguides' minimizes the number of guides in the guide\nset subject to coverage constraints across the target\ngenomes.")), ToolInput(tag="in_guide_mismatches", input_type=Int(optional=True), prefix="--guide-mismatches", doc=InputDocumentation(doc="Allow for this number of mismatches when determining\nwhether a guide covers a sequence")), ToolInput(tag="in_guide_cover_frac", input_type=String(optional=True), prefix="--guide-cover-frac", doc=InputDocumentation(doc="The fraction of all sequences that must be covered by\nthe guides.")), ToolInput(tag="in_soft_guide_constraint", input_type=Int(optional=True), prefix="--soft-guide-constraint", doc=InputDocumentation(doc="Soft constraint on the number of guides. There is no\npenalty for a number of guides <=\nSOFT_GUIDE_CONSTRAINT, and having a number of guides\nbeyond this is penalized. See --penalty-strength. This\nvalue must be <= HARD_GUIDE_CONSTRAINT.")), ToolInput(tag="in_hard_guide_constraint", input_type=Int(optional=True), prefix="--hard-guide-constraint", doc=InputDocumentation(doc="Hard constraint on the number of guides. The number of\nguides designed for a target will be <=\nHARD_GUIDE_CONSTRAINT.")), ToolInput(tag="in_penalty_strength", input_type=Int(optional=True), prefix="--penalty-strength", doc=InputDocumentation(doc="Importance of the penalty when the number of guides\nexceeds the soft guide constraint. Namely, for a guide\nset G, if the penalty strength is L and the soft guide\nconstraint is h, then the penalty in the objective\nfunction is L*max(0, |G|-h). Must be >= 0. The value\ndepends on the output of activity model and reflects a\ntolerance for more guides; for the default activity\nmodel reasonable values are in the range [0.1, 0.5].")), ToolInput(tag="in_maximization_algorithm", input_type=String(optional=True), prefix="--maximization-algorithm", doc=InputDocumentation(doc="Algorithm to use for solving submodular maximization\nproblem. 'greedy' is the canonical deterministic\ngreedy algorithm (Nemhauser 1978) for constrained\nmonotone submodular maximization, which may perform\nwell in practice but has poor theoretical guarantees\nhere because the function is not monotone (unless\n--penalty-strength is 0). 'random-greedy' is the\nrandomized greedy algorithm (Buchbinder 2014) for\nconstrained non-monotone submodular maximization that\nhas good worst-case theoretical guarantees.")), ToolInput(tag="in_missing_th_res", input_type=Int(optional=True), prefix="--missing-thres", doc=InputDocumentation(doc="MISSING_THRES MISSING_THRES\n<A> <B> <C>; parameters governing the threshold on\nwhich sites to ignore due to too much missing data.\nThe 3 values specify not to attempt to design guides\noverlapping sites where the fraction of sequences with\nmissing data is > min(A, max(B, C*m)) where m is the\nmedian fraction of sequences with missing data over\nthe alignment. Set a=1 and b=1 to not ignore sites due\nto missing data.")), ToolInput(tag="in_id_m", input_type=Int(optional=True), prefix="--id-m", doc=InputDocumentation(doc="Allow for this number of mismatches when determining\nwhether a guide 'hits' a sequence in a group/taxon\nother than the for which it is being designed; higher\nvalues correspond to more specificity.")), ToolInput(tag="in_id_frac", input_type=String(optional=True), prefix="--id-frac", doc=InputDocumentation(doc="Decide that a guide 'hits' a group/taxon if it 'hits'\na fraction of sequences in that group/taxon that\nexceeds this value; lower values correspond to more\nspecificity.")), ToolInput(tag="in_id_method", input_type=String(optional=True), prefix="--id-method", doc=InputDocumentation(doc="Choice of method to query for specificity. 'lshnn' for\nLSH near-neighbor approach. 'shard' for approach that\nshards k-mers across small tries.")), ToolInput(tag="in_specific_against_fast_as", input_type=Array(t=String(), optional=True), prefix="--specific-against-fastas", doc=InputDocumentation(doc="Path to one or more FASTA files giving sequences, such\nthat guides are designed to be specific against (i.e.,\nnot hit) these sequences, according to --id-m and\n--id-frac. This is equivalent to specifying the FASTAs\nin the main input (as positional inputs), except that,\nwhen provided here, guides are not designed for them\nand they do not need to be aligned.")), ToolInput(tag="in_specific_against_tax_a", input_type=File(optional=True), prefix="--specific-against-taxa", doc=InputDocumentation(doc="Path to TSV file giving giving taxonomies from which\nto download all genomes and ensure guides are specific\nagainst (i.e., not hit) these. The TSV file has 2\ncolumns: (1) a taxonomic ID; (2) segment label, or\n'None' if unsegmented")), ToolInput(tag="in_do_not_allow_gu_pairing", input_type=Boolean(optional=True), prefix="--do-not-allow-gu-pairing", doc=InputDocumentation(doc="When determining whether a guide binds to a region of\ntarget sequence, do not count G-U (wobble) base pairs\nas matching. Default is to tolerate G-U pairing:\nnamely, A in an output guide sequence matches G in the\ntarget and C in an output guide sequence matches T in\nthe target (since the synthesized guide is the reverse\ncomplement of the output guide sequence)")), ToolInput(tag="in_required_guides", input_type=File(optional=True), prefix="--required-guides", doc=InputDocumentation(doc="Path to a file that gives guide sequences that will be\nincluded in the guide cover and output for the windows\nin which they belong, e.g., if certain guide sequences\nare shown experimentally to perform well. The file\nmust have 3 columns: col 1 gives an identifier for the\nalignment that the guide covers, such that i\nrepresents the i'th FASTA given as input (0-based);\ncol 2 gives a guide sequence; col 3 gives the start\nposition of the guide (0-based) in the alignment")), ToolInput(tag="in_blacklisted_ranges", input_type=File(optional=True), prefix="--blacklisted-ranges", doc=InputDocumentation(doc="Path to a file that gives ranges in alignments from\nwhich guides will not be constructed. The file must\nhave 3 columns: col 1 gives an identifier for the\nalignment that the range corresponds to, such that i\nrepresents the i'th FASTA given as input (0-based);\ncol 2 gives the start position of the range\n(inclusive); col 3 gives the end position of the range\n(exclusive)")), ToolInput(tag="in_blacklisted_km_ers", input_type=Int(optional=True), prefix="--blacklisted-kmers", doc=InputDocumentation(doc="Path to a FASTA file that gives k-mers to blacklisted\nfrom guide sequences. No guide sequences will be\nconstructed that contain these k-mers. The k-mers make\nup the sequences in the FASTA file; the sequence names\nare ignored. k-mers should be long enough so that not\ntoo many guide sequences are deemed to be unsuitable,\nand should be at most the length of the guide")), ToolInput(tag="in_require_flanking_five", input_type=Int(optional=True), prefix="--require-flanking5", doc=InputDocumentation(doc="Require the given sequence on the 5' protospacer\nflanking site (PFS) of each designed guide; this\ntolerates ambiguity in the sequence (e.g., 'H'\nrequires 'A', 'C', or 'T', or, equivalently, avoids\nguides flanked by 'G'). Note that this is the 5' end\nin the target sequence (not the spacer sequence).")), ToolInput(tag="in_require_flanking_three", input_type=Int(optional=True), prefix="--require-flanking3", doc=InputDocumentation(doc="Require the given sequence on the 3' protospacer\nflanking site (PFS) of each designed guide; this\ntolerates ambiguity in the sequence (e.g., 'H'\nrequires 'A', 'C', or 'T', or, equivalently, avoids\nguides flanked by 'G'). Note that this is the 3' end\nin the target sequence (not the spacer sequence).")), ToolInput(tag="in_seed", input_type=String(optional=True), prefix="--seed", doc=InputDocumentation(doc="SEED will set the random seed, guaranteeing the same\noutput given the same inputs. If SEED is not set to\nthe same value, output may vary across different runs.")), ToolInput(tag="in_predict_activity_model_path", input_type=File(optional=True), prefix="--predict-activity-model-path", doc=InputDocumentation(doc="PREDICT_ACTIVITY_MODEL_PATH\nPaths to directories containing serialized models in\nTensorFlow's SavedModel format for predicting guide-\ntarget activity. There are two arguments: (1)\nclassification model to determine which guides are\nactive; (2) regression model, which is used to\ndetermine which guides (among active ones) are highly\nactive. The models/ directory contains example models.\nIf not set, ADAPT does not predict activities to use\nduring design.")), ToolInput(tag="in_predict_activity_th_res", input_type=Int(optional=True), prefix="--predict-activity-thres", doc=InputDocumentation(doc="PREDICT_ACTIVITY_THRES\nThresholds to use for decisions on output of\npredictive models. There are two arguments: (1)\nclassification threshold for deciding which guide-\ntarget pairs are active (in [0,1], where higher values\nhave higher precision but less recall); (2) regression\nthreshold for deciding which guide-target pairs are\nhighly active (>= 0, where higher values limit the\nnumber determined to be highly active). If not set but\n--predict-activity-model-path is set, then ADAPT uses\ndefault thresholds stored with the models.")), ToolInput(tag="in_use_simple_binary_activity_prediction", input_type=Boolean(optional=True), prefix="--use-simple-binary-activity-prediction", doc=InputDocumentation(doc="If set, predict activity using a simple binary\nprediction between guide and target according to their\ndistance, with the threshold determined based on\n--guide-mismatches. This is only applicable when OBJ\nis 'maxmimize-activity'. This does not use a\nserialized model for predicting activity, so\n--predict-activity-model-path should not be set when\nthis is set.")), ToolInput(tag="in_do_not_memoize_guide_computations", input_type=Boolean(optional=True), prefix="--do-not-memoize-guide-computations", doc=InputDocumentation(doc="If set, do not memoize computations during the search,\nincluding of guides identified at each site and of\nspecificity queries. This can be helpful for\nbenchmarking the improvement of memoization, or if\nthere is reason to believe memoization will slow the\nsearch (e.g., if possible amplicons rarely overlap).\nNote that activity predictions are still memoized.")), ToolInput(tag="in_debug", input_type=Boolean(optional=True), prefix="--debug", doc=InputDocumentation(doc="Debug output")), ToolInput(tag="in_verbose", input_type=Boolean(optional=True), prefix="--verbose", doc=InputDocumentation(doc="Verbose output")), ToolInput(tag="in_primer_length", input_type=Int(optional=True), prefix="--primer-length", doc=InputDocumentation(doc="Length of primer in nt")), ToolInput(tag="in_primer_cover_frac", input_type=String(optional=True), prefix="--primer-cover-frac", doc=InputDocumentation(doc="Same as --cover-frac, except for the design of primers\n-- i.e., the fraction of sequences that must be\ncovered by the primers, independently on each end")), ToolInput(tag="in_primer_mismatches", input_type=Int(optional=True), prefix="--primer-mismatches", doc=InputDocumentation(doc="Allow for this number of mismatches when determining\nwhether a primer hybridizes to a sequence")), ToolInput(tag="in_max_primers_at_site", input_type=Int(optional=True), prefix="--max-primers-at-site", doc=InputDocumentation(doc="Only use primer sites that contain at most this number\nof primers; if not set, there is no limit")), ToolInput(tag="in_primer_gc_content_bounds", input_type=Int(optional=True), prefix="--primer-gc-content-bounds", doc=InputDocumentation(doc="PRIMER_GC_CONTENT_BOUNDS\nOnly use primer sites where all primers are within the\ngiven GC content bounds. This consists of two values L\nand H, each fractions in [0,1], such that primer GC\ncontent must be in [L, H]. If not set, there are no\nbounds.")), ToolInput(tag="in_max_target_length", input_type=Int(optional=True), prefix="--max-target-length", doc=InputDocumentation(doc="Only allow amplicons (incl. primers) to be at most\nthis number of nucleotides long; if not set, there is\nno limit")), ToolInput(tag="in_obj_fn_weights", input_type=Int(optional=True), prefix="--obj-fn-weights", doc=InputDocumentation(doc="OBJ_FN_WEIGHTS\nSpecify custom weights to use in the objective\nfunction for a target. These specify weights for\npenalties on primers and amplicons relative to the\nguide objective. There are 2 weights (A B), where the\ntarget objective function is [(guide objective value)\n+/- (A*(total number of primers) + B*log2(amplicon\nlength)]. It is + when --obj is minimize-guides and -\nwhen --obj is maximize-activity.")), ToolInput(tag="in_best_n_targets", input_type=Int(optional=True), prefix="--best-n-targets", doc=InputDocumentation(doc="Only compute and output up to this number of targets.\nNote that runtime will generally be longer for higher\nvalues")), ToolInput(tag="in_halt_search_early", input_type=Boolean(optional=True), prefix="--halt-search-early", doc=InputDocumentation(doc="If set, stop the target search as soon as\nBEST_N_TARGETS have been identified. The targets will\nmeet the given constraints but may not be optimal over\nthe whole genome. They will likely be from the\nbeginning of the genome.")), ToolInput(tag="in_only_account_for_amplified_seqs", input_type=Boolean(optional=True), prefix="--only-account-for-amplified-seqs", doc=InputDocumentation(doc="If set, design guides to cover GUIDE_COVER_FRAC of\njust the sequences covered by the primers. This\nchanges the behavior of -gp/--guide-cover-frac. This\nis only applicable when --obj is 'minimize-guides' as\nit is not implemented for 'maximize-activity'. In\ntotal, >= (GUIDE_COVER_FRAC * (2 * PRIMER_COVER_FRAC -\n1)) sequences will be covered. Using this may worsen\nruntime because the sequences to consider for guide\ndesign will change more often across amplicons and\ntherefore designs can be less easily memoized.")), ToolInput(tag="in_out_tsv", input_type=Array(t=String(), optional=True), prefix="--out-tsv", doc=InputDocumentation(doc="Path to output TSV. If more than one input FASTA is\ngiven, the same number of output TSVs must be given;\neach output TSV corresponds to an input FASTA.")), ToolInput(tag="in_cover_by_year_decay", input_type=Int(optional=True), prefix="--cover-by-year-decay", doc=InputDocumentation(doc="COVER_BY_YEAR_DECAY COVER_BY_YEAR_DECAY\n<A> <B> <C>; if set, group input sequences by year and\nset a desired partial cover for each year (fraction of\nsequences that must be covered by guides) as follows:\nA is a tsv giving a year for each input sequence (col\n1 is sequence name matching that in the input FASTA,\ncol 2 is year). All years >= A receive a desired cover\nfraction of GUIDE_COVER_FRAC for guides (and\nPRIMER_COVER_FRAC for primers). Each preceding year\nreceives a desired cover fraction that decays by B --\ni.e., year n is given B*(desired cover fraction of\nyear n+1).\n")), ToolInput(tag="in_in_fast_a", input_type=String(), position=0, doc=InputDocumentation(doc="Path to input FASTA. More than one can be given for\ndifferential identification"))], outputs=[], container="quay.io/biocontainers/adapt:1.2.0--py_0", version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Design_Py_Complete_Targets_Fasta_V0_1_0().translate("wdl")

