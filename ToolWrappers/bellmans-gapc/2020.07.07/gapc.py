from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean, File, String, Int

Gapc_V0_1_0 = CommandToolBuilder(tool="gapc", base_command=["gapc"], inputs=[ToolInput(tag="in_try_inline_nts", input_type=Boolean(optional=True), prefix="-n", doc=InputDocumentation(doc="[ --inline ]              try to inline NTs")), ToolInput(tag="in_arg_use_instance", input_type=Boolean(optional=True), prefix="-i", doc=InputDocumentation(doc="[ --instance ] arg        use instance (else first)")), ToolInput(tag="in_arg_use_product", input_type=Boolean(optional=True), prefix="-p", doc=InputDocumentation(doc="[ --product ] arg         use product of algebras")), ToolInput(tag="in_arg_output_filename", input_type=File(optional=True), prefix="-o", doc=InputDocumentation(doc="[ --output ] arg          output filename (out.cc)")), ToolInput(tag="in_class_name", input_type=String(optional=True), prefix="--class-name", doc=InputDocumentation(doc="default: basename(output)")), ToolInput(tag="in_print_code_stdout", input_type=Boolean(optional=True), prefix="-E", doc=InputDocumentation(doc="[ --stdout ]              print code to stdout")), ToolInput(tag="in_tab", input_type=String(optional=True), prefix="--tab", doc=InputDocumentation(doc="overwrite table conf with this list")), ToolInput(tag="in_automatically_compute_tableconfiguration", input_type=Boolean(optional=True), prefix="-t", doc=InputDocumentation(doc="[ --table-design ]        automatically compute optimal table\nconfiguration (ignore conf from source file)")), ToolInput(tag="in_tab_all", input_type=Boolean(optional=True), prefix="--tab-all", doc=InputDocumentation(doc="tabulate everything")), ToolInput(tag="in_cy_k", input_type=Boolean(optional=True), prefix="--cyk", doc=InputDocumentation(doc="bottom up evalulation codgen (default: top down\nunger style)")), ToolInput(tag="in_backtrace", input_type=Boolean(optional=True), prefix="--backtrace", doc=InputDocumentation(doc="use backtracing for the pretty print RHS of the")), ToolInput(tag="in_sub_opt_classify", input_type=Boolean(optional=True), prefix="--subopt-classify", doc=InputDocumentation(doc="classified dp")), ToolInput(tag="in_sub_opt", input_type=Boolean(optional=True), prefix="--subopt", doc=InputDocumentation(doc="generate suboptimal backtracing code (needs foo\n* pretty)")), ToolInput(tag="in_sample", input_type=Boolean(optional=True), prefix="--sample", doc=InputDocumentation(doc="generate stochastic backtracing code")), ToolInput(tag="in_no_co_opt", input_type=Boolean(optional=True), prefix="--no-coopt", doc=InputDocumentation(doc="with kbacktrace, don't output cooptimal")), ToolInput(tag="in_k_best", input_type=Boolean(optional=True), prefix="--kbest", doc=InputDocumentation(doc="classify the k-best classes only")), ToolInput(tag="in_ambiguity", input_type=Boolean(optional=True), prefix="--ambiguity", doc=InputDocumentation(doc="converts the selected instance into a context\nfree string grammar")), ToolInput(tag="in_specialize_grammar", input_type=Boolean(optional=True), prefix="--specialize_grammar", doc=InputDocumentation(doc="uses the selected instance and creates a GAP\nprogram which creates specialized GAP programs\nthat recognize a subset of candidates of the\noriginal grammar.")), ToolInput(tag="in_verbose", input_type=Boolean(optional=True), prefix="--verbose", doc=InputDocumentation(doc="show suppressed warnings and messages")), ToolInput(tag="in_arg_log_level", input_type=Boolean(optional=True), prefix="-l", doc=InputDocumentation(doc="[ --log-level ] arg       the log level, valid values are 0 (VERBOSE), 1\n(INFO),  2 (NORMAL), 3 (WARNING), 4 (ERROR).\nDefault is 2 (NORMAL).")), ToolInput(tag="in_arg_include_path", input_type=Boolean(optional=True), prefix="-I", doc=InputDocumentation(doc="[ --include ] arg         include path")), ToolInput(tag="in__version_string", input_type=Boolean(optional=True), prefix="-v", doc=InputDocumentation(doc="[ --version ]             version string")), ToolInput(tag="in_arg_implementation_pareto", input_type=Boolean(optional=True), prefix="-P", doc=InputDocumentation(doc="[ --pareto-version ] arg  Implementation of Pareto Product to use 0\n(NoSort), 1 (Sort), 2 (ISort), 3\n(MultiDimOptimized), 4 (NoSort, domination\nordered)")), ToolInput(tag="in_multi_dim_pareto", input_type=Boolean(optional=True), prefix="--multi-dim-pareto", doc=InputDocumentation(doc="Use multi-dimensional Pareto. Works with -P 0,")), ToolInput(tag="in_arg_cutoff_value", input_type=Boolean(optional=True), prefix="-c", doc=InputDocumentation(doc="[ --cut-off ] arg         The cut-off value for -P 3 option (65 default).")), ToolInput(tag="in_arg_number_set", input_type=Boolean(optional=True), prefix="-f", doc=InputDocumentation(doc="[ --float-accuracy ] arg  The number of decimal places regarded for pareto\nand sorting procedures. If this is not set the\nfull floating point is compared.")), ToolInput(tag="in_arg_set_generate", input_type=Boolean(optional=True), prefix="-S", doc=InputDocumentation(doc="[ --specialized-adp ] arg Set to generate specialized implementations of\nthe ADP framework: 0 (Standard), 1 (Sorted ADP),\n2 (Pareto Eager ADP)")), ToolInput(tag="in_step_mode", input_type=Int(optional=True), prefix="--step-mode", doc=InputDocumentation(doc="Mode of specialization: 0 force block mode, 1\nforce stepwise mode. This is automatically set\nto best option if not specified.\n")), ToolInput(tag="in_product", input_type=String(), position=0, doc=InputDocumentation(doc="--kbacktrace                 backtracing for k-scoring lhs"))], outputs=[ToolOutput(tag="out_arg_output_filename", output_type=File(optional=True), selector=InputSelector(input_to_select="in_arg_output_filename", type_hint=File()), doc=OutputDocumentation(doc="[ --output ] arg          output filename (out.cc)"))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Gapc_V0_1_0().translate("wdl", allow_empty_container=True)

