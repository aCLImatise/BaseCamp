from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Int, Boolean

Bmfilter_V0_1_0 = CommandToolBuilder(tool="bmfilter", base_command=["bmfilter"], inputs=[ToolInput(tag="in_quality_channels", input_type=Int(optional=True), prefix="--quality-channels", doc=InputDocumentation(doc="Number of quality channers for reads (0|1)")), ToolInput(tag="in_read_one", input_type=Boolean(optional=True), prefix="--read-1", doc=InputDocumentation(doc="=''                   -1 ''          Fasta or fastq (for -q1) file with reads, may be repeated")), ToolInput(tag="in_read_two", input_type=Boolean(optional=True), prefix="--read-2", doc=InputDocumentation(doc="=''                   -2 ''          Fasta or fastq (for -q1) file with read pair mates, if used should be repeated as many times as -1 is")), ToolInput(tag="in_word_bitmask", input_type=Boolean(optional=True), prefix="--word-bitmask", doc=InputDocumentation(doc="=''             -b ''          Word bitmask file (may be repeated)")), ToolInput(tag="in_use_mmap", input_type=Boolean(optional=True), prefix="--use-mmap", doc=InputDocumentation(doc="Use mmap for word bitmask (slow unless used for few reads; intended for debug) [off]")), ToolInput(tag="in_max_ambiguities", input_type=Int(optional=True), prefix="--max-ambiguities", doc=InputDocumentation(doc="Maximal number of ambiguities per word")), ToolInput(tag="in_clip_lowercase", input_type=Boolean(optional=True), prefix="--clip-lowercase", doc=InputDocumentation(doc="Should lowercase head and tail of each read be clipped [off]")), ToolInput(tag="in_clip_n_win", input_type=Int(optional=True), prefix="--clip-N-win", doc=InputDocumentation(doc="Clip sequence head or tail as long as it has at least one N per this long window")), ToolInput(tag="in_clip_quality", input_type=Int(optional=True), prefix="--clip-quality", doc=InputDocumentation(doc="Clip sequence head or tail with quality lower then this (for fastq input)")), ToolInput(tag="in_output", input_type=Boolean(optional=True), prefix="--output", doc=InputDocumentation(doc="=''                   -o ''          Output base name (suffixes will be added to it)")), ToolInput(tag="in_tag", input_type=Boolean(optional=True), prefix="--tag", doc=InputDocumentation(doc="Produce .tag file [off]")), ToolInput(tag="in_post", input_type=Boolean(optional=True), prefix="--post", doc=InputDocumentation(doc="Produce .short?.fa and .long?.fa files [off]")), ToolInput(tag="in_report", input_type=Boolean(optional=True), prefix="--report", doc=InputDocumentation(doc="Produce .report file [off]")), ToolInput(tag="in_post_clipped", input_type=Boolean(optional=True), prefix="--post-clipped", doc=InputDocumentation(doc="Put clipped versions of sequences to output .fa files [off]")), ToolInput(tag="in_complexity", input_type=Int(optional=True), prefix="--complexity", doc=InputDocumentation(doc="Set complexity filter cutoff")), ToolInput(tag="in_short_seq", input_type=Int(optional=True), prefix="--short-seq", doc=InputDocumentation(doc="Set sequence length to consider it as short for postprocessing")), ToolInput(tag="in_no_post_len", input_type=Int(optional=True), prefix="--no-post-len", doc=InputDocumentation(doc="Set longest sequence length to ignore postprocessing")), ToolInput(tag="in_chop_length", input_type=Int(optional=True), prefix="--chop-length", doc=InputDocumentation(doc="Set length to chop short sequences to")), ToolInput(tag="in_chop_step", input_type=Int(optional=True), prefix="--chop-step", doc=InputDocumentation(doc="Set step by which to chop short sequences")), ToolInput(tag="in_mask_early", input_type=Int(optional=True), prefix="--mask-early", doc=InputDocumentation(doc="Set mask low complexity before applying heuristics")), ToolInput(tag="in_post_low_complexity", input_type=Int(optional=True), prefix="--post-low-complexity", doc=InputDocumentation(doc="Should 'unknown' low complexity reads be sent to post processing")), ToolInput(tag="in_heur_min_words", input_type=Int(optional=True), prefix="--heur-min-words", doc=InputDocumentation(doc="Set minimal word count to apply heuristics")), ToolInput(tag="in_heur_many_words", input_type=Int(optional=True), prefix="--heur-many-words", doc=InputDocumentation(doc="Set number of good words which switches watermarks (long/short)")), ToolInput(tag="in_heur_count_long_pct", input_type=Int(optional=True), prefix="--heur-count-long-pct", doc=InputDocumentation(doc=":60                  Set watermarks for matched word count for long sequences, int % of good words")), ToolInput(tag="in_heur_count_short_pct", input_type=Int(optional=True), prefix="--heur-count-short-pct", doc=InputDocumentation(doc=":80                 Set watermarks for matched word count for short sequences, int % of good words")), ToolInput(tag="in_heur_run_long_pct", input_type=Int(optional=True), prefix="--heur-run-long-pct", doc=InputDocumentation(doc=":20                    Set watermarks for longest match run for long sequences, int % of good words")), ToolInput(tag="in_heur_run_short_pct", input_type=Int(optional=True), prefix="--heur-run-short-pct", doc=InputDocumentation(doc=":40                   Set watermarks for longest match run for short sequences, int % of good words")), ToolInput(tag="in_heur_negligible_length", input_type=Int(optional=True), prefix="--heur-negligible-length", doc=InputDocumentation(doc="Set cutoff for sequences to consider - these and shorter (after clipping) will be marked as foreign"))], outputs=[], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Bmfilter_V0_1_0().translate("wdl", allow_empty_container=True)

