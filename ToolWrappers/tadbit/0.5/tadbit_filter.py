from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean, File, Int, Array, String

Tadbit_Filter_V0_1_0 = CommandToolBuilder(tool="tadbit_filter", base_command=["tadbit", "filter"], inputs=[ToolInput(tag="in_force", input_type=Boolean(optional=True), prefix="--force", doc=InputDocumentation(doc="overwrite previously run job")), ToolInput(tag="in_resume", input_type=Boolean(optional=True), prefix="--resume", doc=InputDocumentation(doc="use filters of previously run job")), ToolInput(tag="in_workdir", input_type=File(optional=True), prefix="--workdir", doc=InputDocumentation(doc="path to working directory (generated with the tool tadbit mapper)")), ToolInput(tag="in_cpus", input_type=Int(optional=True), prefix="--cpus", doc=InputDocumentation(doc="[8] Maximum number of CPU cores available in the execution host. If\nhigher than 1, tasks with multi-threading capabilities will enabled\n(if 0 all available) cores will be used")), ToolInput(tag="in_nox", input_type=Boolean(optional=True), prefix="--noX", doc=InputDocumentation(doc="no display server (X screen)")), ToolInput(tag="in_tmp_db", input_type=File(optional=True), prefix="--tmpdb", doc=InputDocumentation(doc="if provided uses this directory to manipulate the database")), ToolInput(tag="in_path_ids", input_type=Array(t=Int(), optional=True), prefix="--pathids", doc=InputDocumentation(doc="Use as input data generated by a job under a given pathids. Use\ntadbit describe to find out which. To filter an intersected file\nproduced with tadbit map --fast_fragment only one PATHid is needed\notherwise one per read is needed, first for read 1, second for read\n2.")), ToolInput(tag="in_compress_input", input_type=Boolean(optional=True), prefix="--compress_input", doc=InputDocumentation(doc="Compress input mapped files when parsing is done. This is done in\nbackground, while next MAP file is processed, or while reads are\nsorted.")), ToolInput(tag="in_sam_tools", input_type=File(optional=True), prefix="--samtools", doc=InputDocumentation(doc="path samtools binary")), ToolInput(tag="in_format", input_type=String(optional=True), prefix="--format", doc=InputDocumentation(doc="[mid] for compression into pseudo-BAM format. Short contains only\npositions of reads mapped, mid everything but restriction sites.")), ToolInput(tag="in_valid", input_type=Boolean(optional=True), prefix="--valid", doc=InputDocumentation(doc="stores only valid-pairs discards filtered out reads.")), ToolInput(tag="in_clean", input_type=Boolean(optional=True), prefix="--clean", doc=InputDocumentation(doc="remove intermediate files. WARNING: together with format 'short' or\nvalid options, this may results in losing data")), ToolInput(tag="in_apply", input_type=Array(t=Int(), optional=True), prefix="--apply", doc=InputDocumentation(doc="[[1, 2, 3, 4, 6, 7, 9, 10]] Use filters to define a set os valid\npair of reads e.g.: '--apply 1 2 3 4 6 7 8 9'. Where these\nnumberscorrespond to: 1: self-circle, 2: dangling-end, 3: error, 4:\nextra dangling-end, 5: too close from RES, 6: too short, 7: too\nlarge, 8: over-represented, 9: duplicated, 10: random breaks")), ToolInput(tag="in_over_represented", input_type=Int(optional=True), prefix="--over_represented", doc=InputDocumentation(doc="[0.001%] percentage of restriction-enzyme (RE) genomic fragments\nwith more coverage to exclude (possible PCR artifact).")), ToolInput(tag="in_max_frag_size", input_type=Int(optional=True), prefix="--max_frag_size", doc=InputDocumentation(doc="[100000] to exclude large genomic RE fragments (probably resulting\nfrom gaps in the reference genome)")), ToolInput(tag="in_min_frag_size", input_type=Int(optional=True), prefix="--min_frag_size", doc=InputDocumentation(doc="[50] to exclude small genomic RE fragments (smaller than sequenced\nreads)")), ToolInput(tag="in_re_proximity", input_type=Int(optional=True), prefix="--re_proximity", doc=InputDocumentation(doc="[5] to exclude read-ends falling too close from RE site (pseudo-\ndangling-ends)\n"))], outputs=[], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Tadbit_Filter_V0_1_0().translate("wdl", allow_empty_container=True)

