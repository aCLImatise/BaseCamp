from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean, File

Mmseqs_Multihitsearch_V0_1_0 = CommandToolBuilder(tool="mmseqs_multihitsearch", base_command=["mmseqs", "multihitsearch"], inputs=[ToolInput(tag="in_comp_bias_corr", input_type=Boolean(optional=True), prefix="--comp-bias-corr", doc=InputDocumentation(doc="1               correct for locally biased amino acid composition [0,1]")), ToolInput(tag="in_add_self_matches", input_type=Boolean(optional=True), prefix="--add-self-matches", doc=InputDocumentation(doc="false           artificially add entries of queries with themselves (for clustering)")), ToolInput(tag="in_sensitivity_faster_fast", input_type=Boolean(optional=True), prefix="-s", doc=InputDocumentation(doc="7.000           sensitivity: 1.0 faster; 4.0 fast default; 7.5 sensitive [1.0,7.5]")), ToolInput(tag="in_kmer_size_range", input_type=Boolean(optional=True), prefix="-k", doc=InputDocumentation(doc="0               k-mer size in the range [6,7] (0: set automatically to optimum)")), ToolInput(tag="in_k_score", input_type=Boolean(optional=True), prefix="--k-score", doc=InputDocumentation(doc="2147483647      k-mer threshold for generating similar-k-mer lists")), ToolInput(tag="in_alph_size", input_type=Boolean(optional=True), prefix="--alph-size", doc=InputDocumentation(doc="21              alphabet size [2,21]")), ToolInput(tag="in_offset_result", input_type=Boolean(optional=True), prefix="--offset-result", doc=InputDocumentation(doc="0               Offset result list")), ToolInput(tag="in_split", input_type=Boolean(optional=True), prefix="--split", doc=InputDocumentation(doc="0               Splits input sets into N equally distributed chunks. The default value sets the best split automatically. createindex can only be used with split 1.")), ToolInput(tag="in_split_mode", input_type=Boolean(optional=True), prefix="--split-mode", doc=InputDocumentation(doc="2               0: split target db; 1: split query db;  2: auto, depending on main memory")), ToolInput(tag="in_split_memory_limit", input_type=Boolean(optional=True), prefix="--split-memory-limit", doc=InputDocumentation(doc="0               Maximum system memory in megabyte that one split may use. Defaults (0) to all available system memory.")), ToolInput(tag="in_diag_score", input_type=Boolean(optional=True), prefix="--diag-score", doc=InputDocumentation(doc="1               use diagonal score for sorting the prefilter results [0,1]")), ToolInput(tag="in_exact_km_er_matching", input_type=Boolean(optional=True), prefix="--exact-kmer-matching", doc=InputDocumentation(doc="0               only exact k-mer matching [0,1]")), ToolInput(tag="in_mask", input_type=Boolean(optional=True), prefix="--mask", doc=InputDocumentation(doc="1               0: w/o low complexity masking, 1: with low complexity masking")), ToolInput(tag="in_min_un_gapped_score", input_type=Boolean(optional=True), prefix="--min-ungapped-score", doc=InputDocumentation(doc="15              accept only matches with ungapped alignment score above this threshold")), ToolInput(tag="in_spaced_km_er_mode", input_type=Boolean(optional=True), prefix="--spaced-kmer-mode", doc=InputDocumentation(doc="1               0: use consecutive positions a k-mers; 1: use spaced k-mers")), ToolInput(tag="in_false_add_convert", input_type=Boolean(optional=True), prefix="-a", doc=InputDocumentation(doc="false           add backtrace string (convert to alignments with mmseqs convertalis utility)")), ToolInput(tag="in_alignment_mode", input_type=Boolean(optional=True), prefix="--alignment-mode", doc=InputDocumentation(doc="0               How to compute the alignment: 0: automatic; 1: only score and end_pos; 2: also start_pos and cov; 3: also seq.id; 4: only ungapped alignment")), ToolInput(tag="in_list_matches_evalue", input_type=Boolean(optional=True), prefix="-e", doc=InputDocumentation(doc="100.000         list matches below this E-value [0.0, inf]")), ToolInput(tag="in_min_seq_id", input_type=Boolean(optional=True), prefix="--min-seq-id", doc=InputDocumentation(doc="0.000           list matches above this sequence identity (for clustering) [0.0,1.0]")), ToolInput(tag="in_seq_id_mode", input_type=Boolean(optional=True), prefix="--seq-id-mode", doc=InputDocumentation(doc="0               0: alignment length 1: shorter, 2: longer sequence")), ToolInput(tag="in_alt_ali", input_type=Boolean(optional=True), prefix="--alt-ali", doc=InputDocumentation(doc="0               Show up to this many alternative alignments")), ToolInput(tag="in_list_matches_fraction", input_type=Boolean(optional=True), prefix="-c", doc=InputDocumentation(doc="0.000           list matches above this fraction of aligned (covered) residues (see --cov-mode)")), ToolInput(tag="in_cov_mode", input_type=Boolean(optional=True), prefix="--cov-mode", doc=InputDocumentation(doc="0               0: coverage of query and target, 1: coverage of target, 2: coverage of query 3: target seq. length needs be at least x% of query length")), ToolInput(tag="in_realign", input_type=Boolean(optional=True), prefix="--realign", doc=InputDocumentation(doc="false           compute more conservative, shorter alignments (scores and E-values not changed)")), ToolInput(tag="in_max_rejected", input_type=Boolean(optional=True), prefix="--max-rejected", doc=InputDocumentation(doc="2147483647      maximum rejected alignments before alignment calculation for a query is aborted")), ToolInput(tag="in_max_accept", input_type=Boolean(optional=True), prefix="--max-accept", doc=InputDocumentation(doc="2147483647      maximum accepted alignments before alignment calculation for a query is stopped")), ToolInput(tag="in_score_bias", input_type=Boolean(optional=True), prefix="--score-bias", doc=InputDocumentation(doc="0.300           Score bias when computing the SW alignment (in bits)")), ToolInput(tag="in_pc_a", input_type=Boolean(optional=True), prefix="--pca", doc=InputDocumentation(doc="1.000           pseudo count admixture strength")), ToolInput(tag="in_pcb", input_type=Boolean(optional=True), prefix="--pcb", doc=InputDocumentation(doc="1.500           pseudo counts: Neff at half of maximum admixture (0.0,infinity)")), ToolInput(tag="in_mask_profile", input_type=Boolean(optional=True), prefix="--mask-profile", doc=InputDocumentation(doc="1               mask query sequence of profile using tantan [0,1]")), ToolInput(tag="in_e_profile", input_type=Boolean(optional=True), prefix="--e-profile", doc=InputDocumentation(doc="0.001           includes sequences matches with < e-value thr. into the profile [>=0.0]")), ToolInput(tag="in_wg", input_type=Boolean(optional=True), prefix="--wg", doc=InputDocumentation(doc="false           use global sequence weighting for profile calculation")), ToolInput(tag="in_filter_msa", input_type=Boolean(optional=True), prefix="--filter-msa", doc=InputDocumentation(doc="1               filter msa: 0: do not filter, 1: filter")), ToolInput(tag="in_max_seq_id", input_type=Boolean(optional=True), prefix="--max-seq-id", doc=InputDocumentation(doc="0.900           reduce redundancy of output MSA using max. pairwise sequence identity [0.0,1.0]")), ToolInput(tag="in_qid", input_type=Boolean(optional=True), prefix="--qid", doc=InputDocumentation(doc="0.000           reduce diversity of output MSAs using min.seq. identity with query sequences [0.0,1.0]")), ToolInput(tag="in_two_zero_dot_zero_zero_zero", input_type=Boolean(optional=True), prefix="-20.000", doc=InputDocumentation(doc="reduce diversity of output MSAs using min. score per aligned residue with query sequences [-50.0,100.0]")), ToolInput(tag="in_cov", input_type=Boolean(optional=True), prefix="--cov", doc=InputDocumentation(doc="0.700           filter output MSAs using min. fraction of query residues covered by matched sequences [0.0,1.0]")), ToolInput(tag="in_diff", input_type=Boolean(optional=True), prefix="--diff", doc=InputDocumentation(doc="1000            filter MSAs by selecting most diverse set of sequences, keeping at least this many seqs in each MSA block of length 50")), ToolInput(tag="in_num_iterations", input_type=Boolean(optional=True), prefix="--num-iterations", doc=InputDocumentation(doc="1               Search iterations")), ToolInput(tag="in_no_preload", input_type=Boolean(optional=True), prefix="--no-preload", doc=InputDocumentation(doc="false           Do not preload database")), ToolInput(tag="in_re_score_mode", input_type=Boolean(optional=True), prefix="--rescore-mode", doc=InputDocumentation(doc="0               Rescore diagonal with: 0: Hamming distance, 1: local alignment (score only) or 2: local alignment")), ToolInput(tag="in_min_length", input_type=Boolean(optional=True), prefix="--min-length", doc=InputDocumentation(doc="1               minimum codon number in open reading frames")), ToolInput(tag="in_max_length", input_type=Boolean(optional=True), prefix="--max-length", doc=InputDocumentation(doc="2147483647      maximum codon number in open reading frames")), ToolInput(tag="in_max_gaps", input_type=Boolean(optional=True), prefix="--max-gaps", doc=InputDocumentation(doc="2147483647      maximum number of codons with gaps or unknown residues before an open reading frame is rejected")), ToolInput(tag="in_contig_start_mode", input_type=Boolean(optional=True), prefix="--contig-start-mode", doc=InputDocumentation(doc="2               Contig start can be 0: incomplete, 1: complete, 2: both")), ToolInput(tag="in_contig_end_mode", input_type=Boolean(optional=True), prefix="--contig-end-mode", doc=InputDocumentation(doc="2               Contig end can be 0: incomplete, 1: complete, 2: both")), ToolInput(tag="in_orf_start_mode", input_type=Boolean(optional=True), prefix="--orf-start-mode", doc=InputDocumentation(doc="0               Orf fragment can be 0: from start to stop, 1: from any to stop, 2: from last encountered start to stop (no start in the middle)")), ToolInput(tag="in_forward_frames", input_type=Boolean(optional=True), prefix="--forward-frames", doc=InputDocumentation(doc="1,2,3           comma-seperated list of ORF frames on the forward strand to be extracted")), ToolInput(tag="in_reverse_frames", input_type=Boolean(optional=True), prefix="--reverse-frames", doc=InputDocumentation(doc="1,2,3           comma-seperated list of ORF frames on the reverse strand to be extracted")), ToolInput(tag="in_translation_table", input_type=Boolean(optional=True), prefix="--translation-table", doc=InputDocumentation(doc="1               1) CANONICAL, 2) VERT_MITOCHONDRIAL, 3) YEAST_MITOCHONDRIAL, 4) MOLD_MITOCHONDRIAL, 5) INVERT_MITOCHONDRIAL, 6) CILIATE, 9) FLATWORM_MITOCHONDRIAL, 10) EUPLOTID, 11) PROKARYOTE, 12) ALT_YEAST, 13) ASCIDIAN_MITOCHONDRIAL, 14) ALT_FLATWORM_MITOCHONDRIAL, 15) BLEPHARISMA, 16) CHLOROPHYCEAN_MITOCHONDRIAL, 21) TREMATODE_MITOCHONDRIAL, 22) SCENEDESMUS_MITOCHONDRIAL, 23) THRAUSTOCHYTRIUM_MITOCHONDRIAL, 24) PTEROBRANCHIA_MITOCHONDRIAL, 25) GRACILIBACTERIA, 26) PACHYSOLEN, 27) KARYORELICT, 28) CONDYLOSTOMA, 29) MESODINIUM, 30) PERTRICH, 31) BLASTOCRITHIDIA")), ToolInput(tag="in_use_all_table_starts", input_type=Boolean(optional=True), prefix="--use-all-table-starts", doc=InputDocumentation(doc="false           use all alteratives for a start codon in the genetic table, if false - only ATG (AUG)")), ToolInput(tag="in_id_offset", input_type=Boolean(optional=True), prefix="--id-offset", doc=InputDocumentation(doc="0               numeric ids in index file are offset by this value")), ToolInput(tag="in_add_orf_stop", input_type=Boolean(optional=True), prefix="--add-orf-stop", doc=InputDocumentation(doc="false           add * at complete start and end")), ToolInput(tag="in_start_sens", input_type=Boolean(optional=True), prefix="--start-sens", doc=InputDocumentation(doc="4.000           start sensitivity")), ToolInput(tag="in_sens_steps", input_type=Boolean(optional=True), prefix="--sens-steps", doc=InputDocumentation(doc="1               Search steps performed from --start-sense and -s.")), ToolInput(tag="in_simple_best_hit", input_type=Boolean(optional=True), prefix="--simple-best-hit", doc=InputDocumentation(doc="false           Update the e-value by the best p-value")), ToolInput(tag="in_sub_mat", input_type=File(optional=True), prefix="--sub-mat", doc=InputDocumentation(doc="blosum62.out    amino acid substitution matrix file")), ToolInput(tag="in_max_seq_len", input_type=Boolean(optional=True), prefix="--max-seq-len", doc=InputDocumentation(doc="65535           Maximum sequence length [1,32768]")), ToolInput(tag="in_max_seqs", input_type=Boolean(optional=True), prefix="--max-seqs", doc=InputDocumentation(doc="300             maximum result sequences per query (this parameter affects the sensitivity)")), ToolInput(tag="in_threads", input_type=Boolean(optional=True), prefix="--threads", doc=InputDocumentation(doc="8               number of cores used for the computation (uses all cores by default)")), ToolInput(tag="in_verbosity_level_nothing", input_type=Boolean(optional=True), prefix="-v", doc=InputDocumentation(doc="3               verbosity level: 0=nothing, 1: +errors, 2: +warnings, 3: +info"))], outputs=[ToolOutput(tag="out_sub_mat", output_type=File(optional=True), selector=InputSelector(input_to_select="in_sub_mat", type_hint=File()), doc=OutputDocumentation(doc="blosum62.out    amino acid substitution matrix file"))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Mmseqs_Multihitsearch_V0_1_0().translate("wdl", allow_empty_container=True)

