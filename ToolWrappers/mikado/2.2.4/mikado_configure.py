from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Int, Boolean, File, String, Directory

Mikado_Configure_V0_1_0 = CommandToolBuilder(tool="mikado_configure", base_command=["mikado", "configure"], inputs=[ToolInput(tag="in_full", input_type=Int(optional=True), prefix="--full", doc=InputDocumentation(doc="Random seed number. Default: 0.")), ToolInput(tag="in_random_seed", input_type=Boolean(optional=True), prefix="--random-seed", doc=InputDocumentation(doc="Generate a new random seed number (instead of the\ndefault of 0)")), ToolInput(tag="in_strand_specific", input_type=Boolean(optional=True), prefix="--strand-specific", doc=InputDocumentation(doc="Boolean flag indicating whether all the assemblies are")), ToolInput(tag="in_gff", input_type=File(optional=True), prefix="--gff", doc=InputDocumentation(doc="Input GFF/GTF file(s), separated by comma")), ToolInput(tag="in_list", input_type=Boolean(optional=True), prefix="--list", doc=InputDocumentation(doc="Tab-delimited file containing rows with the following\nformat: <file> <label> <strandedness(def. False)>\n<score(optional, def. 0)> <is_reference(optional, def.\nFalse)> <exclude_redundant(optional, def. True)>\n<strip_cds(optional, def. False)>\n<skip_split(optional, def. False)> 'strandedness',\n'is_reference', 'exclude_redundant', 'strip_cds' and\n'skip_split' must be boolean values (True, False)\n'score' must be a valid floating number.")), ToolInput(tag="in_reference", input_type=String(optional=True), prefix="--reference", doc=InputDocumentation(doc="Fasta genomic reference.")), ToolInput(tag="in_strand_specific_assemblies", input_type=String(optional=True), prefix="--strand-specific-assemblies", doc=InputDocumentation(doc="List of strand-specific assemblies among the inputs.")), ToolInput(tag="in_labels", input_type=String(optional=True), prefix="--labels", doc=InputDocumentation(doc="Labels to attach to the IDs of the transcripts of the\ninput files, separated by comma.")), ToolInput(tag="in_codon_table", input_type=Int(optional=True), prefix="--codon-table", doc=InputDocumentation(doc="Codon table to use. Default: 0 (ie Standard, NCBI #1,\nbut only ATG is considered a valid start codon.")), ToolInput(tag="in_external", input_type=File(optional=True), prefix="--external", doc=InputDocumentation(doc="External configuration file to overwrite/add values\nfrom. Parameters specified on the command line will\ntake precedence over those present in the\nconfiguration file.")), ToolInput(tag="in_skip_split", input_type=String(optional=True), prefix="--skip-split", doc=InputDocumentation(doc="List of labels for which splitting will be disabled\n(eg long reads such as PacBio)")), ToolInput(tag="in_json", input_type=File(optional=True), prefix="--json", doc=InputDocumentation(doc="Output will be in JSON (default: inferred by filename,\nwith TOML as fallback).")), ToolInput(tag="in_yaml", input_type=File(optional=True), prefix="--yaml", doc=InputDocumentation(doc="Output will be in YAML (default: inferred by filename,\nwith TOML as fallback).")), ToolInput(tag="in_to_ml", input_type=File(optional=True), prefix="--toml", doc=InputDocumentation(doc="Output will be in TOML (default: inferred by filename,\nwith TOML as fallback).")), ToolInput(tag="in_out_dir", input_type=Directory(optional=True), prefix="--out-dir", doc=InputDocumentation(doc="Destination directory for the output.")), ToolInput(tag="in_minimum_cdna_length", input_type=Int(optional=True), prefix="--minimum-cdna-length", doc=InputDocumentation(doc="Minimum cDNA length for transcripts.")), ToolInput(tag="in_max_intron_length", input_type=Int(optional=True), prefix="--max-intron-length", doc=InputDocumentation(doc="Maximum intron length for transcripts.")), ToolInput(tag="in_strip_faulty_cds", input_type=Boolean(optional=True), prefix="--strip-faulty-cds", doc=InputDocumentation(doc="Flag. If set, transcripts with an incorrect CDS will\nbe retained but with their CDS stripped. Default\nbehaviour: the whole transcript will be considered\ninvalid and discarded.")), ToolInput(tag="in_scoring", input_type=File(optional=True), prefix="--scoring", doc=InputDocumentation(doc="Scoring file to use. Mikado provides the following:\nplant.yaml, mammalian.yaml, HISTORIC/scerevisiae.yaml,\nHISTORIC/plant.yaml, HISTORIC/celegans_scoring.yaml,\nHISTORIC/mammalian.yaml,\nHISTORIC/athaliana_scoring.yaml, HISTORIC/human.yaml,\nHISTORIC/insects.yaml, HISTORIC/hsapiens_scoring.yaml,\nHISTORIC/dmelanogaster_scoring.yaml,\nHISTORIC/worm.yaml, HISTORIC/plants.yaml")), ToolInput(tag="in_copy_scoring", input_type=File(optional=True), prefix="--copy-scoring", doc=InputDocumentation(doc="File into which to copy the selected scoring file, for\nmodification.")), ToolInput(tag="in__intronrange_intronrange", input_type=Int(optional=True), prefix="-i", doc=InputDocumentation(doc="INTRON_RANGE, --intron-range INTRON_RANGE INTRON_RANGE\nRange into which intron lengths should fall, as a\ncouple of integers. Transcripts with intron lengths\noutside of this range will be penalised. Default: (60,\n900)")), ToolInput(tag="in_subloc_i_out", input_type=String(optional=True), prefix="--subloci-out", doc=InputDocumentation(doc="Name of the optional subloci output. By default, this\nwill not be produced.")), ToolInput(tag="in_mono_loci_out", input_type=String(optional=True), prefix="--monoloci-out", doc=InputDocumentation(doc="Name of the optional monoloci output. By default, this\nwill not be produced.")), ToolInput(tag="in_no_pad", input_type=Boolean(optional=True), prefix="--no-pad", doc=InputDocumentation(doc="Disable transcript padding. On by default.")), ToolInput(tag="in_reference_update", input_type=Boolean(optional=True), prefix="--reference-update", doc=InputDocumentation(doc="Flag. If switched on, Mikado will prioritise\ntranscripts marked as reference and will consider any\nother transcipt within loci only in reference to these\nreference transcripts. Novel loci will still be\nreported.")), ToolInput(tag="in_only_reference_update", input_type=Boolean(optional=True), prefix="--only-reference-update", doc=InputDocumentation(doc="Flag. If switched on, Mikado will only keep loci where\nat least one of the transcripts is marked as\n'reference'. CAUTION: if no transcript has been marked\nas reference, the output will be completely empty!")), ToolInput(tag="in_exclude_retained_introns", input_type=Boolean(optional=True), prefix="--exclude-retained-introns", doc=InputDocumentation(doc="Exclude all retained intron alternative splicing\nevents from the final output. Default: False. Retained\nintron events that do not dirsupt the CDS are kept by\nMikado in the final output.")), ToolInput(tag="in_keep_disrupted_cds", input_type=Boolean(optional=True), prefix="--keep-disrupted-cds", doc=InputDocumentation(doc="Keep in the final output transcripts whose CDS is most\nprobably disrupted by a retained intron event.\nDefault: False. Mikado will try to detect these\ninstances and exclude them from the final output.")), ToolInput(tag="in_check_references", input_type=Boolean(optional=True), prefix="--check-references", doc=InputDocumentation(doc="Flag. If switched on, Mikado will also check reference\nmodels against the general transcript requirements,\nand will also consider them as potential fragments.\nThis is useful in the context of e.g. updating an *ab-\ninitio* results with data from RNASeq, protein\nalignments, etc.")), ToolInput(tag="in_min_clustering_cdna_overlap", input_type=Int(optional=True), prefix="--min-clustering-cdna-overlap", doc=InputDocumentation(doc="Minimum cDNA overlap between two transcripts for them\nto be considered part of the same locus during the\nlate picking stages. NOTE: if --min-cds-overlap is not\nspecified, it will be set to this value! Default: 20%.")), ToolInput(tag="in_min_clustering_cds_overlap", input_type=Int(optional=True), prefix="--min-clustering-cds-overlap", doc=InputDocumentation(doc="Minimum CDS overlap between two transcripts for them\nto be considered part of the same locus during the\nlate picking stages. NOTE: if not specified, and\n--min-cdna-overlap is specified on the command line,\nmin-cds-overlap will be set to this value! Default:\n20%.")), ToolInput(tag="in_report_all_orfs", input_type=Boolean(optional=True), prefix="--report-all-orfs", doc=InputDocumentation(doc="Boolean switch. If set to true, all ORFs will be\nreported, not just the primary.")), ToolInput(tag="in_report_all_external_metrics", input_type=Boolean(optional=True), prefix="--report-all-external-metrics", doc=InputDocumentation(doc="Boolean switch. If activated, Mikado will report all\navailable external metrics, not just those requested\nfor in the scoring configuration. This might affect\nspeed in Minos analyses.")), ToolInput(tag="in_cds_only", input_type=Boolean(optional=True), prefix="--cds-only", doc=InputDocumentation(doc="'Flag. If set, Mikado will only look for overlap in\nthe coding features when clustering transcripts\n(unless one transcript is non-coding, in which case\nthe whole transcript will be considered). Please note\nthat Mikado will only consider the **best** ORF for\nthis. Default: False, Mikado will consider transcripts\nin their entirety.")), ToolInput(tag="in_as_cds_only", input_type=Boolean(optional=True), prefix="--as-cds-only", doc=InputDocumentation(doc="Flag. If set, Mikado will only consider the CDS to\ndetermine whether a transcript is a valid alternative\nsplicing event in a locus.")), ToolInput(tag="in_dai_jin", input_type=Boolean(optional=True), prefix="--daijin", doc=InputDocumentation(doc="Flag. If set, the configuration file will be also\nvalid for Daijin.")), ToolInput(tag="in_blast_chunks", input_type=Int(optional=True), prefix="--blast-chunks", doc=InputDocumentation(doc="Number of parallel DIAMOND/BLAST jobs to run. Default:\n10.")), ToolInput(tag="in_use_blast", input_type=Boolean(optional=True), prefix="--use-blast", doc=InputDocumentation(doc="Flag. If switched on, Mikado will use BLAST instead of")), ToolInput(tag="in_mode", input_type=String(optional=True), prefix="--mode", doc=InputDocumentation(doc="[{nosplit,stringent,lenient,permissive,split} ...]\nMode(s) in which Mikado will treat transcripts with\nmultiple ORFs. - nosplit: keep the transcripts whole.\n- stringent: split multi-orf transcripts if two\nconsecutive ORFs have both BLAST hits and none of\nthose hits is against the same target. - lenient:\nsplit multi-orf transcripts as in stringent, and\nadditionally, also when either of the ORFs lacks a\nBLAST hit (but not both). - permissive: like lenient,\nbut also split when both ORFs lack BLAST hits - split:\nsplit multi-orf transcripts regardless of what BLAST\ndata is available. If multiple modes are specified,\nMikado will create a Daijin-compatible configuration\nfile.")), ToolInput(tag="in_scheduler", input_type=String(optional=True), prefix="--scheduler", doc=InputDocumentation(doc="Scheduler to use. Default: None - ie, either execute\neverything on the local machine or use DRMAA to submit\nand control jobs (recommended).")), ToolInput(tag="in_exe", input_type=File(optional=True), prefix="--exe", doc=InputDocumentation(doc="Configuration file for the executables.")), ToolInput(tag="in_cluster_config", input_type=File(optional=True), prefix="--cluster_config", doc=InputDocumentation(doc="Cluster configuration file to write to.\n")), ToolInput(tag="in_out", input_type=String(), position=0, doc=InputDocumentation(doc="optional arguments:")), ToolInput(tag="in_strand_specific_dot", input_type=String(), position=1, doc=InputDocumentation(doc="--no-files            Remove all files-specific options from the printed")), ToolInput(tag="in_diamond_dot", input_type=String(), position=0, doc=InputDocumentation(doc="--use-transdecoder    Flag. If switched on, Mikado will use TransDecoder"))], outputs=[ToolOutput(tag="out_json", output_type=File(optional=True), selector=InputSelector(input_to_select="in_json", type_hint=File()), doc=OutputDocumentation(doc="Output will be in JSON (default: inferred by filename,\nwith TOML as fallback).")), ToolOutput(tag="out_yaml", output_type=File(optional=True), selector=InputSelector(input_to_select="in_yaml", type_hint=File()), doc=OutputDocumentation(doc="Output will be in YAML (default: inferred by filename,\nwith TOML as fallback).")), ToolOutput(tag="out_to_ml", output_type=File(optional=True), selector=InputSelector(input_to_select="in_to_ml", type_hint=File()), doc=OutputDocumentation(doc="Output will be in TOML (default: inferred by filename,\nwith TOML as fallback).")), ToolOutput(tag="out_out_dir", output_type=Directory(optional=True), selector=InputSelector(input_to_select="in_out_dir", type_hint=File()), doc=OutputDocumentation(doc="Destination directory for the output."))], container="quay.io/biocontainers/mikado:2.2.4--py38h803c66d_0", version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Mikado_Configure_V0_1_0().translate("wdl")

