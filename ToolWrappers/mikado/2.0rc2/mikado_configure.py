from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Int, Boolean, File, String, Directory

Mikado_Configure_V0_1_0 = CommandToolBuilder(tool="mikado_configure", base_command=["mikado", "configure"], inputs=[ToolInput(tag="in_full", input_type=Int(optional=True), prefix="--full", doc=InputDocumentation(doc="Random seed number.")), ToolInput(tag="in_strand_specific", input_type=Boolean(optional=True), prefix="--strand-specific", doc=InputDocumentation(doc="Boolean flag indicating whether all the assemblies are strand-specific.")), ToolInput(tag="in_no_files", input_type=Boolean(optional=True), prefix="--no-files", doc=InputDocumentation(doc="Remove all files-specific options from the printed configuration file.\nInvoking the '--gff' option will disable this flag.")), ToolInput(tag="in_gff", input_type=File(optional=True), prefix="--gff", doc=InputDocumentation(doc="Input GFF/GTF file(s), separated by comma")), ToolInput(tag="in_list", input_type=Boolean(optional=True), prefix="--list", doc=InputDocumentation(doc="Tab-delimited file containing rows with the following format:\n<file>  <label> <strandedness> <score(optional)> <is_reference(optional)> <always_keep(optional)\nstrandedness, is_reference and always_keep must be boolean values (True, False)\nscore must be a valid floating number.")), ToolInput(tag="in_reference", input_type=String(optional=True), prefix="--reference", doc=InputDocumentation(doc="Fasta genomic reference.")), ToolInput(tag="in_strand_specific_assemblies", input_type=String(optional=True), prefix="--strand-specific-assemblies", doc=InputDocumentation(doc="List of strand-specific assemblies among the inputs.")), ToolInput(tag="in_labels", input_type=String(optional=True), prefix="--labels", doc=InputDocumentation(doc="Labels to attach to the IDs of the transcripts of the input files,\nseparated by comma.")), ToolInput(tag="in_external", input_type=File(optional=True), prefix="--external", doc=InputDocumentation(doc="External configuration file to overwrite/add values from.\nParameters specified on the command line will take precedence over those present in the configuration file.")), ToolInput(tag="in_skip_split", input_type=String(optional=True), prefix="--skip-split", doc=InputDocumentation(doc="List of labels for which splitting will be disabled (eg long reads such as PacBio)")), ToolInput(tag="in_json", input_type=File(optional=True), prefix="--json", doc=InputDocumentation(doc="Output will be in JSON (default: inferred by filename, with TOML as fallback).")), ToolInput(tag="in_yaml", input_type=File(optional=True), prefix="--yaml", doc=InputDocumentation(doc="Output will be in YAML (default: inferred by filename, with TOML as fallback).")), ToolInput(tag="in_to_ml", input_type=File(optional=True), prefix="--toml", doc=InputDocumentation(doc="Output will be in TOML (default: inferred by filename, with TOML as fallback).")), ToolInput(tag="in_out_dir", input_type=Directory(optional=True), prefix="--out-dir", doc=InputDocumentation(doc="Destination directory for the output.")), ToolInput(tag="in_minimum_cdna_length", input_type=Int(optional=True), prefix="--minimum-cdna-length", doc=InputDocumentation(doc="Minimum cDNA length for transcripts.")), ToolInput(tag="in_max_intron_length", input_type=Int(optional=True), prefix="--max-intron-length", doc=InputDocumentation(doc="Maximum intron length for transcripts.")), ToolInput(tag="in_scoring", input_type=File(optional=True), prefix="--scoring", doc=InputDocumentation(doc="Scoring file to use. Mikado provides the following:\nmammalian.yaml,\nplant.yaml,\nHISTORIC/worm.yaml,\nHISTORIC/athaliana_scoring.yaml,\nHISTORIC/scerevisiae.yaml,\nHISTORIC/celegans_scoring.yaml,\nHISTORIC/insects.yaml,\nHISTORIC/human.yaml,\nHISTORIC/hsapiens_scoring.yaml,\nHISTORIC/dmelanogaster_scoring.yaml,\nHISTORIC/plants.yaml")), ToolInput(tag="in_copy_scoring", input_type=File(optional=True), prefix="--copy-scoring", doc=InputDocumentation(doc="File into which to copy the selected scoring file, for modification.")), ToolInput(tag="in__intronrange_intronrange", input_type=Int(optional=True), prefix="-i", doc=InputDocumentation(doc="INTRON_RANGE, --intron-range INTRON_RANGE INTRON_RANGE\nRange into which intron lengths should fall, as a couple of integers.\nTranscripts with intron lengths outside of this range will be penalised.\nDefault: (60, 900)")), ToolInput(tag="in_subloc_i_out", input_type=String(optional=True), prefix="--subloci-out", doc=InputDocumentation(doc="Name of the optional subloci output. By default, this will not be produced.")), ToolInput(tag="in_mono_loci_out", input_type=String(optional=True), prefix="--monoloci-out", doc=InputDocumentation(doc="Name of the optional monoloci output. By default, this will not be produced.")), ToolInput(tag="in_no_pad", input_type=Boolean(optional=True), prefix="--no-pad", doc=InputDocumentation(doc="Disable transcript padding. On by default.")), ToolInput(tag="in_only_reference_update", input_type=Boolean(optional=True), prefix="--only-reference-update", doc=InputDocumentation(doc="Flag. If switched on, Mikado will only keep loci where at least one of the transcripts     is marked as 'reference'. CAUTION: new and experimental. If no transcript has been marked as reference,     the output will be completely empty!")), ToolInput(tag="in_exclude_retained_introns", input_type=Boolean(optional=True), prefix="--exclude-retained-introns", doc=InputDocumentation(doc="Exclude all retained intron alternative splicing events from the final output. Default: False. Retained intron events that do not dirsupt the CDS are kept by Mikado in the final output.")), ToolInput(tag="in_keep_disrupted_cds", input_type=Boolean(optional=True), prefix="--keep-disrupted-cds", doc=InputDocumentation(doc="Keep in the final output transcripts whose CDS is most probably disrupted by a retained intron event. Default: False. Mikado will try to detect these instances and exclude them from the final output.")), ToolInput(tag="in_check_references", input_type=Boolean(optional=True), prefix="--check-references", doc=InputDocumentation(doc="Flag. If switched on, Mikado will also check reference models against the general\ntranscript requirements, and will also consider them as potential fragments. This is useful in the context of e.g.\nupdating an *ab-initio* results with data from RNASeq, protein alignments, etc.")), ToolInput(tag="in_dai_jin", input_type=Boolean(optional=True), prefix="--daijin", doc=InputDocumentation(doc="Flag. If set, the configuration file will be also valid for Daijin.")), ToolInput(tag="in_blast_chunks", input_type=Int(optional=True), prefix="--blast-chunks", doc=InputDocumentation(doc="Number of parallel DIAMOND/BLAST jobs to run. Default: 10.")), ToolInput(tag="in_use_blast", input_type=Boolean(optional=True), prefix="--use-blast", doc=InputDocumentation(doc="Flag. If switched on, Mikado will use BLAST instead of DIAMOND.")), ToolInput(tag="in_use_trans_decoder", input_type=Boolean(optional=True), prefix="--use-transdecoder", doc=InputDocumentation(doc="Flag. If switched on, Mikado will use TransDecoder instead of Prodigal.")), ToolInput(tag="in_mode", input_type=String(optional=True), prefix="--mode", doc=InputDocumentation(doc="[{nosplit,stringent,lenient,permissive,split} ...]\nMode(s) in which Mikado will treat transcripts with multiple ORFs.\n- nosplit: keep the transcripts whole.\n- stringent: split multi-orf transcripts if two consecutive ORFs have both BLAST hits\nand none of those hits is against the same target.\n- lenient: split multi-orf transcripts as in stringent, and additionally, also when\neither of the ORFs lacks a BLAST hit (but not both).\n- permissive: like lenient, but also split when both ORFs lack BLAST hits\n- split: split multi-orf transcripts regardless of what BLAST data is available.\nIf multiple modes are specified, Mikado will create a Daijin-compatible configuration file.")), ToolInput(tag="in_scheduler", input_type=String(optional=True), prefix="--scheduler", doc=InputDocumentation(doc="Scheduler to use. Default: None - ie, either execute everything on the local machine or use DRMAA to submit and control jobs (recommended).")), ToolInput(tag="in_exe", input_type=File(optional=True), prefix="--exe", doc=InputDocumentation(doc="Configuration file for the executables.")), ToolInput(tag="in_cluster_config", input_type=File(optional=True), prefix="--cluster_config", doc=InputDocumentation(doc="Cluster configuration file to write to.\n")), ToolInput(tag="in_out", input_type=String(), position=0, doc=InputDocumentation(doc="optional arguments:"))], outputs=[ToolOutput(tag="out_json", output_type=File(optional=True), selector=InputSelector(input_to_select="in_json", type_hint=File()), doc=OutputDocumentation(doc="Output will be in JSON (default: inferred by filename, with TOML as fallback).")), ToolOutput(tag="out_yaml", output_type=File(optional=True), selector=InputSelector(input_to_select="in_yaml", type_hint=File()), doc=OutputDocumentation(doc="Output will be in YAML (default: inferred by filename, with TOML as fallback).")), ToolOutput(tag="out_to_ml", output_type=File(optional=True), selector=InputSelector(input_to_select="in_to_ml", type_hint=File()), doc=OutputDocumentation(doc="Output will be in TOML (default: inferred by filename, with TOML as fallback).")), ToolOutput(tag="out_out_dir", output_type=Directory(optional=True), selector=InputSelector(input_to_select="in_out_dir", type_hint=File()), doc=OutputDocumentation(doc="Destination directory for the output."))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Mikado_Configure_V0_1_0().translate("wdl", allow_empty_container=True)

