from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean

Cactus_Caf_V0_1_0 = CommandToolBuilder(tool="cactus_caf", base_command=["cactus_caf"], inputs=[ToolInput(tag="in_loglevel", input_type=Boolean(optional=True), prefix="--logLevel", doc=InputDocumentation(doc=": Set the log level")), ToolInput(tag="in_alignments", input_type=Boolean(optional=True), prefix="--alignments", doc=InputDocumentation(doc=": The input alignments file")), ToolInput(tag="in_cactus_disk", input_type=Boolean(optional=True), prefix="--cactusDisk", doc=InputDocumentation(doc=": The location of the flower disk directory")), ToolInput(tag="in_last_z_arguments", input_type=Boolean(optional=True), prefix="--lastzArguments", doc=InputDocumentation(doc=": Lastz arguments")), ToolInput(tag="in_annealing_rounds", input_type=Boolean(optional=True), prefix="--annealingRounds", doc=InputDocumentation(doc="(array of ints, each greater than or equal to 1) : The rounds of annealing")), ToolInput(tag="in_de_annealing_rounds", input_type=Boolean(optional=True), prefix="--deannealingRounds", doc=InputDocumentation(doc="(array of ints, each greater than or equal to 1 and each greater than the last) : The rounds of deannealing")), ToolInput(tag="in_trim", input_type=Boolean(optional=True), prefix="--trim", doc=InputDocumentation(doc="(array of integers, each greater or equal to zero) : An array giving the trim for each annealing round. If the array is shorter than the annealing rounds then a trim value of 0 is assumed for annealing rounds greater than the length of the trim array")), ToolInput(tag="in_minimum_tree_coverage", input_type=Boolean(optional=True), prefix="--minimumTreeCoverage", doc=InputDocumentation(doc=": (float [0.0, 1.0]) Minimum tree coverage proportion of a block to be included in the graph")), ToolInput(tag="in_block_trim", input_type=Boolean(optional=True), prefix="--blockTrim", doc=InputDocumentation(doc=": (int >= 0) The number of bases to trim from the ends of each block in a chain before accepting, this filtering is done after choosing the length of chains")), ToolInput(tag="in_minimum_degree", input_type=Boolean(optional=True), prefix="--minimumDegree", doc=InputDocumentation(doc=": (int >= 0) Minimum number of sequences in a block to be included in the output graph")), ToolInput(tag="in_minimum_in_group_degree", input_type=Boolean(optional=True), prefix="--minimumIngroupDegree", doc=InputDocumentation(doc=": Number of ingroup sequences required in a block.")), ToolInput(tag="in_minimum_out_group_degree", input_type=Boolean(optional=True), prefix="--minimumOutgroupDegree", doc=InputDocumentation(doc=": Number of outgroup sequences required in a block.")), ToolInput(tag="in_alignment_filter", input_type=Boolean(optional=True), prefix="--alignmentFilter", doc=InputDocumentation(doc=": Choose alignment filter:\nnone: no filtering,\nsingleCopyOutgroup: never merge two outgroup segments together\nrelaxedSingleCopyOutgroup: never merge two outgroup segments together if they are both already aligned to something else\nsingleCopy: Never align two segments from the same genome together\nrelaxedSingleCopy: Never align two segments from the same genome together if they are both already aligned to something else\nfilterSecondariesByMultipleSpecies: Apply no filtering to primary alignments, for secondary alignments do not sort them and filter them so that no two blocks are merged that each already contain multiple species.")), ToolInput(tag="in_minimum_sequence_length_for_blast", input_type=Boolean(optional=True), prefix="--minimumSequenceLengthForBlast", doc=InputDocumentation(doc=": The minimum length of a sequence to include when blasting")), ToolInput(tag="in_max_adjacency_component_size_ratio", input_type=Boolean(optional=True), prefix="--maxAdjacencyComponentSizeRatio", doc=InputDocumentation(doc=": The components equal or less than log(n) * of this size will be allowed in the cactus. Used to fight giant components.")), ToolInput(tag="in_constraints", input_type=Boolean(optional=True), prefix="--constraints", doc=InputDocumentation(doc=": A file of alignments that will be enforced upon the cactus")), ToolInput(tag="in_minlength_for_chromosome", input_type=Boolean(optional=True), prefix="--minLengthForChromosome", doc=InputDocumentation(doc=": The minimum length required for a sequence to be considered as a candidate to be chromosome.")), ToolInput(tag="in_proportion_of_unaligned_bases_for_new_chromosome", input_type=Boolean(optional=True), prefix="--proportionOfUnalignedBasesForNewChromosome", doc=InputDocumentation(doc=": Proportion of aligned bases to be not contained in an existing chromosome to cause generation of a new chromosome.")), ToolInput(tag="in_maximum_median_sequence_length_between_linked_ends", input_type=Boolean(optional=True), prefix="--maximumMedianSequenceLengthBetweenLinkedEnds", doc=InputDocumentation(doc=": Maximum nedian length of sequences between linked ends to allow before breaking chains.")), ToolInput(tag="in_realign", input_type=Boolean(optional=True), prefix="--realign", doc=InputDocumentation(doc=": Realign the lastz hits.")), ToolInput(tag="in_realign_arguments", input_type=Boolean(optional=True), prefix="--realignArguments", doc=InputDocumentation(doc=": Arguments for realignment.")), ToolInput(tag="in_phylogeny_num_trees", input_type=Boolean(optional=True), prefix="--phylogenyNumTrees", doc=InputDocumentation(doc=": Number of trees to sample when removing ancient homologies. (default 1)")), ToolInput(tag="in_phylogeny_rooting_method", input_type=Boolean(optional=True), prefix="--phylogenyRootingMethod", doc=InputDocumentation(doc=": Method of rooting trees: either 'outgroupBranch', 'longestBranch', or 'bestRecon' (default outgroupBranch).")), ToolInput(tag="in_phylogeny_scoring_method", input_type=Boolean(optional=True), prefix="--phylogenyScoringMethod", doc=InputDocumentation(doc=": Method of deciding which sampled tree is best: either 'reconCost' or .")), ToolInput(tag="in_phylogeny_breakpoint_scaling_factor", input_type=Boolean(optional=True), prefix="--phylogenyBreakpointScalingFactor", doc=InputDocumentation(doc=": scale breakpoint distance by this factor while building phylogenies. Default 0.0.")), ToolInput(tag="in_phylogeny_skip_single_copy_blocks", input_type=Boolean(optional=True), prefix="--phylogenySkipSingleCopyBlocks", doc=InputDocumentation(doc=": Skip building trees for single-copy blocks. Default is not to skip.")), ToolInput(tag="in_phylogeny_max_base_distance", input_type=Boolean(optional=True), prefix="--phylogenyMaxBaseDistance", doc=InputDocumentation(doc=": maximum distance in bases to walk outside of a block gathering feature columns")), ToolInput(tag="in_phylogeny_max_block_distance", input_type=Boolean(optional=True), prefix="--phylogenyMaxBlockDistance", doc=InputDocumentation(doc=": maximum distance in blocks to walk outside of a block gathering feature columns")), ToolInput(tag="in_phylogeny_debug_file", input_type=Boolean(optional=True), prefix="--phylogenyDebugFile", doc=InputDocumentation(doc=": path to file to dump block trees and partitions to")), ToolInput(tag="in_phylogeny_keep_single_degree_blocks", input_type=Boolean(optional=True), prefix="--phylogenyKeepSingleDegreeBlocks", doc=InputDocumentation(doc=": when splitting blocks, allow blocks to be created of only one ingroup.")), ToolInput(tag="in_phylogeny_tree_building_method", input_type=Boolean(optional=True), prefix="--phylogenyTreeBuildingMethod", doc=InputDocumentation(doc=": neighbor joining or neighbor-joining guided by the species tree")), ToolInput(tag="in_reference_event_header", input_type=Boolean(optional=True), prefix="--referenceEventHeader", doc=InputDocumentation(doc=": name of reference event (necessary for phylogeny estimation)")), ToolInput(tag="in_phylogeny_do_splits_with_support_higher_than_this_all_at_once", input_type=Boolean(optional=True), prefix="--phylogenyDoSplitsWithSupportHigherThanThisAllAtOnce", doc=InputDocumentation(doc=": assume that this support value or greater means a very confident split, and that they will not be changed by the greedy split algorithm. Do all these very confident splits at once, to save a lot of computation time.")), ToolInput(tag="in_num_tree_building_threads", input_type=Boolean(optional=True), prefix="--numTreeBuildingThreads", doc=InputDocumentation(doc=": Number of threads in the tree-building thread pool. Must be greater than 1. Default 2.")), ToolInput(tag="in_phylogeny", input_type=Boolean(optional=True), prefix="--phylogeny", doc=InputDocumentation(doc=": Run the tree-building code and split ancient homologies away.")), ToolInput(tag="in_minimum_block_homology_support", input_type=Boolean(optional=True), prefix="--minimumBlockHomologySupport", doc=InputDocumentation(doc=": Minimum fraction of possible homologies required not to be considered a transitively collapsed megablock.")), ToolInput(tag="in_phylogeny_nucleotide_scaling_factor", input_type=Boolean(optional=True), prefix="--phylogenyNucleotideScalingFactor", doc=InputDocumentation(doc=": Weighting for the nucleotide information in the distance matrix used to build each tree.")), ToolInput(tag="in_minimum_block_degree_to_check_support", input_type=Boolean(optional=True), prefix="--minimumBlockDegreeToCheckSupport", doc=InputDocumentation(doc=": Minimum degree required to be checked for being a megablock."))], outputs=[], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Cactus_Caf_V0_1_0().translate("wdl", allow_empty_container=True)

