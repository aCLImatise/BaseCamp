from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import File, Boolean, Int, Float

Ribotricer_Detect_Orfs_V0_1_0 = CommandToolBuilder(tool="ribotricer_detect_orfs", base_command=["ribotricer", "detect-orfs"], inputs=[ToolInput(tag="in_bam", input_type=File(optional=True), prefix="--bam", doc=InputDocumentation(doc="Path to BAM file  [required]")), ToolInput(tag="in_ribot_ricer_index", input_type=File(optional=True), prefix="--ribotricer_index", doc=InputDocumentation(doc="Path to the index file of ribotricer This\nfile should be generated using ribotricer\nprepare-orfs  [required]")), ToolInput(tag="in_prefix", input_type=File(optional=True), prefix="--prefix", doc=InputDocumentation(doc="Prefix to output file  [required]")), ToolInput(tag="in_stranded", input_type=Boolean(optional=True), prefix="--stranded", doc=InputDocumentation(doc="[yes|no|reverse]     whether the data is from a strand-specific\nassay If not provided, the experimental\nprotocol will be automatically inferred")), ToolInput(tag="in_read_lengths", input_type=Int(optional=True), prefix="--read_lengths", doc=InputDocumentation(doc="Comma separated read lengths to be used,\nsuch as 28,29,30 If not provided, it will be\nautomatically determined by assessing the\nmetagene periodicity")), ToolInput(tag="in_p_site_offsets", input_type=Int(optional=True), prefix="--psite_offsets", doc=InputDocumentation(doc="Comma separated P-site offsets for each read\nlength matching the read lengths provided.\nIf not provided, reads from different read\nlengths will be automatically aligned using\ncross-correlation")), ToolInput(tag="in_phase_score_cut_off", input_type=Float(optional=True), prefix="--phase_score_cutoff", doc=InputDocumentation(doc="Phase score cutoff for determining active")), ToolInput(tag="in_min_valid_codons", input_type=Int(optional=True), prefix="--min_valid_codons", doc=InputDocumentation(doc="Minimum number of codons with non-zero reads\nfor determining active translation\n[default: 5]")), ToolInput(tag="in_min_reads_per_codon", input_type=Int(optional=True), prefix="--min_reads_per_codon", doc=InputDocumentation(doc="Minimum number of reads per codon for\ndetermining active translation  [default: 0]")), ToolInput(tag="in_min_valid_codons_ratio", input_type=Float(optional=True), prefix="--min_valid_codons_ratio", doc=InputDocumentation(doc="Minimum ratio of codons with non-zero reads\nto total codons for determining active\ntranslation  [default: 0]")), ToolInput(tag="in_min_read_density", input_type=Float(optional=True), prefix="--min_read_density", doc=InputDocumentation(doc="Minimum read density (total_reads/length)\nover an ORF total codons for determining\nactive translation  [default: 0.0]")), ToolInput(tag="in_report_all", input_type=Boolean(optional=True), prefix="--report_all", doc=InputDocumentation(doc="Whether output all ORFs including those non-\ntranslating ones"))], outputs=[ToolOutput(tag="out_prefix", output_type=File(optional=True), selector=InputSelector(input_to_select="in_prefix", type_hint=File()), doc=OutputDocumentation(doc="Prefix to output file  [required]"))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Ribotricer_Detect_Orfs_V0_1_0().translate("wdl", allow_empty_container=True)

