from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean, File

Filter_Vep_V0_1_0 = CommandToolBuilder(tool="filter_vep", base_command=["filter_vep"], inputs=[ToolInput(tag="in_input_file", input_type=Boolean(optional=True), prefix="--input_file", doc=InputDocumentation(doc="[file]  -i   Specify the input file (i.e. the VEP results file).\nIf no input file is specified, the script will\nattempt to read from STDIN. Input may be gzipped - to\nforce the script to read a file as gzipped, use --gz")), ToolInput(tag="in_format", input_type=Boolean(optional=True), prefix="--format", doc=InputDocumentation(doc="[vcf|tab]        Specify input file format (tab for any tab-delimited\nformat, including default VEP output format)")), ToolInput(tag="in_output_file", input_type=File(optional=True), prefix="--output_file", doc=InputDocumentation(doc="[file] -o   Specify the output file to write to. If no output file\nis specified, the script will write to STDOUT")), ToolInput(tag="in_force_overwrite", input_type=File(optional=True), prefix="--force_overwrite", doc=InputDocumentation(doc="Force the script to overwrite the output file if it\nalready exists")), ToolInput(tag="in_filter", input_type=Boolean(optional=True), prefix="--filter", doc=InputDocumentation(doc="[filters]   -f   Add filter. Multiple --filter flags may be used, and\nare treated as logical ANDs, i.e. all filters must\npass for a line to be printed")), ToolInput(tag="in_list", input_type=Boolean(optional=True), prefix="--list", doc=InputDocumentation(doc="List allowed fields from the input file")), ToolInput(tag="in_count", input_type=Boolean(optional=True), prefix="--count", doc=InputDocumentation(doc="Print only a count of matched lines")), ToolInput(tag="in_only_matched", input_type=Boolean(optional=True), prefix="--only_matched", doc=InputDocumentation(doc="In VCF files, the CSQ field that contains the\nconsequence data will often contain more than one\n'block' of consequence data, where each block\ncorresponds to a variant/feature overlap. Using\n--only_matched will remove blocks that do not pass the\nfilters. By default, the script prints out the entire\nVCF line if any of the blocks pass the filters.")), ToolInput(tag="in_vcf_info_field", input_type=Boolean(optional=True), prefix="--vcf_info_field", doc=InputDocumentation(doc="[key]    With VCF input files, by default filter_vep expects to\nfind VEP annotations encoded in the CSQ INFO key; VEP\nitself can be configured to write to a different key\n(with the equivalent --vcf_info_field flag). Use this\nflag to change the INFO key VEP expects to decode.")), ToolInput(tag="in_ontology", input_type=Boolean(optional=True), prefix="--ontology", doc=InputDocumentation(doc="Use Sequence Ontology to match consequence terms. Use\nwith operator 'is' to match against all child terms of\nyour value.\ne.g. 'Consequence is coding_sequence_variant' will\nmatch missense_variant, synonymous_variant etc.\nRequires database connection; defaults to connecting\nto ensembldb.ensembl.org. Use --host, --port, --user,\n--password, --version as per ./vep to change\nconnection parameters.\n"))], outputs=[ToolOutput(tag="out_output_file", output_type=File(optional=True), selector=InputSelector(input_to_select="in_output_file", type_hint=File()), doc=OutputDocumentation(doc="[file] -o   Specify the output file to write to. If no output file\nis specified, the script will write to STDOUT")), ToolOutput(tag="out_force_overwrite", output_type=File(optional=True), selector=InputSelector(input_to_select="in_force_overwrite", type_hint=File()), doc=OutputDocumentation(doc="Force the script to overwrite the output file if it\nalready exists"))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Filter_Vep_V0_1_0().translate("wdl", allow_empty_container=True)

