from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Int, File, String, Boolean

Svim_Asm_Haploid_V0_1_0 = CommandToolBuilder(tool="svim_asm_haploid", base_command=["svim-asm", "haploid"], inputs=[ToolInput(tag="in_min_mapq", input_type=Int(optional=True), prefix="--min_mapq", doc=InputDocumentation(doc="Minimum mapping quality of alignments to consider\n(default: 20). Alignments with a lower mapping quality\nare ignored.")), ToolInput(tag="in_min_sv_size", input_type=Int(optional=True), prefix="--min_sv_size", doc=InputDocumentation(doc="Minimum SV size to detect (default: 40). SVIM can\npotentially detect events of any size but is limited\nby the signal-to-noise ratio in the input alignments.\nThat means that more accurate assemblies and\nalignments enable the detection of smaller events.")), ToolInput(tag="in_max_sv_size", input_type=Int(optional=True), prefix="--max_sv_size", doc=InputDocumentation(doc="Maximum SV size to detect (default: 100000). This\nparameter is used to distinguish long deletions (and\ninversions) from translocations which cannot be\ndistinguished from the alignment alone. Split read\nsegments mapping far apart on the reference could\neither indicate a very long deletion (inversion) or a\ntranslocation breakpoint. SVIM calls a translocation\nbreakpoint if the mapping distance is larger than this\nparameter and a deletion (or inversion) if it is\nsmaller or equal.")), ToolInput(tag="in_query_gap_tolerance", input_type=Int(optional=True), prefix="--query_gap_tolerance", doc=InputDocumentation(doc="Maximum tolerated gap between adjacent alignment\nsegments on the query (default: 50). Example:\nDeletions are detected from two subsequent segments of\na split query sequence that are mapped far apart from\neach other on the reference. The query gap tolerance\ndetermines the maximum tolerated length of the query\ngap between both segments. If there is an unaligned\nquery segment larger than this value between the two\nsegments, no deletion is called.")), ToolInput(tag="in_query_overlap_tolerance", input_type=Int(optional=True), prefix="--query_overlap_tolerance", doc=InputDocumentation(doc="Maximum tolerated overlap between adjacent alignment\nsegments on the query (default: 50). Example:\nDeletions are detected from two subsequent segments of\na split query sequence that are mapped far apart from\neach other on the reference. The query overlap\ntolerance determines the maximum tolerated length of\nan overlap between both segments in the query. If the\noverlap between the two segments in the query is\nlarger than this value, no deletion is called.")), ToolInput(tag="in_reference_gap_tolerance", input_type=Int(optional=True), prefix="--reference_gap_tolerance", doc=InputDocumentation(doc="Maximum tolerated gap between adjacent alignment\nsegments on the reference (default: 50). Example:\nInsertions are detected from two segments of a split\nquery sequence that are mapped right next to each\nother on the reference but with unaligned sequence\nbetween them on the query. The reference gap tolerance\ndetermines the maximum tolerated length of the\nreference gap between both segments. If there is a\nreference gap larger than this value between the two\nsegments, no insertion is called.")), ToolInput(tag="in_reference_overlap_tolerance", input_type=Int(optional=True), prefix="--reference_overlap_tolerance", doc=InputDocumentation(doc="Maximum tolerated overlap between adjacent alignment\nsegments on the reference (default: 50). Example:\nInsertions are detected from two segments of a split\nquery sequence that are mapped right next to each\nother on the reference but with unaligned sequence\nbetween them on the query. The reference overlap\ntolerance determines the maximum tolerated length of\nan overlap between both segments on the reference. If\nthere is a reference gap larger than this value\nbetween the two segments, no insertion is called.")), ToolInput(tag="in_sample", input_type=File(optional=True), prefix="--sample", doc=InputDocumentation(doc="Sample ID to include in output vcf file (default:\nSample)")), ToolInput(tag="in_types", input_type=String(optional=True), prefix="--types", doc=InputDocumentation(doc="SV types to include in output VCF (default:\nDEL,INS,INV,DUP_TAN,DUP_INT,BND). Give a comma-\nseparated list of SV types. The possible SV types are:\nDEL (deletions), INS (novel insertions), INV\n(inversions), DUP_TAN (tandem duplications), DUP_INT\n(interspersed duplications), BND (breakends).")), ToolInput(tag="in_symbolic_alleles", input_type=Boolean(optional=True), prefix="--symbolic_alleles", doc=InputDocumentation(doc="Use symbolic alleles, such as <DEL> or <INV> in the\nVCF output (default: False). By default, deletions,\ninsertions, and inversions are represented by their\nnucleotide sequence in the output VCF.")), ToolInput(tag="in_duplications_as_insertions", input_type=Boolean(optional=True), prefix="--duplications_as_insertions", doc=InputDocumentation(doc="Represent tandem and interspersed duplications as\ninsertions in output VCF (default: False). By default,\nduplications are represented by the SVTYPE=DUP and the\ngenomic source is given by the POS and END tags. When\nenabling this option, duplications are instead\nrepresented by the SVTYPE=INS and POS and END both\ngive the insertion point of the duplication.")), ToolInput(tag="in_query_names", input_type=Boolean(optional=True), prefix="--query_names", doc=InputDocumentation(doc="Output names of supporting query sequences in INFO tag\nof VCF (default: False). If enabled, the INFO/READS\ntag contains the list of names of the supporting query\nsequences.\n")), ToolInput(tag="in_working_dir", input_type=String(), position=0, doc=InputDocumentation(doc="Working and output directory. Existing files in the\ndirectory are overwritten. If the directory does not\nexist, it is created.")), ToolInput(tag="in_bam_file", input_type=String(), position=1, doc=InputDocumentation(doc="SAM/BAM file with alignment of query assembly to\nreference assembly (needs to be coordinate-sorted)")), ToolInput(tag="in_genome", input_type=String(), position=2, doc=InputDocumentation(doc="Reference genome file that the assembly was aligned to\n(FASTA)"))], outputs=[ToolOutput(tag="out_sample", output_type=File(optional=True), selector=InputSelector(input_to_select="in_sample", type_hint=File()), doc=OutputDocumentation(doc="Sample ID to include in output vcf file (default:\nSample)"))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Svim_Asm_Haploid_V0_1_0().translate("wdl", allow_empty_container=True)

