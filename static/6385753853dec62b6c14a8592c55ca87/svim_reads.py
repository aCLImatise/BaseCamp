from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Int, String, Boolean, File

Svim_Reads_V0_1_0 = CommandToolBuilder(tool="svim_reads", base_command=["svim", "reads"], inputs=[ToolInput(tag="in_min_mapq", input_type=Int(optional=True), prefix="--min_mapq", doc=InputDocumentation(doc="Minimum mapping quality of reads to consider (default:\n20). Reads with a lower mapping quality are ignored.")), ToolInput(tag="in_min_sv_size", input_type=Int(optional=True), prefix="--min_sv_size", doc=InputDocumentation(doc="Minimum SV size to detect (default: 40). SVIM can\npotentially detect events of any size but is limited\nby the signal-to-noise ratio in the input alignments.\nThat means that more accurate reads and alignments\nenable the detection of smaller events. For current\nPacBio or Nanopore data, we would recommend a minimum\nsize of 40bp or larger.")), ToolInput(tag="in_max_sv_size", input_type=Int(optional=True), prefix="--max_sv_size", doc=InputDocumentation(doc="Maximum SV size to detect (default: 100000). This\nparameter is used to distinguish long deletions (and\ninversions) from translocations which cannot be\ndistinguished from the alignment alone. Split read\nsegments mapping far apart on the reference could\neither indicate a very long deletion (inversion) or a\ntranslocation breakpoint. SVIM calls a translocation\nbreakpoint if the mapping distance is larger than this\nparameter and a deletion (or inversion) if it is\nsmaller or equal.")), ToolInput(tag="in_cores", input_type=Int(optional=True), prefix="--cores", doc=InputDocumentation(doc="CPU cores to use for the alignment (default: 1)")), ToolInput(tag="in_aligner", input_type=String(optional=True), prefix="--aligner", doc=InputDocumentation(doc="Tool for read alignment: ngmlr or minimap2 (default:\nngmlr)")), ToolInput(tag="in_nano_pore", input_type=Boolean(optional=True), prefix="--nanopore", doc=InputDocumentation(doc="Use Nanopore settings for read alignment (default:\nFalse)")), ToolInput(tag="in_segment_gap_tolerance", input_type=Int(optional=True), prefix="--segment_gap_tolerance", doc=InputDocumentation(doc="Maximum tolerated gap between adjacent alignment\nsegments (default: 10). This parameter applies to gaps\non the reference and the read. Example: Deletions are\ndetected from two subsequent segments of a split read\nthat are mapped far apart from each other on the\nreference. The segment gap tolerance determines the\nmaximum tolerated length of the read gap between both\nsegments. If there is an unaligned read segment larger\nthan this value between the two segments, no deletion\nis called.")), ToolInput(tag="in_segment_overlap_tolerance", input_type=Int(optional=True), prefix="--segment_overlap_tolerance", doc=InputDocumentation(doc="Maximum tolerated overlap between adjacent alignment\nsegments (default: 5). This parameter applies to\noverlaps on the reference and the read. Example:\nDeletions are detected from two subsequent segments of\na split read that are mapped far apart from each other\non the reference. The segment overlap tolerance\ndetermines the maximum tolerated length of an overlap\nbetween both segments on the read. If the overlap\nbetween the two segments on the read is larger than\nthis value, no deletion is called.")), ToolInput(tag="in_partition_max_distance", input_type=Int(optional=True), prefix="--partition_max_distance", doc=InputDocumentation(doc="Maximum distance in bp between SVs in a partition\n(default: 5000). Before clustering, the SV signatures\nare divided into coarse partitions. This parameter\ndetermines the maximum distance between two subsequent\nsignatures in the same partition. If the distance\nbetween two subsequent signatures is larger than this\nparameter, they are distributed into separate\npartitions.")), ToolInput(tag="in_distance_normalizer", input_type=Int(optional=True), prefix="--distance_normalizer", doc=InputDocumentation(doc="Distance normalizer used for span-position distance\n(default: 900). SVIM clusters the SV signatures using\nan hierarchical clustering approach and a novel\ndistance metric called 'span-position distance'. Span-\nposition distance is the sum of two components, span\ndistance and position distance. The span distance is\nthe difference in lengths between signatures\nnormalized by the greater length and always lies in\nthe interval [0,1]. The position distance is the\ndifference in position between signatures normalized\nby the distance normalizer (this parameter). For a\nposition difference of 1.8kb and a distance normalizer\nof 900, the position distance will be 2. A smaller\ndistance normalizer leads to a higher position\ndistance and as a consequence increases the importance\nof the position distance in the span-position distance\nrelative to the span distance.")), ToolInput(tag="in_cluster_max_distance", input_type=Int(optional=True), prefix="--cluster_max_distance", doc=InputDocumentation(doc="Maximum span-position distance between SVs in a\ncluster (default: 0.3). This is the most important\nparameter because it determines the strictness of\nclustering. Choosing a large value leads to fewer but\nlarger clusters with larger distances between its\nmembers. Choosing a small value leads to more but\nsmaller clusters with smaller distances between its\nmembers. This parameter determines the height of the\ncut-off in the hierarchical clustering dendrogram.")), ToolInput(tag="in_del_ins_dup_max_distance", input_type=Int(optional=True), prefix="--del_ins_dup_max_distance", doc=InputDocumentation(doc="Maximum span-position distance between the origin of\nan insertion and a deletion to be flagged as a\npotential cut&paste insertion (default: 1.0)")), ToolInput(tag="in_trans_destination_partition_max_distance", input_type=Int(optional=True), prefix="--trans_destination_partition_max_distance", doc=InputDocumentation(doc="Maximum distance in bp between translocation\nbreakpoint destinations in a partition (default: 1000)")), ToolInput(tag="in_trans_partition_max_distance", input_type=Int(optional=True), prefix="--trans_partition_max_distance", doc=InputDocumentation(doc="Maximum distance in bp between translocation\nbreakpoints in a partition (default: 200)")), ToolInput(tag="in_trans_sv_max_distance", input_type=Int(optional=True), prefix="--trans_sv_max_distance", doc=InputDocumentation(doc="Maximum distance in bp between a translocation\nbreakpoint and an SV signature to be combined\n(default: 500)")), ToolInput(tag="in_skip_genotyping", input_type=Boolean(optional=True), prefix="--skip_genotyping", doc=InputDocumentation(doc="Disable genotyping (default: False)")), ToolInput(tag="in_minimum_score", input_type=Int(optional=True), prefix="--minimum_score", doc=InputDocumentation(doc="Minimum score for genotyping (default: 3). Only SV\ncandidates with a higher or equal score are genotyped.\nDepending on the score distribution among the SV\ncandidates, decreasing this value increases the\nruntime. We recommend to choose a value close to the\nscore threshold used for filtering the SV candidates.")), ToolInput(tag="in_homozygous_threshold", input_type=Int(optional=True), prefix="--homozygous_threshold", doc=InputDocumentation(doc="Minimum variant allele frequency to be called as\nhomozygous (default: 0.8). Allele frequency is\ncomputed as the fraction of reads supporting the\nvariant over the total number of reads covering the\nvariant. Variants with an allele frequence greater\nthan or equal to this threshold are called as\nhomozygous alternative.")), ToolInput(tag="in_heterozygous_threshold", input_type=Int(optional=True), prefix="--heterozygous_threshold", doc=InputDocumentation(doc="Minimum variant allele frequency to be called as\nheterozygous (default: 0.2). Allele frequency is\ncomputed as the fraction of reads supporting the\nvariant over the total number of reads covering the\nvariant. Variants with an allele frequence greater\nthan or equal to this threshold but lower than the\nhomozygous threshold are called as heterozygous\nalternative. Variants with an allele frequence lower\nthan this threshold are called as homozygous\nreference.")), ToolInput(tag="in_minimum_depth", input_type=Int(optional=True), prefix="--minimum_depth", doc=InputDocumentation(doc="Minimum total read depth for genotyping (default: 4).\nVariants covered by a total number of reads lower than\nthis value are not assigned a genotype (./. in the\noutput VCF file).")), ToolInput(tag="in_sample", input_type=File(optional=True), prefix="--sample", doc=InputDocumentation(doc="Sample ID to include in output vcf file (default:\nSample)")), ToolInput(tag="in_types", input_type=Int(optional=True), prefix="--types", doc=InputDocumentation(doc="SV types to include in output VCF (default:\nDEL,INS,INV,DUP:TANDEM,DUP:INT,BND). Give a comma-\nseparated list of SV types. The possible SV types are:\nDEL (deletions), INS (novel insertions), INV\n(inversions), DUP:TANDEM (tandem duplications),\nDUP:INT (interspersed duplications), BND (breakends).")), ToolInput(tag="in_sequence_alleles", input_type=Boolean(optional=True), prefix="--sequence_alleles", doc=InputDocumentation(doc="Use nucleotide sequences for alleles of deletions,\ninversions and insertions in output VCF (default:\nFalse). By default, all SVs are represented by\nsymbolic alleles, such as <DEL>, <INV> or <INS>. If\nenabled, ALT alleles of insertions are obtained from\nthe sequence of a random read that supports the\nvariant.")), ToolInput(tag="in_insertion_sequences", input_type=Boolean(optional=True), prefix="--insertion_sequences", doc=InputDocumentation(doc="Output insertion sequences in INFO tag of VCF\n(default: False). If enabled, the INFO/SEQS tag\ncontains a list of insertion sequences from the\nsupporting reads. However, the insertion sequences are\nnot combined into a consensus sequence.")), ToolInput(tag="in_tandem_duplications_as_insertions", input_type=Boolean(optional=True), prefix="--tandem_duplications_as_insertions", doc=InputDocumentation(doc="Represent tandem duplications as insertions in output\nVCF (default: False). By default, tandem duplications\nare represented by the SVTYPE=DUP:TANDEM and the\ngenomic source is given by the POS and END tags. When\nenabling this option, duplications are instead\nrepresented by the SVTYPE=INS and POS and END both\ngive the insertion point of the duplication.")), ToolInput(tag="in_interspersed_duplications_as_insertions", input_type=Boolean(optional=True), prefix="--interspersed_duplications_as_insertions", doc=InputDocumentation(doc="Represent interspersed duplications as insertions in\noutput VCF (default: False). By default, interspersed\nduplications are represented by the SVTYPE=DUP:INT and\nthe genomic source is given by the POS and END tags.\nWhen enabling this option, duplications are instead\nrepresented by the SVTYPE=INS and POS and END both\ngive the insertion point of the duplication.")), ToolInput(tag="in_read_names", input_type=Boolean(optional=True), prefix="--read_names", doc=InputDocumentation(doc="Output names of supporting reads in INFO tag of VCF\n(default: False). If enabled, the INFO/READS tag\ncontains the list of names of the supporting reads.")), ToolInput(tag="in_z_mws", input_type=Boolean(optional=True), prefix="--zmws", doc=InputDocumentation(doc="look for information on ZMWs in PacBio read names\n(default: False). If enabled, the INFO/ZMWS tag\ncontains the number of ZMWs that produced supporting\nreads.\n")), ToolInput(tag="in_working_dir", input_type=String(), position=0, doc=InputDocumentation(doc="Working and output directory. Existing files in the\ndirectory are overwritten. If the directory does not\nexist, it is created.")), ToolInput(tag="in_reads", input_type=String(), position=1, doc=InputDocumentation(doc="Read file (FASTA, FASTQ, gzipped FASTA, gzipped FASTQ\nor file list). The read file has to have one of the\nfollowing supported file endings: FASTA: .fa, .fasta,\n.FA, .fa.gz, .fa.gzip, .fasta.gz, .fasta.gzip FASTQ:\n.fq, .fastq, .FQ, .fq.gz, .fq.gzip, .fastq.gz,\n.fastq.gzip FILE LIST: .fa.fn, fq.fn")), ToolInput(tag="in_genome", input_type=String(), position=2, doc=InputDocumentation(doc="Reference genome file (FASTA)"))], outputs=[ToolOutput(tag="out_sample", output_type=File(optional=True), selector=InputSelector(input_to_select="in_sample", type_hint=File()), doc=OutputDocumentation(doc="Sample ID to include in output vcf file (default:\nSample)"))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Svim_Reads_V0_1_0().translate("wdl", allow_empty_container=True)

