from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean, String

Extract_Bad_Reads_V0_1_0 = CommandToolBuilder(tool="extract_bad_reads", base_command=["extract-bad-reads"], inputs=[ToolInput(tag="in_extract_reads_instead", input_type=Boolean(optional=True), prefix="-a", doc=InputDocumentation(doc="[ --all ]                        Extract all reads instead of only 'bad'")), ToolInput(tag="in_arg_maximal_internal", input_type=Boolean(optional=True), prefix="-s", doc=InputDocumentation(doc="[ --max_span ] arg (=50000)      Maximal internal segment. Read pairs with\nlarger internal segment will be ignored.")), ToolInput(tag="in_arg_number_threads", input_type=Boolean(optional=True), prefix="-T", doc=InputDocumentation(doc="[ --threads ] arg (=0)           Number of threads (default: 0 = strictly\nsingle-threaded).")), ToolInput(tag="in_arg_size_excludingreads", input_type=Boolean(optional=True), prefix="-m", doc=InputDocumentation(doc="[ --min_insert_size ] arg (=-1)  Minimum internal segment size (excluding\nreads) for a pair to be considered good\n(and thus not be extracted).")), ToolInput(tag="in_arg_maximum_excludingreads", input_type=Boolean(optional=True), prefix="-M", doc=InputDocumentation(doc="[ --max_insert_size ] arg (=-1)  Maximum internal segment size (excluding\nreads) for a pair to be considered good\n(and thus not be extracted).")), ToolInput(tag="in_arg_minimum_mapping", input_type=Boolean(optional=True), prefix="-Q", doc=InputDocumentation(doc="[ --min_mapq ] arg (=30)         Minimum mapping quality for good reads\n(which are not to be extracted).")), ToolInput(tag="in_arg_maximum_allowed", input_type=Boolean(optional=True), prefix="-e", doc=InputDocumentation(doc="[ --max_edit_distance ] arg (=3) Maximum allowed edit distance, reads with\nlarger distance will be extracted.")), ToolInput(tag="in_arg_filename_write", input_type=Boolean(optional=True), prefix="-S", doc=InputDocumentation(doc="[ --split_file ] arg             Filename to write (gzipped) split reads\nto (FASTQ format).")), ToolInput(tag="in_arg_length_prefixsuffix", input_type=Boolean(optional=True), prefix="-l", doc=InputDocumentation(doc="[ --split_length ] arg (=35)     Length of prefix/suffix to be extracted\n(if option -S is used).")), ToolInput(tag="in_encode_read_groups", input_type=Boolean(optional=True), prefix="-r", doc=InputDocumentation(doc="[ --read_groups ]                Encode read groups in read_names (as\n'<readgroup>_<name>').")), ToolInput(tag="in_arg_distribute_output", input_type=Boolean(optional=True), prefix="-D", doc=InputDocumentation(doc="[ --distribute_output ] arg (=0) Distribute output over multiple files\naccording to [off|readgroup|sample].")), ToolInput(tag="in_also_use_reads", input_type=Boolean(optional=True), prefix="-H", doc=InputDocumentation(doc="[ --use_hard_clipped ]           Also use hard clipped reads (default:\nignore hard clipped reads).\n")), ToolInput(tag="in_ones_dot", input_type=String(), position=0, doc=InputDocumentation(doc="-u [ --unsorted ]                   Input is not sorted by position but "))], outputs=[], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Extract_Bad_Reads_V0_1_0().translate("wdl", allow_empty_container=True)

