from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Int, Boolean, Float, String

Abpoa_V0_1_0 = CommandToolBuilder(tool="abpoa", base_command=["abpoa"], inputs=[ToolInput(tag="in_aln_mode", input_type=Int(optional=True), prefix="--aln-mode", doc=InputDocumentation(doc="alignment mode [0]\n0: global, 1: local, 2: extension")), ToolInput(tag="in_match", input_type=Boolean(optional=True), prefix="--match", doc=InputDocumentation(doc="INT       match score [2]")), ToolInput(tag="in_mismatch", input_type=Int(optional=True), prefix="--mismatch", doc=InputDocumentation(doc="mismatch penalty [4]")), ToolInput(tag="in_gap_open", input_type=Int(optional=True), prefix="--gap-open", doc=InputDocumentation(doc="(,INT) gap opening penalty (O1,O2) [4,24]")), ToolInput(tag="in_gap_ext", input_type=Boolean(optional=True), prefix="--gap-ext", doc=InputDocumentation(doc="INT(,INT) gap extension penalty (E1,E2) [2,1]\nabPOA provides three gap penalty modes, cost of a g-long gap:\n- convex (default): min{O1+g*E1, O2+g*E2}\n- affine (set O2 as 0): O1+g*E1\n- linear (set O1 as 0): g*E1")), ToolInput(tag="in_amb_strand", input_type=Boolean(optional=True), prefix="--amb-strand", doc=InputDocumentation(doc="ambiguous strand mode [False]\nfor each input sequence, try the reverse complement if the current\nalignment score is too low, and pick the strand with a higher score")), ToolInput(tag="in_extra_b", input_type=Boolean(optional=True), prefix="--extra-b", doc=InputDocumentation(doc="INT       first adaptive banding parameter [10]\nset b as < 0 to disable adaptive banded DP")), ToolInput(tag="in_extra_f", input_type=Boolean(optional=True), prefix="--extra-f", doc=InputDocumentation(doc="FLOAT     second adaptive banding parameter [0.01]\nthe number of extra bases added on both sites of the band is\nb+f*L, where L is the length of the aligned sequence")), ToolInput(tag="in_in_list", input_type=Boolean(optional=True), prefix="--in-list", doc=InputDocumentation(doc="input file is a list of sequence file names [False]\neach line is one sequence file containing a set of sequences\nwhich will be aligned by abPOA to generate a consensus sequence")), ToolInput(tag="in_in_crm_nt", input_type=Boolean(optional=True), prefix="--incrmnt", doc=InputDocumentation(doc="FILE      incrementally align sequences to an existing graph/MSA [Null]\ngraph could be in GFA or MSA format generated by abPOA")), ToolInput(tag="in_output", input_type=Boolean(optional=True), prefix="--output", doc=InputDocumentation(doc="FILE      ouput to FILE [stdout]")), ToolInput(tag="in_result", input_type=Boolean(optional=True), prefix="--result", doc=InputDocumentation(doc="INT       output result mode [0]\n- 0: consensus (FASTA format)\n- 1: MSA (PIR format)\n- 2: both 0 & 1\n- 3: graph (GFA format)\n- 4: graph with consensus path (GFA format)")), ToolInput(tag="in_msa_header", input_type=Boolean(optional=True), prefix="--msa-header", doc=InputDocumentation(doc="add read ID as header of each sequence in MSA output [False]")), ToolInput(tag="in_out_pog", input_type=Boolean(optional=True), prefix="--out-pog", doc=InputDocumentation(doc="FILE      dump final alignment graph to FILE (.pdf/.png) [Null]")), ToolInput(tag="in_cons_alg", input_type=Int(optional=True), prefix="--cons-alg", doc=InputDocumentation(doc="algorithm to use for consensus calling [0]\n- 0: heaviest bundling\n- 1: heaviest in column")), ToolInput(tag="in_diploid", input_type=Boolean(optional=True), prefix="--diploid", doc=InputDocumentation(doc="input data is diploid [False]")), ToolInput(tag="in_min_freq", input_type=Float(optional=True), prefix="--min-freq", doc=InputDocumentation(doc="min frequency of each consensus for diploid input [0.30]")), ToolInput(tag="in_in_dot_f_a_slash_fq", input_type=String(), position=0, doc=InputDocumentation(doc=""))], outputs=[], container="quay.io/biocontainers/abpoa:1.1.0--hed695b0_0", version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Abpoa_V0_1_0().translate("wdl")

