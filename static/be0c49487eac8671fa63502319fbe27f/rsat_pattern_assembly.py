from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean, File, String

Rsat_Pattern_Assembly_V0_1_0 = CommandToolBuilder(tool="rsat_pattern_assembly", base_command=["rsat", "pattern-assembly"], inputs=[ToolInput(tag="in_help", input_type=Boolean(optional=True), prefix="-help", doc=InputDocumentation(doc="(must be first argument) display options")), ToolInput(tag="in_verbose", input_type=Boolean(optional=True), prefix="-v", doc=InputDocumentation(doc="verbose")), ToolInput(tag="in_specified_standard_input", input_type=File(optional=True), prefix="-i", doc=InputDocumentation(doc="if not specified, the standard input is used.\nThis allows to place the command within a pipe.")), ToolInput(tag="in_specified_standard_output", input_type=File(optional=True), prefix="-o", doc=InputDocumentation(doc="if not specified, the standard output is used.\nThis allows to place the command within a pipe.")), ToolInput(tag="in_two_str", input_type=Boolean(optional=True), prefix="-2str", doc=InputDocumentation(doc="strand insensitive assembly (default).\nWith the strand insensitive option, patterns can be\nused either in direct or reverse complement\norientation for assembly. For each pattern, the\norientation which offers the best match is chosen.")), ToolInput(tag="in_one_str", input_type=Boolean(optional=True), prefix="-1str", doc=InputDocumentation(doc="strand sensitive assembly.")), ToolInput(tag="in_sc", input_type=Boolean(optional=True), prefix="-sc", doc=InputDocumentation(doc="#   score column\nPattern assembly is a NP-hard problem, i.e. the time\nof calculation increases exponentially with the number\nof patterns. Beyond a certain number of patterns, it\nis impossible to envisage all possible assemblie in\norder to select the best ones. pattern-assembly\nimplements a heuristic which is sensitive to the order\nof entry of the patterns. When a score column is\nspecified, patterns are incorporated accordingly to\ntheir scores (higher scores are incorporated first.")), ToolInput(tag="in_cc", input_type=Boolean(optional=True), prefix="-cc", doc=InputDocumentation(doc="cluster column\nDefine a column containing cluster names or numbers.\nIf cluster column is specified, each cluster is\ntreated as a separate set of patterns for assembly.")), ToolInput(tag="in_max_fl", input_type=Boolean(optional=True), prefix="-maxfl", doc=InputDocumentation(doc="#\nmaximum flanking segment size (default 1).\nThe flanking segment is the portion of a fragment that\nextends outside of the assembly on which it is aligned.")), ToolInput(tag="in_subst", input_type=Boolean(optional=True), prefix="-subst", doc=InputDocumentation(doc="#\nmaximum allowed substitutions (default 0).")), ToolInput(tag="in_match", input_type=Boolean(optional=True), prefix="-match", doc=InputDocumentation(doc="#\nminimum number of matching residues to include a\npattern in an assembly (default 0).")), ToolInput(tag="in_weight", input_type=Boolean(optional=True), prefix="-weight", doc=InputDocumentation(doc="#\nminimum matching weight to include a pattern in an\nassembly (default 0). The weight is the sum\nof informative residue matches. A single-letter match\nhas weight 1. Matches between ambiguous nucleotides\nhave lower weight (for example A versus [AT] has\nweight 0.5).")), ToolInput(tag="in_max_as_mb_nb", input_type=Boolean(optional=True), prefix="-max_asmb_nb", doc=InputDocumentation(doc="#\nmaximal number of assemblies (default: 5)")), ToolInput(tag="in_max_as_mb_per_cluster", input_type=Boolean(optional=True), prefix="-max_asmb_per_cluster", doc=InputDocumentation(doc="#\nmaximal number of assemblies per cluster\n(default: 2).\nThis option is only valid in combination with the\noption -cc.")), ToolInput(tag="in_max_as_mb_size", input_type=Boolean(optional=True), prefix="-max_asmb_size", doc=InputDocumentation(doc="#\nmaximal assembly size, i.e. the number of patterns per\nalignment group (default: 50)")), ToolInput(tag="in_max_as_mb_width", input_type=Boolean(optional=True), prefix="-max_asmb_width", doc=InputDocumentation(doc="#\nmaximal width for an assembly (default: 0)")), ToolInput(tag="in_single_sep", input_type=Boolean(optional=True), prefix="-single_sep", doc=InputDocumentation(doc="Report the isolated words (i.e. words that do not\nmatch any other words) separately. This was the\ndefault behaviour of the program before April 2011.\nThe separate list of isolaed words presents the\nadvantage of compacity (no need to create one assembly\nfor each isolated word), but a drawback is that some\nsignificant single words may appear after less\nsignificant assemblies of several words, and thus be\nignored for further processing (e.g. by\nmatrix-from-patterns).")), ToolInput(tag="in_top_pat", input_type=Boolean(optional=True), prefix="-toppat", doc=InputDocumentation(doc="#\nDefault: 100\nmaximum number of patterns to assemble.  If the number\nof patterns in the input file exceeds the maximal\nnumber, the assembly is restrictedd with the top patterns\nonly.")), ToolInput(tag="in_max_pat", input_type=Boolean(optional=True), prefix="-maxpat", doc=InputDocumentation(doc="#\nmaximum number of allowed patterns (default\n0).  If the number of patterns in the\ninput file exceeds the maximal number, the program\ndoes not performa ny assembly, and returns a\ncancellation message.")), ToolInput(tag="in_pattern_assembly", input_type=String(), position=0, doc=InputDocumentation(doc="1998 by Jacques van Helden (Jacques.van-Helden@univ-amu.fr)")), ToolInput(tag="in_sequences", input_type=String(), position=0, doc=InputDocumentation(doc="OPTIONS")), ToolInput(tag="in_submitted_dot", input_type=String(), position=0, doc=InputDocumentation(doc="These options are mutually incompatible."))], outputs=[ToolOutput(tag="out_specified_standard_output", output_type=File(optional=True), selector=InputSelector(input_to_select="in_specified_standard_output", type_hint=File()), doc=OutputDocumentation(doc="if not specified, the standard output is used.\nThis allows to place the command within a pipe."))], container=None, version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Rsat_Pattern_Assembly_V0_1_0().translate("wdl", allow_empty_container=True)

