!Command
positional: []
named: []
command:
- stag-diff.pl
parent:
subcommands: []
help_flag:
usage_flag:
version_flag:
help_text: "\e[1mNAME\e[0m\n    stag-diff - finds the difference between two stag\
  \ files\n\n\e[1mSYNOPSIS\e[0m\n      stag-diff -ignore foo-id -ignore bar-id file1.xml\
  \ file2.xml\n\n\e[1mDESCRIPTION\e[0m\n    Compares two data trees and reports whether\
  \ they match. If they do not\n    match, the mismatch is reported.\n\n    -help|h\n\
  \        shows this document\n\n    -ignore|i ELEMENT\n        these nodes are ignored\
  \ for the purposes of comparison. Note that\n        attributes are treated as elements,\
  \ prefixed by the containing element\n        id. For example, if you have\n\n \
  \         <foo ID=\"wibble\">\n\n        And you wish to ignore the ID attribute,\
  \ then you would use the switch\n\n          -ignore foo-ID\n\n        You can specify\
  \ multiple elements to ignore like this\n\n          -i foo -i bar -i baz\n\n  \
  \      You can also specify paths\n\n          -i foo/bar/bar-id\n\n    -parser|p\
  \ FORMAT\n        which parser to use. The default is XML. This can also be autodetected\n\
  \        by the file suffix. Other alternatives are \e[1msxpr\e[0m and \e[1mitext\e\
  [0m. See\n        Data::Stag for details.\n\n    -report|r ELEMENT\n        report\
  \ mismatches as they occur on each element of type ELEMENT\n\n        multiple elements\
  \ can be specified\n\n    -verbose|v\n        used in conjunction with the \e[1m-report\e\
  [0m switch\n\n        shows the tree of the mismatching element\n\n  \e[1mOUTPUT\e\
  [0m\n    If a mismatch is reported, a report is generated displaying the subpart\
  \ of\n    the tree that could not be matched. This will look like this:\n\n    REASON:\
  \ no_matching_node: annotation no_matching_node: feature_set\n    no_matching_node:\
  \ feature_span no_matching_node: evidence\n    no_matching_node: evidence-id data_mismatch(:15077290\
  \ ne :15077291):\n    evidence-id AND evidence-id\n\n    Due to the nature of tree\
  \ matching, it can be difficult to specify exactly\n    how trees do not match.\
  \ To investigate this, you may need to use the\n    \e[1m-r\e[0m and \e[1m-v\e[0m\
  \ options. For the above output, I would recommend using\n\n      stag-diff -r feature_span\
  \ -v\n\n  \e[1mALGORITHM\e[0m\n    Both trees are recursively traversed... see the\
  \ actual code for how this\n    works\n\n    The order of elements is not important;\
  \ eg\n\n      <foo>\n        <bar>\n          <baz>1</baz>\n        </bar>\n   \
  \     <bar>\n          <baz>2</baz>\n        </bar>\n      </foo>\n\n    matches\n\
  \n      <foo>\n        <bar>\n          <baz>2</baz>\n        </bar>\n        <bar>\n\
  \          <baz>1</baz>\n        </bar>\n      </foo>\n\n    The recursive nature\
  \ of this algorithm means that certain tree comparisons\n    will explode wrt time\
  \ and memory. I think this will only happen with very\n    deep trees where nodes\
  \ high up in the tree can only be differentiated by\n    nodes low down in the tree.\n\
  \n    Both trees are loaded into memory to begin with, so it may thrash with\n \
  \   very large documents\n\n  \e[1mAUTHOR\e[0m\n    Chris Mungall cjm at fruitfly\
  \ dot org\n\n\e[1mSEE ALSO\e[0m\n    Data::Stag\n\n\e[1mPOD ERRORS\e[0m\n    Hey!\
  \ \e[1mThe above document had some coding errors, which are explained\n    below:\e\
  [0m\n\n    Around line 189:\n        =over should be: '=over' or '=over positive_number'\n\
  \n"
generated_using:
- --help
