from datetime import datetime
from typing import List, Optional, Dict, Any

from janis_core import *
from janis_core.types.common_data_types import Boolean, File, String, Directory, Int, Float

Shasta_V0_1_0 = CommandToolBuilder(tool="shasta", base_command=["shasta"], inputs=[ToolInput(tag="in_identify_shasta_version", input_type=Boolean(optional=True), prefix="-v", doc=InputDocumentation(doc="[ --version ]                      Identify the Shasta version.")), ToolInput(tag="in_config", input_type=File(optional=True), prefix="--config", doc=InputDocumentation(doc="Configuration file name.")), ToolInput(tag="in_input", input_type=String(optional=True), prefix="--input", doc=InputDocumentation(doc="Names of input files containing reads.\nSpecify at least one.")), ToolInput(tag="in_assembly_directory", input_type=Directory(optional=True), prefix="--assemblyDirectory", doc=InputDocumentation(doc="(=ShastaRun)  Name of the output directory. If\ncommand is assemble, this directory\nmust not exist.")), ToolInput(tag="in_command", input_type=String(optional=True), prefix="--command", doc=InputDocumentation(doc="(=assemble)             Command to run. Must be one of:\nassemble, saveBinaryData,\ncleanupBinaryData, explore,\ncreateBashCompletionScript")), ToolInput(tag="in_memory_mode", input_type=String(optional=True), prefix="--memoryMode", doc=InputDocumentation(doc="(=anonymous)         Specify whether allocated memory is\nanonymous or backed by a filesystem.\nAllowed values: anonymous, filesystem.")), ToolInput(tag="in_memory_backing", input_type=Int(optional=True), prefix="--memoryBacking", doc=InputDocumentation(doc="(=4K)             Specify the type of pages used to back")), ToolInput(tag="in_threads", input_type=Int(optional=True), prefix="--threads", doc=InputDocumentation(doc="(=0)                    Number of threads, or 0 to use one\nthread per virtual processor.")), ToolInput(tag="in_explore_access", input_type=String(optional=True), prefix="--exploreAccess", doc=InputDocumentation(doc="(=user)           Specify allowed access for --command\nexplore. Allowed values: user, local,\nunrestricted. DO NOT CHANGE FROM\nDEFAULT VALUE WITHOUT UNDERSTANDING THE\nSECURITY IMPLICATIONS.")), ToolInput(tag="in_port", input_type=Int(optional=True), prefix="--port", doc=InputDocumentation(doc="(=17100)                   Port to be used by the http server\n(command --explore).")), ToolInput(tag="in_reads_dot_palindromic_reads_dot_skip_flagging", input_type=Boolean(optional=True), prefix="--Reads.palindromicReads.skipFlagging", doc=InputDocumentation(doc="Skip flagging palindromic reads. Oxford\nNanopore reads should be flagged for\nbetter results.")), ToolInput(tag="in_reads_dot_palindromic_reads_dot_max_skip", input_type=Int(optional=True), prefix="--Reads.palindromicReads.maxSkip", doc=InputDocumentation(doc="(=100)\nUsed for palindromic read detection.")), ToolInput(tag="in_reads_dot_palindromic_reads_dot_max_drift", input_type=Int(optional=True), prefix="--Reads.palindromicReads.maxDrift", doc=InputDocumentation(doc="(=100)\nUsed for palindromic read detection.")), ToolInput(tag="in_reads_dot_palindromic_reads_dot_max_marker_frequency", input_type=Int(optional=True), prefix="--Reads.palindromicReads.maxMarkerFrequency", doc=InputDocumentation(doc="(=10)\nUsed for palindromic read detection.")), ToolInput(tag="in_reads_dot_palindromic_reads_dot_aligned_fraction_threshold", input_type=Float(optional=True), prefix="--Reads.palindromicReads.alignedFractionThreshold", doc=InputDocumentation(doc="(=0.1)\nUsed for palindromic read detection.")), ToolInput(tag="in_reads_dot_palindromic_reads_dot_near_diagonal_fraction_threshold", input_type=Float(optional=True), prefix="--Reads.palindromicReads.nearDiagonalFractionThreshold", doc=InputDocumentation(doc="(=0.1)\nUsed for palindromic read detection.")), ToolInput(tag="in_reads_dot_palindromic_reads_dot_delta_threshold", input_type=Int(optional=True), prefix="--Reads.palindromicReads.deltaThreshold", doc=InputDocumentation(doc="(=100)\nUsed for palindromic read detection.")), ToolInput(tag="in_km_ers_dot_generation_method", input_type=File(optional=True), prefix="--Kmers.generationMethod", doc=InputDocumentation(doc="(=0)     Method to generate marker k-mers: 0 =\nrandom, 1 = random, excluding globally\noverenriched,2 = random, excluding\noverenriched even in a single read,3 =\nread from file.")), ToolInput(tag="in_km_ers_dot_k", input_type=Int(optional=True), prefix="--Kmers.k", doc=InputDocumentation(doc="(=10)                   Length of marker k-mers (in run-length\nspace).")), ToolInput(tag="in_km_ers_dot_probability", input_type=Float(optional=True), prefix="--Kmers.probability", doc=InputDocumentation(doc="(=0.1)        Fraction k-mers used as a marker.")), ToolInput(tag="in_km_ers_dot_enrichment_threshold", input_type=Int(optional=True), prefix="--Kmers.enrichmentThreshold", doc=InputDocumentation(doc="(=100.)\nEnrichment threshold for\nKmers.generationMethod 1 and 2.")), ToolInput(tag="in_km_ers_dotfile", input_type=File(optional=True), prefix="--Kmers.file", doc=InputDocumentation(doc="The absolute path of a file containing\nthe k-mers to be used as markers, one\nper line. A relative path is not\naccepted. Only used if\nKmers.generationMethod is 3.")), ToolInput(tag="in_min_hash_dot_version", input_type=Int(optional=True), prefix="--MinHash.version", doc=InputDocumentation(doc="(=0)            Controls the version of the LowHash\nalgorithm to use. Can be 0 (default) or\n1.(experimental).")), ToolInput(tag="in_min_hash_do_tm", input_type=Int(optional=True), prefix="--MinHash.m", doc=InputDocumentation(doc="(=4)                  The number of consecutive markers that\ndefine a MinHash/LowHash feature.")), ToolInput(tag="in_min_hash_dot_hash_fraction", input_type=Float(optional=True), prefix="--MinHash.hashFraction", doc=InputDocumentation(doc="(=0.01)    Defines how low a hash has to be to be\nused with the LowHash algorithm.")), ToolInput(tag="in_min_hash_dot_min_hash_iteration_count", input_type=Int(optional=True), prefix="--MinHash.minHashIterationCount", doc=InputDocumentation(doc="(=10)\nThe number of MinHash/LowHash\niterations, or 0 to let\n--MinHash.alignmentCandidatesPerRead\ncontrol the number of iterations.")), ToolInput(tag="in_min_hash_dot_alignment_candidates_per_read", input_type=Int(optional=True), prefix="--MinHash.alignmentCandidatesPerRead", doc=InputDocumentation(doc="(=20)\nIf --MinHash.minHashIterationCount is\n0, MinHash iteration is stopped when\nthe average number of alignment\ncandidates that each read is involved\nin reaches this value. If\n--MinHash.minHashIterationCount is not\n0, this is not used.")), ToolInput(tag="in_min_hash_dot_min_bucketsize", input_type=Int(optional=True), prefix="--MinHash.minBucketSize", doc=InputDocumentation(doc="(=0)      The minimum bucket size to be used by\nthe LowHash algoritm.")), ToolInput(tag="in_min_hash_dot_max_bucketsize", input_type=Int(optional=True), prefix="--MinHash.maxBucketSize", doc=InputDocumentation(doc="(=10)     The maximum bucket size to be used by\nthe LowHash algoritm.")), ToolInput(tag="in_min_hash_dot_min_frequency", input_type=Int(optional=True), prefix="--MinHash.minFrequency", doc=InputDocumentation(doc="(=2)       The minimum number of times a pair of\nreads must be found by the\nMinHash/LowHash algorithm in order to\nbe considered a candidate alignment.")), ToolInput(tag="in_min_hash_dot_all_pairs", input_type=Boolean(optional=True), prefix="--MinHash.allPairs", doc=InputDocumentation(doc="Skip the MinHash algorithm and mark all\npairs of reads as alignmentcandidates\nwith both orientation. This should only\nbe used for experimentation on very\nsmall runs because it is very time\nconsuming.")), ToolInput(tag="in_align_dot_align_method", input_type=Int(optional=True), prefix="--Align.alignMethod", doc=InputDocumentation(doc="(=3)          The alignment method to be used to\ncreate the read graph & the marker\ngraph. 0 = old Shasta method, 1 = SeqAn\n(slow), 3 = banded SeqAn.")), ToolInput(tag="in_align_dot_max_skip", input_type=Int(optional=True), prefix="--Align.maxSkip", doc=InputDocumentation(doc="(=30)             The maximum number of markers that an\nalignment is allowed to skip.")), ToolInput(tag="in_align_dot_max_drift", input_type=Int(optional=True), prefix="--Align.maxDrift", doc=InputDocumentation(doc="(=30)            The maximum amount of marker drift that\nan alignment is allowed to tolerate\nbetween successive markers.")), ToolInput(tag="in_align_dot_max_trim", input_type=Int(optional=True), prefix="--Align.maxTrim", doc=InputDocumentation(doc="(=30)             The maximum number of unaligned markers\ntolerated at the beginning and end of\nan alignment.")), ToolInput(tag="in_align_dot_max_marker_frequency", input_type=Int(optional=True), prefix="--Align.maxMarkerFrequency", doc=InputDocumentation(doc="(=10)  Marker frequency threshold. Markers\nmore frequent than this value in either\nof two oriented reads being aligned are\ndiscarded and not used to compute the\nalignment.")), ToolInput(tag="in_align_dot_min_aligned_marker_count", input_type=Int(optional=True), prefix="--Align.minAlignedMarkerCount", doc=InputDocumentation(doc="(=100)\nThe minimum number of aligned markers\nfor an alignment to be used.")), ToolInput(tag="in_align_dot_min_aligned_fraction", input_type=Int(optional=True), prefix="--Align.minAlignedFraction", doc=InputDocumentation(doc="(=0)   The minimum fraction of aligned markers\nfor an alignment to be used.")), ToolInput(tag="in_align_dot_match_score", input_type=Int(optional=True), prefix="--Align.matchScore", doc=InputDocumentation(doc="(=6)           Match score for marker alignments (only\nused for alignment methods 1 and 3).")), ToolInput(tag="in_align_dot_mismatch_score", input_type=Int(optional=True), prefix="--Align.mismatchScore", doc=InputDocumentation(doc="(=-1)       Mismatch score for marker alignments\n(only used for alignment methods 1 and\n3).")), ToolInput(tag="in_align_dot_gap_score", input_type=Int(optional=True), prefix="--Align.gapScore", doc=InputDocumentation(doc="(=-1)            Gap score for marker alignments (only\nused for alignment methods 1 and 3).")), ToolInput(tag="in_align_dot_downsampling_factor", input_type=Float(optional=True), prefix="--Align.downsamplingFactor", doc=InputDocumentation(doc="(=0.10000000000000001)\nDownsampling factor (only used for\nalignment method 3).")), ToolInput(tag="in_align_dot_band_extend", input_type=Int(optional=True), prefix="--Align.bandExtend", doc=InputDocumentation(doc="(=10)          Amount to extend the downsampled band\n(only used for alignment method 3).")), ToolInput(tag="in_align_dot_max_band", input_type=Int(optional=True), prefix="--Align.maxBand", doc=InputDocumentation(doc="(=1000)           Maximum alignment band (only used for\nalignment method 3).")), ToolInput(tag="in_align_dot_same_channel_read_alignment_dot_suppress_delta_threshold", input_type=Int(optional=True), prefix="--Align.sameChannelReadAlignment.suppressDeltaThreshold", doc=InputDocumentation(doc="(=0)\nIf not zero, alignments between reads\nfrom the same nanopore channel and\nclose in time are suppressed. The\n'read' meta data fields from the FASTA\nor FASTQ header are checked. If their\ndifference, in absolute value, is less\nthan the value of this option, the\nalignment is suppressed. This can help\navoid assembly artifact. This check is\nonly done if the two reads have\nidentical meta data fields 'runid',\n'sampleid', and 'ch'. If any of these\nmeta data fields are missing, this\ncheck is suppressed and this option has\nno effect.")), ToolInput(tag="in_align_dot_suppress_containments", input_type=Boolean(optional=True), prefix="--Align.suppressContainments", doc=InputDocumentation(doc="Suppress containment alignments, that\nis alignments in which one read is\nentirely contained in another read,\nexcept possibly for up to maxTrim\nmarkers at the beginning and end.")), ToolInput(tag="in_read_graph_dot_creation_method", input_type=Int(optional=True), prefix="--ReadGraph.creationMethod", doc=InputDocumentation(doc="(=0)   The method used to create the read\ngraph (0 default, 1 or 2 experimental).")), ToolInput(tag="in_read_graph_dot_max_alignment_count", input_type=Int(optional=True), prefix="--ReadGraph.maxAlignmentCount", doc=InputDocumentation(doc="(=6)\nThe maximum number of alignments to be\nkept for each read.")), ToolInput(tag="in_read_graph_dot_min_component_size", input_type=Int(optional=True), prefix="--ReadGraph.minComponentSize", doc=InputDocumentation(doc="(=100)\nThe minimum size (number of oriented\nreads) of a connected component of the\nread graph to be kept. This is\ncurrently ignored.")), ToolInput(tag="in_read_graph_dot_max_chimeric_read_distance", input_type=Int(optional=True), prefix="--ReadGraph.maxChimericReadDistance", doc=InputDocumentation(doc="(=2)\nUsed for chimeric read detection.")), ToolInput(tag="in_read_graph_dot_cross_strand_max_distance", input_type=Int(optional=True), prefix="--ReadGraph.crossStrandMaxDistance", doc=InputDocumentation(doc="(=6)\nMaximum distance (edges) for\nflagCrossStrandReadGraphEdges. Set this\nto zero to entirely suppress\nflagCrossStrandReadGraphEdges.")), ToolInput(tag="in_read_graph_dot_contained_neighbor_count", input_type=Int(optional=True), prefix="--ReadGraph.containedNeighborCount", doc=InputDocumentation(doc="(=6)\nMaximum number of alignments to be kept\nfor each contained read (only used when\ncreationMethod is 1).")), ToolInput(tag="in_read_graph_dot_uncontained_neighbor_count_per_direction", input_type=Int(optional=True), prefix="--ReadGraph.uncontainedNeighborCountPerDirection", doc=InputDocumentation(doc="(=3)\nMaximum number of alignments to be kept\nin each direction (forward, backward)\nfor each uncontained read (only used\nwhen creationMethod is 1).")), ToolInput(tag="in_read_graph_dot_remove_conflicts", input_type=Boolean(optional=True), prefix="--ReadGraph.removeConflicts", doc=InputDocumentation(doc="Remove conflicts from the read graph.\nExperimental - do not use.")), ToolInput(tag="in_read_graph_dot_marker_count_percentile", input_type=Float(optional=True), prefix="--ReadGraph.markerCountPercentile", doc=InputDocumentation(doc="(=0.015)\nPercentile for markerCount (only used\nwhen creationMethod is 2).")), ToolInput(tag="in_read_graph_dot_aligned_fraction_percentile", input_type=Float(optional=True), prefix="--ReadGraph.alignedFractionPercentile", doc=InputDocumentation(doc="(=0.12)\nPercentile for alignedFraction (only\nused when creationMethod is 2).")), ToolInput(tag="in_read_graph_dot_max_skip_percentile", input_type=Float(optional=True), prefix="--ReadGraph.maxSkipPercentile", doc=InputDocumentation(doc="(=0.12)\nPercentile for maxSkip (only used when\ncreationMethod is 2).")), ToolInput(tag="in_read_graph_dot_max_drift_percentile", input_type=Float(optional=True), prefix="--ReadGraph.maxDriftPercentile", doc=InputDocumentation(doc="(=0.12)\nPercentile for maxDrift (only used when\ncreationMethod is 2).")), ToolInput(tag="in_read_graph_dot_max_trim_percentile", input_type=Float(optional=True), prefix="--ReadGraph.maxTrimPercentile", doc=InputDocumentation(doc="(=0.015)\nPercentile for maxTrim (only used when\ncreationMethod is 2).")), ToolInput(tag="in_marker_graph_dot_min_coverage", input_type=Int(optional=True), prefix="--MarkerGraph.minCoverage", doc=InputDocumentation(doc="(=10)   Minimum coverage (number of supporting\noriented reads) for a marker graph\nvertex to be created.Specifying 0\ncauses a suitable value of this\nparameter to be selected automatically.")), ToolInput(tag="in_marker_graph_dot_max_coverage", input_type=Int(optional=True), prefix="--MarkerGraph.maxCoverage", doc=InputDocumentation(doc="(=100)  Maximum coverage (number of supporting\noriented reads) for a marker graph\nvertex.")), ToolInput(tag="in_marker_graph_dot_min_coverage_per_strand", input_type=Int(optional=True), prefix="--MarkerGraph.minCoveragePerStrand", doc=InputDocumentation(doc="(=0)\nMinimum coverage (number of supporting\noriented reads) for each strand for a\nmarker graph vertex.")), ToolInput(tag="in_marker_graph_dot_low_coverage_threshold", input_type=Int(optional=True), prefix="--MarkerGraph.lowCoverageThreshold", doc=InputDocumentation(doc="(=0)\nUsed during approximate transitive\nreduction. Marker graph edges with\ncoverage lower than this value are\nalways marked as removed regardless of\nreachability.")), ToolInput(tag="in_marker_graph_dot_high_coverage_threshold", input_type=Int(optional=True), prefix="--MarkerGraph.highCoverageThreshold", doc=InputDocumentation(doc="(=256)\nUsed during approximate transitive\nreduction. Marker graph edges with\ncoverage higher than this value are\nnever marked as removed regardless of\nreachability.")), ToolInput(tag="in_marker_graph_dot_max_distance", input_type=Int(optional=True), prefix="--MarkerGraph.maxDistance", doc=InputDocumentation(doc="(=30)   Used during approximate transitive")), ToolInput(tag="in_marker_graph_dot_simplify_maxlength", input_type=Int(optional=True), prefix="--MarkerGraph.simplifyMaxLength", doc=InputDocumentation(doc="(=10,100,1000)\nMaximum lengths (in markers) used at\neach iteration of simplifyMarkerGraph.")), ToolInput(tag="in_marker_graph_dot_cross_edge_coverage_threshold", input_type=Int(optional=True), prefix="--MarkerGraph.crossEdgeCoverageThreshold", doc=InputDocumentation(doc="(=0)\nExperimental. Cross edge coverage\nthreshold. If this is not zero,\nassembly graph cross-edges with average\nedge coverage less than this value are\nremoved, together with the\ncorresponding marker graph edges. A\ncross edge is defined as an edge v0->v1\nwith out-degree(v0)>1, in-degree(v1)>1.")), ToolInput(tag="in_marker_graph_dot_refine_threshold", input_type=Int(optional=True), prefix="--MarkerGraph.refineThreshold", doc=InputDocumentation(doc="(=0)\nExperimental. Length threshold, in\nmarkers, for the marker graph\nrefinement step, or 0 to turn off the\nrefinement step.")), ToolInput(tag="in_marker_graph_dot_reverse_transitive_reduction", input_type=Boolean(optional=True), prefix="--MarkerGraph.reverseTransitiveReduction", doc=InputDocumentation(doc="Perform approximate reverse transitive\nreduction of the marker graph.")), ToolInput(tag="in_marker_graph_dot_peak_finder_dot_min_are_a_fraction", input_type=Float(optional=True), prefix="--MarkerGraph.peakFinder.minAreaFraction", doc=InputDocumentation(doc="(=0.080000000000000002)\nUsed in the automatic selection of\n--MarkerGraph.minCoverage when\n--MarkerGraph.minCoverage is set to 0.")), ToolInput(tag="in_marker_graph_dot_peak_finder_dot_area_start_index", input_type=Int(optional=True), prefix="--MarkerGraph.peakFinder.areaStartIndex", doc=InputDocumentation(doc="(=2)\nUsed in the automatic selection of\n--MarkerGraph.minCoverage when\n--MarkerGraph.minCoverage is set to 0.")), ToolInput(tag="in_assembly_dot_cross_edge_coverage_threshold", input_type=Int(optional=True), prefix="--Assembly.crossEdgeCoverageThreshold", doc=InputDocumentation(doc="(=3)\nMaximum average edge coverage for a\ncross edge of the assembly graph to be\nremoved.")), ToolInput(tag="in_assembly_dot_marker_graph_edge_length_threshold_for_consensus", input_type=Int(optional=True), prefix="--Assembly.markerGraphEdgeLengthThresholdForConsensus", doc=InputDocumentation(doc="(=1000)\nControls assembly of long marker graph\nedges.")), ToolInput(tag="in_assembly_dot_consensus_caller", input_type=Float(optional=True), prefix="--Assembly.consensusCaller", doc=InputDocumentation(doc="(=Bayesian:guppy-2.3.5-a)\nSelects the consensus caller for repeat\ncounts. See the documentation for\navailable choices.")), ToolInput(tag="in_assembly_dot_store_coverage_data", input_type=Boolean(optional=True), prefix="--Assembly.storeCoverageData", doc=InputDocumentation(doc="Used to request storing coverage data\nin binary format.")), ToolInput(tag="in_assembly_dot_store_coverage_data_csv_length_threshold", input_type=Int(optional=True), prefix="--Assembly.storeCoverageDataCsvLengthThreshold", doc=InputDocumentation(doc="(=0)\nUsed to specify the minimum length of\nan assembled segment for which coverage\ndata in csv format should be stored. If\n0, no coverage data in csv format is\nstored.")), ToolInput(tag="in_assembly_dot_write_reads_by_assembled_segment", input_type=Boolean(optional=True), prefix="--Assembly.writeReadsByAssembledSegment", doc=InputDocumentation(doc="Used to request writing the reads that\ncontributed to assembling each segment.")), ToolInput(tag="in_assembly_dot_de_tangle_method", input_type=Int(optional=True), prefix="--Assembly.detangleMethod", doc=InputDocumentation(doc="(=0)    Specify the method used to detangle the\nassembly graph. 0 = no detangling, 1 =\nstrict detangling, 2 = less strict\ndetangling, controlled by\nAssembly.detangle.* options\n(experimental).")), ToolInput(tag="in_assembly_dot_de_tangle_dot_diagonal_read_count_min", input_type=Int(optional=True), prefix="--Assembly.detangle.diagonalReadCountMin", doc=InputDocumentation(doc="(=1)\nMinimum number of reads on detangle\nmatrix diagonal elements required for\ndetangling.")), ToolInput(tag="in_assembly_dot_de_tangle_dot_off_diagonal_read_count_max", input_type=Int(optional=True), prefix="--Assembly.detangle.offDiagonalReadCountMax", doc=InputDocumentation(doc="(=2)\nMaximum number of reads on detangle\nmatrix off-diagonal elements allowed\nfor detangling.")), ToolInput(tag="in_assembly_dot_de_tangle_dot_off_diagonal_ratio", input_type=Float(optional=True), prefix="--Assembly.detangle.offDiagonalRatio", doc=InputDocumentation(doc="(=0.29999999999999999)\nMaximum ratio of total off-diagonal\nelements over diagonal element allowed\nfor detangling.")), ToolInput(tag="in_assembly_dot_iterative", input_type=Boolean(optional=True), prefix="--Assembly.iterative", doc=InputDocumentation(doc="Used to request iterative assembly\n(experimental).")), ToolInput(tag="in_assembly_dot_iterative_dot_iteration_count", input_type=Int(optional=True), prefix="--Assembly.iterative.iterationCount", doc=InputDocumentation(doc="(=3)\nNumber of iterations for iterative\nassembly (experimental).")), ToolInput(tag="in_assembly_dot_iterative_dot_pseudo_path_align_match_score", input_type=Int(optional=True), prefix="--Assembly.iterative.pseudoPathAlignMatchScore", doc=InputDocumentation(doc="(=1)\nPseudopath alignment match score for\niterative assembly (experimental).")), ToolInput(tag="in_assembly_dot_iterative_dot_pseudo_path_align_mismatch_score", input_type=Int(optional=True), prefix="--Assembly.iterative.pseudoPathAlignMismatchScore", doc=InputDocumentation(doc="(=-1)\nPseudopath alignment mismatch score for\niterative assembly (experimental).")), ToolInput(tag="in_assembly_dot_iterative_dot_pseudo_path_align_gap_score", input_type=Int(optional=True), prefix="--Assembly.iterative.pseudoPathAlignGapScore", doc=InputDocumentation(doc="(=-1)\nPseudopath alignment gap score for\niterative assembly (experimental).")), ToolInput(tag="in_assembly_dot_iterative_dot_mismatch_square_factor", input_type=Int(optional=True), prefix="--Assembly.iterative.mismatchSquareFactor", doc=InputDocumentation(doc="(=3)\nMismatch square factor for iterative\nassembly (experimental).")), ToolInput(tag="in_assembly_dot_iterative_dot_min_score", input_type=Int(optional=True), prefix="--Assembly.iterative.minScore", doc=InputDocumentation(doc="(=0)\nMinimum pseudo-alignment score for\niterative assembly (experimental).")), ToolInput(tag="in_assembly_dot_iterative_dot_max_alignment_count", input_type=Int(optional=True), prefix="--Assembly.iterative.maxAlignmentCount", doc=InputDocumentation(doc="(=6)\nMaximum number of read graph neighbors\nfor iterative assembly (experimental).")), ToolInput(tag="in_assembly_dot_iterative_dot_bridge_removal_iteration_count", input_type=Int(optional=True), prefix="--Assembly.iterative.bridgeRemovalIterationCount", doc=InputDocumentation(doc="(=3)\nNumber of read graph bridge removal\niterations for iterative assembly\n(experimental).")), ToolInput(tag="in_assembly_dot_iterative_dot_bridge_removal_max_distance", input_type=Int(optional=True), prefix="--Assembly.iterative.bridgeRemovalMaxDistance", doc=InputDocumentation(doc="(=2)\nMaximum distance for read graph bridge\nremoval for iterative assembly\n(experimental).\n")), ToolInput(tag="in_memory_dot", input_type=String(), position=0, doc=InputDocumentation(doc="Allowed values: disk, 4K , 2M (for best")), ToolInput(tag="in_discarded_dot", input_type=String(), position=0, doc=InputDocumentation(doc="--Reads.desiredCoverage arg (=0)      Reduce coverage to desired value. If ")), ToolInput(tag="in_coverage_dot", input_type=String(), position=0, doc=InputDocumentation(doc="--Reads.noCache                       If set, skip the Linux cache when "))], outputs=[ToolOutput(tag="out_assembly_directory", output_type=Directory(optional=True), selector=InputSelector(input_to_select="in_assembly_directory", type_hint=File()), doc=OutputDocumentation(doc="(=ShastaRun)  Name of the output directory. If\ncommand is assemble, this directory\nmust not exist."))], container="quay.io/biocontainers/shasta:0.6.0--hc9558a2_0", version="v0.1.0")


if __name__ == "__main__":
    # or "cwl"
    Shasta_V0_1_0().translate("wdl")

